[
  {
    "testName": "counter",
    "provider": "LMStudio",
    "modelId": "qwen/qwen3-4b-2507",
    "numSamples": 1,
    "numCorrect": 0,
    "pass1": 0,
    "pass10": 0,
    "context": {
      "used": true,
      "content": "# Svelte 5 Anti-Patterns — focused\n\nKeep only Svelte 5–specific anti-patterns:\n\n- Do NOT import rune identifiers or use external rune libraries — runes are language-level.\n- Avoid mutating props directly; use `$bindable()` or callbacks for writable semantics.\n- Do not use `$effect` to derive state — prefer `$derived` for pure computations.\n- Avoid exporting reassigned `$state` values from `.svelte.js`/`.svelte.ts`; instead expose getters/setters to preserve reactivity.\n- Be cautious with event directive differences from Svelte 4; consult the repo's notes for specific breakages.\n\nRemoved general JS/UX guidance to keep this file tightly scoped.\n- Use modern Svelte 5 APIs instead of legacy APIs (e.g., prefer callback props over `createEventDispatcher`).\n\n\n# Svelte 5 Best Practices — distilled\n\nThis file summarizes only Svelte 5–specific guidance (runes, new reactive primitives, and breaking changes from Svelte 4).\n\nKey points\n\nTesting and debugging\n\nThis document intentionally omits generic Svelte usage to keep focus on net-new Svelte 5 behaviors.\n# Svelte 5 Best Practices — distilled\n\nThis file summarizes only Svelte 5–specific guidance (runes, new reactive primitives, and breaking changes from Svelte 4).\n\nKey points\n- Enable runes per-component: `<svelte:options runes={true} />`.\n- Runes (`$state`, `$derived`, `$effect`, `$inspect`) are language-level — do not import them.\n- Props are read-only: destructure once from `$props()`; use local `$state` copies, `$bindable()`, or callback props for writable behavior.\n- Use `$derived` for pure computed values and `$effect` for side effects (effects can return teardown functions).\n- `$inspect` and `$inspect.trace` are dev-only; `$inspect.trace` must be the first statement in a function body.\n- Be aware of syntactic differences from Svelte 4 (see other repo notes for specifics).\n\nTesting and debugging\n- Add `data-testid` attributes for stable selectors in tests.\n- Use `$effect.root` or explicit cleanup in tests to avoid cross-test leaks.\n\nThis document intentionally omits generic Svelte usage to keep focus on net-new Svelte 5 behaviors.\n\n\n# Svelte 5 — $derived (concise)\n\nKey Svelte 5 behaviors for `$derived`:\n\n- `$derived` is built-in; do NOT import it.\n- Use `let x = $derived(expr)` for straightforward computed values.\n- Use `$derived.by(() => { ... })` when returning complex objects; store the object before destructuring.\n- `$derived` auto-updates when dependencies change; avoid side effects inside derived functions.\n\nThis document focuses on Svelte 5 semantics; generic examples removed.\n\n# Svelte 5 Each Blocks — notes\n\nConcise Svelte 5 notes for `{#each}` usage:\n\n- Use stable primitive keys in keyed each blocks: `{#each items as item (item.id)}`.\n- Supported iterables: arrays, Maps, Sets, and array-like objects.\n- Use `{:else}` for empty lists.\n\nNo Svelte 5–specific API changes to `{#each}` beyond standard behavior.\n\n\n# Svelte 5 — $effect (summary)\n\nEssential Svelte 5 behaviors and pitfalls for `$effect`:\n\n- Runes are language-level; do NOT import `$effect` or other `$` runes.\n- Enable runes with `<svelte:options runes={true} />`.\n- `$effect` auto-tracks dependencies read synchronously from `$state`, `$derived`, and `$props`.\n- Return a teardown function; teardown runs before re-run and on destroy.\n- Use `$effect.pre` to run before DOM updates (useful for measurement and `tick()` coordination).\n- Use `$effect.root` to create a non-tracked scope that requires manual cleanup.\n- Do not use `$effect` for pure derived state — prefer `$derived`.\n\nEdge cases:\n- Conditional reads are only tracked when executed; avoid relying on implicit tracking of mutated object internals without reassigning the reference.\n\nExamples and generic usage intentionally omitted.\n\n# Svelte 5 — $inspect (summary)\n\nPractical Svelte 5 points for `$inspect`:\n\n- `$inspect` is a dev-only reactive inspection helper — use it for debugging.\n- `$inspect(...).with(fn)` accepts a callback; the callback's first argument indicates call type (`init` | `update`).\n- `$inspect.trace(label?)` enables tracing and must be the first statement in a function body.\n- `$inspect` and `$inspect.trace` are runes — do not import them; enable runes with `<svelte:options runes={true} />`.\n\nThis file focuses on the API surface; verbose test mandates removed.\n\n# Svelte 5 Props Reference\n\n# Svelte 5 props — focused rules\n\nThis file intentionally keeps only Svelte 5–specific prop semantics and patterns.\n\n- Call and destructure `$props()` exactly once. Example:\n\n  ```svelte\n  let { id, name = 'Guest' } = $props();\n  ```\n\n  Reason: repeated calls or multiple scattered destructurings can confuse the compiler and make intent unclear.\n\n- Props are read-only. If you need mutable local state, copy prop values into local state (e.g., a `$state` value) or design the component to accept callbacks for mutations.\n\n  Alternatives:\n  - Use `$bindable()` for writable bindings where appropriate.\n  - Accept an `onChange`/callback prop so the parent maintains authoritative state.\n\n- Provide sensible defaults when destructuring: `let { count = 0 } = $props();`.\n\n- Per-instance IDs: newer Svelte 5 releases may expose `$props.id()` to obtain a stable instance identifier; prefer that for stable identity in tests or lists rather than generating random IDs inside the component.\n\n- Testing note: prefer stable attributes provided by the parent (for example `data-testid`) instead of relying on component-internal generated IDs.\n\n\n# Svelte 5 Snippets — concise\n\nFocus: Svelte 5–specific snippet rules and minimal examples. Keep only net-new behaviors and guidance.\n\n- Snippets are template constructs (not JS functions). Use `{#snippet name(params)}...{/snippet}` and render with `{@render name(args)}`.\n- Do not use `return` or JSX inside snippets — write template markup directly.\n\nExample (minimal):\n```svelte\n<svelte:options runes={true} />\n\n{#snippet title(text)}\n  <span data-testid=\"title\">{text}</span>\n{/snippet}\n\n{#each items as item}\n  <li>{@render title(item)}</li>\n{/each}\n```\n\nProps & children:\n- Implicit children become a `children` snippet; access via `$props()`.\n- Use `{@render children?.()}` or conditional rendering for fallbacks.\n\nTypeScript:\n- Annotate snippet props with interfaces and destructure from `$props()`.\n\nExported snippets:\n- Svelte 5 supports exporting snippet utilities from module scripts (behavior may vary by patch).\n\nFor complex behavior, combine snippets with runes and composable state helpers."
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = 0;\n\n  function increment() {\n    count++;\n  }\n\n  function decrement() {\n    count--;\n  }\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" on:click={decrement}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" on:click={increment}>+</button>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  1\u001b[39m\nReceived:\n\u001b[31m  0\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  -1\u001b[39m\nReceived:\n\u001b[31m  0\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  2\u001b[39m\nReceived:\n\u001b[31m  0\u001b[39m"
        ],
        "temperature": 0
      }
    ]
  },
  {
    "testName": "derived",
    "provider": "LMStudio",
    "modelId": "qwen/qwen3-4b-2507",
    "numSamples": 1,
    "numCorrect": 0,
    "pass1": 0,
    "pass10": 0,
    "context": {
      "used": true,
      "content": "# Svelte 5 Anti-Patterns — focused\n\nKeep only Svelte 5–specific anti-patterns:\n\n- Do NOT import rune identifiers or use external rune libraries — runes are language-level.\n- Avoid mutating props directly; use `$bindable()` or callbacks for writable semantics.\n- Do not use `$effect` to derive state — prefer `$derived` for pure computations.\n- Avoid exporting reassigned `$state` values from `.svelte.js`/`.svelte.ts`; instead expose getters/setters to preserve reactivity.\n- Be cautious with event directive differences from Svelte 4; consult the repo's notes for specific breakages.\n\nRemoved general JS/UX guidance to keep this file tightly scoped.\n- Use modern Svelte 5 APIs instead of legacy APIs (e.g., prefer callback props over `createEventDispatcher`).\n\n\n# Svelte 5 Best Practices — distilled\n\nThis file summarizes only Svelte 5–specific guidance (runes, new reactive primitives, and breaking changes from Svelte 4).\n\nKey points\n\nTesting and debugging\n\nThis document intentionally omits generic Svelte usage to keep focus on net-new Svelte 5 behaviors.\n# Svelte 5 Best Practices — distilled\n\nThis file summarizes only Svelte 5–specific guidance (runes, new reactive primitives, and breaking changes from Svelte 4).\n\nKey points\n- Enable runes per-component: `<svelte:options runes={true} />`.\n- Runes (`$state`, `$derived`, `$effect`, `$inspect`) are language-level — do not import them.\n- Props are read-only: destructure once from `$props()`; use local `$state` copies, `$bindable()`, or callback props for writable behavior.\n- Use `$derived` for pure computed values and `$effect` for side effects (effects can return teardown functions).\n- `$inspect` and `$inspect.trace` are dev-only; `$inspect.trace` must be the first statement in a function body.\n- Be aware of syntactic differences from Svelte 4 (see other repo notes for specifics).\n\nTesting and debugging\n- Add `data-testid` attributes for stable selectors in tests.\n- Use `$effect.root` or explicit cleanup in tests to avoid cross-test leaks.\n\nThis document intentionally omits generic Svelte usage to keep focus on net-new Svelte 5 behaviors.\n\n\n# Svelte 5 — $derived (concise)\n\nKey Svelte 5 behaviors for `$derived`:\n\n- `$derived` is built-in; do NOT import it.\n- Use `let x = $derived(expr)` for straightforward computed values.\n- Use `$derived.by(() => { ... })` when returning complex objects; store the object before destructuring.\n- `$derived` auto-updates when dependencies change; avoid side effects inside derived functions.\n\nThis document focuses on Svelte 5 semantics; generic examples removed.\n\n# Svelte 5 Each Blocks — notes\n\nConcise Svelte 5 notes for `{#each}` usage:\n\n- Use stable primitive keys in keyed each blocks: `{#each items as item (item.id)}`.\n- Supported iterables: arrays, Maps, Sets, and array-like objects.\n- Use `{:else}` for empty lists.\n\nNo Svelte 5–specific API changes to `{#each}` beyond standard behavior.\n\n\n# Svelte 5 — $effect (summary)\n\nEssential Svelte 5 behaviors and pitfalls for `$effect`:\n\n- Runes are language-level; do NOT import `$effect` or other `$` runes.\n- Enable runes with `<svelte:options runes={true} />`.\n- `$effect` auto-tracks dependencies read synchronously from `$state`, `$derived`, and `$props`.\n- Return a teardown function; teardown runs before re-run and on destroy.\n- Use `$effect.pre` to run before DOM updates (useful for measurement and `tick()` coordination).\n- Use `$effect.root` to create a non-tracked scope that requires manual cleanup.\n- Do not use `$effect` for pure derived state — prefer `$derived`.\n\nEdge cases:\n- Conditional reads are only tracked when executed; avoid relying on implicit tracking of mutated object internals without reassigning the reference.\n\nExamples and generic usage intentionally omitted.\n\n# Svelte 5 — $inspect (summary)\n\nPractical Svelte 5 points for `$inspect`:\n\n- `$inspect` is a dev-only reactive inspection helper — use it for debugging.\n- `$inspect(...).with(fn)` accepts a callback; the callback's first argument indicates call type (`init` | `update`).\n- `$inspect.trace(label?)` enables tracing and must be the first statement in a function body.\n- `$inspect` and `$inspect.trace` are runes — do not import them; enable runes with `<svelte:options runes={true} />`.\n\nThis file focuses on the API surface; verbose test mandates removed.\n\n# Svelte 5 Props Reference\n\n# Svelte 5 props — focused rules\n\nThis file intentionally keeps only Svelte 5–specific prop semantics and patterns.\n\n- Call and destructure `$props()` exactly once. Example:\n\n  ```svelte\n  let { id, name = 'Guest' } = $props();\n  ```\n\n  Reason: repeated calls or multiple scattered destructurings can confuse the compiler and make intent unclear.\n\n- Props are read-only. If you need mutable local state, copy prop values into local state (e.g., a `$state` value) or design the component to accept callbacks for mutations.\n\n  Alternatives:\n  - Use `$bindable()` for writable bindings where appropriate.\n  - Accept an `onChange`/callback prop so the parent maintains authoritative state.\n\n- Provide sensible defaults when destructuring: `let { count = 0 } = $props();`.\n\n- Per-instance IDs: newer Svelte 5 releases may expose `$props.id()` to obtain a stable instance identifier; prefer that for stable identity in tests or lists rather than generating random IDs inside the component.\n\n- Testing note: prefer stable attributes provided by the parent (for example `data-testid`) instead of relying on component-internal generated IDs.\n\n\n# Svelte 5 Snippets — concise\n\nFocus: Svelte 5–specific snippet rules and minimal examples. Keep only net-new behaviors and guidance.\n\n- Snippets are template constructs (not JS functions). Use `{#snippet name(params)}...{/snippet}` and render with `{@render name(args)}`.\n- Do not use `return` or JSX inside snippets — write template markup directly.\n\nExample (minimal):\n```svelte\n<svelte:options runes={true} />\n\n{#snippet title(text)}\n  <span data-testid=\"title\">{text}</span>\n{/snippet}\n\n{#each items as item}\n  <li>{@render title(item)}</li>\n{/each}\n```\n\nProps & children:\n- Implicit children become a `children` snippet; access via `$props()`.\n- Use `{@render children?.()}` or conditional rendering for fallbacks.\n\nTypeScript:\n- Annotate snippet props with interfaces and destructure from `$props()`.\n\nExported snippets:\n- Svelte 5 supports exporting snippet utilities from module scripts (behavior may vary by patch).\n\nFor complex behavior, combine snippets with runes and composable state helpers."
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(() => number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" on:click={() => number++}>Increment</button>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Doubled: 10\u001b[39m\nReceived:\n\u001b[31m  Doubled: () => get(number) * 2\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Doubled: 12\u001b[39m\nReceived:\n\u001b[31m  Doubled: () => get(number) * 2\u001b[39m"
        ],
        "temperature": 0
      }
    ]
  },
  {
    "testName": "derived-by",
    "provider": "LMStudio",
    "modelId": "qwen/qwen3-4b-2507",
    "numSamples": 1,
    "numCorrect": 0,
    "pass1": 0,
    "pass10": 0,
    "context": {
      "used": true,
      "content": "# Svelte 5 Anti-Patterns — focused\n\nKeep only Svelte 5–specific anti-patterns:\n\n- Do NOT import rune identifiers or use external rune libraries — runes are language-level.\n- Avoid mutating props directly; use `$bindable()` or callbacks for writable semantics.\n- Do not use `$effect` to derive state — prefer `$derived` for pure computations.\n- Avoid exporting reassigned `$state` values from `.svelte.js`/`.svelte.ts`; instead expose getters/setters to preserve reactivity.\n- Be cautious with event directive differences from Svelte 4; consult the repo's notes for specific breakages.\n\nRemoved general JS/UX guidance to keep this file tightly scoped.\n- Use modern Svelte 5 APIs instead of legacy APIs (e.g., prefer callback props over `createEventDispatcher`).\n\n\n# Svelte 5 Best Practices — distilled\n\nThis file summarizes only Svelte 5–specific guidance (runes, new reactive primitives, and breaking changes from Svelte 4).\n\nKey points\n\nTesting and debugging\n\nThis document intentionally omits generic Svelte usage to keep focus on net-new Svelte 5 behaviors.\n# Svelte 5 Best Practices — distilled\n\nThis file summarizes only Svelte 5–specific guidance (runes, new reactive primitives, and breaking changes from Svelte 4).\n\nKey points\n- Enable runes per-component: `<svelte:options runes={true} />`.\n- Runes (`$state`, `$derived`, `$effect`, `$inspect`) are language-level — do not import them.\n- Props are read-only: destructure once from `$props()`; use local `$state` copies, `$bindable()`, or callback props for writable behavior.\n- Use `$derived` for pure computed values and `$effect` for side effects (effects can return teardown functions).\n- `$inspect` and `$inspect.trace` are dev-only; `$inspect.trace` must be the first statement in a function body.\n- Be aware of syntactic differences from Svelte 4 (see other repo notes for specifics).\n\nTesting and debugging\n- Add `data-testid` attributes for stable selectors in tests.\n- Use `$effect.root` or explicit cleanup in tests to avoid cross-test leaks.\n\nThis document intentionally omits generic Svelte usage to keep focus on net-new Svelte 5 behaviors.\n\n\n# Svelte 5 — $derived (concise)\n\nKey Svelte 5 behaviors for `$derived`:\n\n- `$derived` is built-in; do NOT import it.\n- Use `let x = $derived(expr)` for straightforward computed values.\n- Use `$derived.by(() => { ... })` when returning complex objects; store the object before destructuring.\n- `$derived` auto-updates when dependencies change; avoid side effects inside derived functions.\n\nThis document focuses on Svelte 5 semantics; generic examples removed.\n\n# Svelte 5 Each Blocks — notes\n\nConcise Svelte 5 notes for `{#each}` usage:\n\n- Use stable primitive keys in keyed each blocks: `{#each items as item (item.id)}`.\n- Supported iterables: arrays, Maps, Sets, and array-like objects.\n- Use `{:else}` for empty lists.\n\nNo Svelte 5–specific API changes to `{#each}` beyond standard behavior.\n\n\n# Svelte 5 — $effect (summary)\n\nEssential Svelte 5 behaviors and pitfalls for `$effect`:\n\n- Runes are language-level; do NOT import `$effect` or other `$` runes.\n- Enable runes with `<svelte:options runes={true} />`.\n- `$effect` auto-tracks dependencies read synchronously from `$state`, `$derived`, and `$props`.\n- Return a teardown function; teardown runs before re-run and on destroy.\n- Use `$effect.pre` to run before DOM updates (useful for measurement and `tick()` coordination).\n- Use `$effect.root` to create a non-tracked scope that requires manual cleanup.\n- Do not use `$effect` for pure derived state — prefer `$derived`.\n\nEdge cases:\n- Conditional reads are only tracked when executed; avoid relying on implicit tracking of mutated object internals without reassigning the reference.\n\nExamples and generic usage intentionally omitted.\n\n# Svelte 5 — $inspect (summary)\n\nPractical Svelte 5 points for `$inspect`:\n\n- `$inspect` is a dev-only reactive inspection helper — use it for debugging.\n- `$inspect(...).with(fn)` accepts a callback; the callback's first argument indicates call type (`init` | `update`).\n- `$inspect.trace(label?)` enables tracing and must be the first statement in a function body.\n- `$inspect` and `$inspect.trace` are runes — do not import them; enable runes with `<svelte:options runes={true} />`.\n\nThis file focuses on the API surface; verbose test mandates removed.\n\n# Svelte 5 Props Reference\n\n# Svelte 5 props — focused rules\n\nThis file intentionally keeps only Svelte 5–specific prop semantics and patterns.\n\n- Call and destructure `$props()` exactly once. Example:\n\n  ```svelte\n  let { id, name = 'Guest' } = $props();\n  ```\n\n  Reason: repeated calls or multiple scattered destructurings can confuse the compiler and make intent unclear.\n\n- Props are read-only. If you need mutable local state, copy prop values into local state (e.g., a `$state` value) or design the component to accept callbacks for mutations.\n\n  Alternatives:\n  - Use `$bindable()` for writable bindings where appropriate.\n  - Accept an `onChange`/callback prop so the parent maintains authoritative state.\n\n- Provide sensible defaults when destructuring: `let { count = 0 } = $props();`.\n\n- Per-instance IDs: newer Svelte 5 releases may expose `$props.id()` to obtain a stable instance identifier; prefer that for stable identity in tests or lists rather than generating random IDs inside the component.\n\n- Testing note: prefer stable attributes provided by the parent (for example `data-testid`) instead of relying on component-internal generated IDs.\n\n\n# Svelte 5 Snippets — concise\n\nFocus: Svelte 5–specific snippet rules and minimal examples. Keep only net-new behaviors and guidance.\n\n- Snippets are template constructs (not JS functions). Use `{#snippet name(params)}...{/snippet}` and render with `{@render name(args)}`.\n- Do not use `return` or JSX inside snippets — write template markup directly.\n\nExample (minimal):\n```svelte\n<svelte:options runes={true} />\n\n{#snippet title(text)}\n  <span data-testid=\"title\">{text}</span>\n{/snippet}\n\n{#each items as item}\n  <li>{@render title(item)}</li>\n{/each}\n```\n\nProps & children:\n- Implicit children become a `children` snippet; access via `$props()`.\n- Use `{@render children?.()}` or conditional rendering for fallbacks.\n\nTypeScript:\n- Annotate snippet props with interfaces and destructure from `$props()`.\n\nExported snippets:\n- Svelte 5 supports exporting snippet utilities from module scripts (behavior may vary by patch).\n\nFor complex behavior, combine snippets with runes and composable state helpers."
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  import { $state, $derived } from 'svelte';\n\n  let text = $state('');\n\n  const wordCount = $derived.by(() => {\n    const words = text.trim().split(/\\s+/).filter(w => w.length > 0);\n    return words.length;\n  });\n\n  const charCount = $derived.by(() => {\n    return text.length;\n  });\n\n  const isLong = $derived.by(() => {\n    return wordCount > 15;\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" on:click={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": false,
        "errors": [
          "/Users/Abhijeet.Karpe/apps/svelte-bench/tmp/samples/lmstudio/Component.svelte:4:11 The $ prefix is reserved, and cannot be used for variables and imports\nhttps://svelte.dev/e/dollar_prefix_invalid"
        ],
        "temperature": 0
      }
    ]
  },
  {
    "testName": "each",
    "provider": "LMStudio",
    "modelId": "qwen/qwen3-4b-2507",
    "numSamples": 1,
    "numCorrect": 0,
    "pass1": 0,
    "pass10": 0,
    "context": {
      "used": true,
      "content": "# Svelte 5 Anti-Patterns — focused\n\nKeep only Svelte 5–specific anti-patterns:\n\n- Do NOT import rune identifiers or use external rune libraries — runes are language-level.\n- Avoid mutating props directly; use `$bindable()` or callbacks for writable semantics.\n- Do not use `$effect` to derive state — prefer `$derived` for pure computations.\n- Avoid exporting reassigned `$state` values from `.svelte.js`/`.svelte.ts`; instead expose getters/setters to preserve reactivity.\n- Be cautious with event directive differences from Svelte 4; consult the repo's notes for specific breakages.\n\nRemoved general JS/UX guidance to keep this file tightly scoped.\n- Use modern Svelte 5 APIs instead of legacy APIs (e.g., prefer callback props over `createEventDispatcher`).\n\n\n# Svelte 5 Best Practices — distilled\n\nThis file summarizes only Svelte 5–specific guidance (runes, new reactive primitives, and breaking changes from Svelte 4).\n\nKey points\n\nTesting and debugging\n\nThis document intentionally omits generic Svelte usage to keep focus on net-new Svelte 5 behaviors.\n# Svelte 5 Best Practices — distilled\n\nThis file summarizes only Svelte 5–specific guidance (runes, new reactive primitives, and breaking changes from Svelte 4).\n\nKey points\n- Enable runes per-component: `<svelte:options runes={true} />`.\n- Runes (`$state`, `$derived`, `$effect`, `$inspect`) are language-level — do not import them.\n- Props are read-only: destructure once from `$props()`; use local `$state` copies, `$bindable()`, or callback props for writable behavior.\n- Use `$derived` for pure computed values and `$effect` for side effects (effects can return teardown functions).\n- `$inspect` and `$inspect.trace` are dev-only; `$inspect.trace` must be the first statement in a function body.\n- Be aware of syntactic differences from Svelte 4 (see other repo notes for specifics).\n\nTesting and debugging\n- Add `data-testid` attributes for stable selectors in tests.\n- Use `$effect.root` or explicit cleanup in tests to avoid cross-test leaks.\n\nThis document intentionally omits generic Svelte usage to keep focus on net-new Svelte 5 behaviors.\n\n\n# Svelte 5 — $derived (concise)\n\nKey Svelte 5 behaviors for `$derived`:\n\n- `$derived` is built-in; do NOT import it.\n- Use `let x = $derived(expr)` for straightforward computed values.\n- Use `$derived.by(() => { ... })` when returning complex objects; store the object before destructuring.\n- `$derived` auto-updates when dependencies change; avoid side effects inside derived functions.\n\nThis document focuses on Svelte 5 semantics; generic examples removed.\n\n# Svelte 5 Each Blocks — notes\n\nConcise Svelte 5 notes for `{#each}` usage:\n\n- Use stable primitive keys in keyed each blocks: `{#each items as item (item.id)}`.\n- Supported iterables: arrays, Maps, Sets, and array-like objects.\n- Use `{:else}` for empty lists.\n\nNo Svelte 5–specific API changes to `{#each}` beyond standard behavior.\n\n\n# Svelte 5 — $effect (summary)\n\nEssential Svelte 5 behaviors and pitfalls for `$effect`:\n\n- Runes are language-level; do NOT import `$effect` or other `$` runes.\n- Enable runes with `<svelte:options runes={true} />`.\n- `$effect` auto-tracks dependencies read synchronously from `$state`, `$derived`, and `$props`.\n- Return a teardown function; teardown runs before re-run and on destroy.\n- Use `$effect.pre` to run before DOM updates (useful for measurement and `tick()` coordination).\n- Use `$effect.root` to create a non-tracked scope that requires manual cleanup.\n- Do not use `$effect` for pure derived state — prefer `$derived`.\n\nEdge cases:\n- Conditional reads are only tracked when executed; avoid relying on implicit tracking of mutated object internals without reassigning the reference.\n\nExamples and generic usage intentionally omitted.\n\n# Svelte 5 — $inspect (summary)\n\nPractical Svelte 5 points for `$inspect`:\n\n- `$inspect` is a dev-only reactive inspection helper — use it for debugging.\n- `$inspect(...).with(fn)` accepts a callback; the callback's first argument indicates call type (`init` | `update`).\n- `$inspect.trace(label?)` enables tracing and must be the first statement in a function body.\n- `$inspect` and `$inspect.trace` are runes — do not import them; enable runes with `<svelte:options runes={true} />`.\n\nThis file focuses on the API surface; verbose test mandates removed.\n\n# Svelte 5 Props Reference\n\n# Svelte 5 props — focused rules\n\nThis file intentionally keeps only Svelte 5–specific prop semantics and patterns.\n\n- Call and destructure `$props()` exactly once. Example:\n\n  ```svelte\n  let { id, name = 'Guest' } = $props();\n  ```\n\n  Reason: repeated calls or multiple scattered destructurings can confuse the compiler and make intent unclear.\n\n- Props are read-only. If you need mutable local state, copy prop values into local state (e.g., a `$state` value) or design the component to accept callbacks for mutations.\n\n  Alternatives:\n  - Use `$bindable()` for writable bindings where appropriate.\n  - Accept an `onChange`/callback prop so the parent maintains authoritative state.\n\n- Provide sensible defaults when destructuring: `let { count = 0 } = $props();`.\n\n- Per-instance IDs: newer Svelte 5 releases may expose `$props.id()` to obtain a stable instance identifier; prefer that for stable identity in tests or lists rather than generating random IDs inside the component.\n\n- Testing note: prefer stable attributes provided by the parent (for example `data-testid`) instead of relying on component-internal generated IDs.\n\n\n# Svelte 5 Snippets — concise\n\nFocus: Svelte 5–specific snippet rules and minimal examples. Keep only net-new behaviors and guidance.\n\n- Snippets are template constructs (not JS functions). Use `{#snippet name(params)}...{/snippet}` and render with `{@render name(args)}`.\n- Do not use `return` or JSX inside snippets — write template markup directly.\n\nExample (minimal):\n```svelte\n<svelte:options runes={true} />\n\n{#snippet title(text)}\n  <span data-testid=\"title\">{text}</span>\n{/snippet}\n\n{#each items as item}\n  <li>{@render title(item)}</li>\n{/each}\n```\n\nProps & children:\n- Implicit children become a `children` snippet; access via `$props()`.\n- Use `{@render children?.()}` or conditional rendering for fallbacks.\n\nTypeScript:\n- Annotate snippet props with interfaces and destructure from `$props()`.\n\nExported snippets:\n- Svelte 5 supports exporting snippet utilities from module scripts (behavior may vary by patch).\n\nFor complex behavior, combine snippets with runes and composable state helpers."
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  import { $state, $derived } from 'svelte';\n\n  let characters = $state(['Jerry', 'Elaine', 'Kramer']);\n\n  function addGeorge() {\n    characters.push('George');\n  }\n\n  let { characters: $derivedChars } = $derived(() => characters);\n</script>\n\n<ul data-testid=\"characters-list\">\n  {#each $derivedChars as character}\n    <li data-testid=\"character\">{character}</li>\n  {/each}\n</ul>\n<button data-testid=\"add-george-button\" on:click={addGeorge}>Add George</button>",
        "success": false,
        "errors": [
          "/Users/Abhijeet.Karpe/apps/svelte-bench/tmp/samples/lmstudio/Component.svelte:4:11 The $ prefix is reserved, and cannot be used for variables and imports\nhttps://svelte.dev/e/dollar_prefix_invalid"
        ],
        "temperature": 0
      }
    ]
  },
  {
    "testName": "effect",
    "provider": "LMStudio",
    "modelId": "qwen/qwen3-4b-2507",
    "numSamples": 1,
    "numCorrect": 0,
    "pass1": 0,
    "pass10": 0,
    "context": {
      "used": true,
      "content": "# Svelte 5 Anti-Patterns — focused\n\nKeep only Svelte 5–specific anti-patterns:\n\n- Do NOT import rune identifiers or use external rune libraries — runes are language-level.\n- Avoid mutating props directly; use `$bindable()` or callbacks for writable semantics.\n- Do not use `$effect` to derive state — prefer `$derived` for pure computations.\n- Avoid exporting reassigned `$state` values from `.svelte.js`/`.svelte.ts`; instead expose getters/setters to preserve reactivity.\n- Be cautious with event directive differences from Svelte 4; consult the repo's notes for specific breakages.\n\nRemoved general JS/UX guidance to keep this file tightly scoped.\n- Use modern Svelte 5 APIs instead of legacy APIs (e.g., prefer callback props over `createEventDispatcher`).\n\n\n# Svelte 5 Best Practices — distilled\n\nThis file summarizes only Svelte 5–specific guidance (runes, new reactive primitives, and breaking changes from Svelte 4).\n\nKey points\n\nTesting and debugging\n\nThis document intentionally omits generic Svelte usage to keep focus on net-new Svelte 5 behaviors.\n# Svelte 5 Best Practices — distilled\n\nThis file summarizes only Svelte 5–specific guidance (runes, new reactive primitives, and breaking changes from Svelte 4).\n\nKey points\n- Enable runes per-component: `<svelte:options runes={true} />`.\n- Runes (`$state`, `$derived`, `$effect`, `$inspect`) are language-level — do not import them.\n- Props are read-only: destructure once from `$props()`; use local `$state` copies, `$bindable()`, or callback props for writable behavior.\n- Use `$derived` for pure computed values and `$effect` for side effects (effects can return teardown functions).\n- `$inspect` and `$inspect.trace` are dev-only; `$inspect.trace` must be the first statement in a function body.\n- Be aware of syntactic differences from Svelte 4 (see other repo notes for specifics).\n\nTesting and debugging\n- Add `data-testid` attributes for stable selectors in tests.\n- Use `$effect.root` or explicit cleanup in tests to avoid cross-test leaks.\n\nThis document intentionally omits generic Svelte usage to keep focus on net-new Svelte 5 behaviors.\n\n\n# Svelte 5 — $derived (concise)\n\nKey Svelte 5 behaviors for `$derived`:\n\n- `$derived` is built-in; do NOT import it.\n- Use `let x = $derived(expr)` for straightforward computed values.\n- Use `$derived.by(() => { ... })` when returning complex objects; store the object before destructuring.\n- `$derived` auto-updates when dependencies change; avoid side effects inside derived functions.\n\nThis document focuses on Svelte 5 semantics; generic examples removed.\n\n# Svelte 5 Each Blocks — notes\n\nConcise Svelte 5 notes for `{#each}` usage:\n\n- Use stable primitive keys in keyed each blocks: `{#each items as item (item.id)}`.\n- Supported iterables: arrays, Maps, Sets, and array-like objects.\n- Use `{:else}` for empty lists.\n\nNo Svelte 5–specific API changes to `{#each}` beyond standard behavior.\n\n\n# Svelte 5 — $effect (summary)\n\nEssential Svelte 5 behaviors and pitfalls for `$effect`:\n\n- Runes are language-level; do NOT import `$effect` or other `$` runes.\n- Enable runes with `<svelte:options runes={true} />`.\n- `$effect` auto-tracks dependencies read synchronously from `$state`, `$derived`, and `$props`.\n- Return a teardown function; teardown runs before re-run and on destroy.\n- Use `$effect.pre` to run before DOM updates (useful for measurement and `tick()` coordination).\n- Use `$effect.root` to create a non-tracked scope that requires manual cleanup.\n- Do not use `$effect` for pure derived state — prefer `$derived`.\n\nEdge cases:\n- Conditional reads are only tracked when executed; avoid relying on implicit tracking of mutated object internals without reassigning the reference.\n\nExamples and generic usage intentionally omitted.\n\n# Svelte 5 — $inspect (summary)\n\nPractical Svelte 5 points for `$inspect`:\n\n- `$inspect` is a dev-only reactive inspection helper — use it for debugging.\n- `$inspect(...).with(fn)` accepts a callback; the callback's first argument indicates call type (`init` | `update`).\n- `$inspect.trace(label?)` enables tracing and must be the first statement in a function body.\n- `$inspect` and `$inspect.trace` are runes — do not import them; enable runes with `<svelte:options runes={true} />`.\n\nThis file focuses on the API surface; verbose test mandates removed.\n\n# Svelte 5 Props Reference\n\n# Svelte 5 props — focused rules\n\nThis file intentionally keeps only Svelte 5–specific prop semantics and patterns.\n\n- Call and destructure `$props()` exactly once. Example:\n\n  ```svelte\n  let { id, name = 'Guest' } = $props();\n  ```\n\n  Reason: repeated calls or multiple scattered destructurings can confuse the compiler and make intent unclear.\n\n- Props are read-only. If you need mutable local state, copy prop values into local state (e.g., a `$state` value) or design the component to accept callbacks for mutations.\n\n  Alternatives:\n  - Use `$bindable()` for writable bindings where appropriate.\n  - Accept an `onChange`/callback prop so the parent maintains authoritative state.\n\n- Provide sensible defaults when destructuring: `let { count = 0 } = $props();`.\n\n- Per-instance IDs: newer Svelte 5 releases may expose `$props.id()` to obtain a stable instance identifier; prefer that for stable identity in tests or lists rather than generating random IDs inside the component.\n\n- Testing note: prefer stable attributes provided by the parent (for example `data-testid`) instead of relying on component-internal generated IDs.\n\n\n# Svelte 5 Snippets — concise\n\nFocus: Svelte 5–specific snippet rules and minimal examples. Keep only net-new behaviors and guidance.\n\n- Snippets are template constructs (not JS functions). Use `{#snippet name(params)}...{/snippet}` and render with `{@render name(args)}`.\n- Do not use `return` or JSX inside snippets — write template markup directly.\n\nExample (minimal):\n```svelte\n<svelte:options runes={true} />\n\n{#snippet title(text)}\n  <span data-testid=\"title\">{text}</span>\n{/snippet}\n\n{#each items as item}\n  <li>{@render title(item)}</li>\n{/each}\n```\n\nProps & children:\n- Implicit children become a `children` snippet; access via `$props()`.\n- Use `{@render children?.()}` or conditional rendering for fallbacks.\n\nTypeScript:\n- Annotate snippet props with interfaces and destructure from `$props()`.\n\nExported snippets:\n- Svelte 5 supports exporting snippet utilities from module scripts (behavior may vary by patch).\n\nFor complex behavior, combine snippets with runes and composable state helpers."
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = 5;\n  let doubled = $derived(() => number * 2);\n\n  $effect(() => {\n    // This effect runs whenever number changes\n    // No side effects inside derived functions\n  });\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" on:click={() => number++}>Increment</button>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Doubled: 10\u001b[39m\nReceived:\n\u001b[31m  Doubled: () => number * 2\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Number: 6\u001b[39m\nReceived:\n\u001b[31m  Number: 5\u001b[39m"
        ],
        "temperature": 0
      }
    ]
  },
  {
    "testName": "hello-world",
    "provider": "LMStudio",
    "modelId": "qwen/qwen3-4b-2507",
    "numSamples": 1,
    "numCorrect": 1,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "# Svelte 5 Anti-Patterns — focused\n\nKeep only Svelte 5–specific anti-patterns:\n\n- Do NOT import rune identifiers or use external rune libraries — runes are language-level.\n- Avoid mutating props directly; use `$bindable()` or callbacks for writable semantics.\n- Do not use `$effect` to derive state — prefer `$derived` for pure computations.\n- Avoid exporting reassigned `$state` values from `.svelte.js`/`.svelte.ts`; instead expose getters/setters to preserve reactivity.\n- Be cautious with event directive differences from Svelte 4; consult the repo's notes for specific breakages.\n\nRemoved general JS/UX guidance to keep this file tightly scoped.\n- Use modern Svelte 5 APIs instead of legacy APIs (e.g., prefer callback props over `createEventDispatcher`).\n\n\n# Svelte 5 Best Practices — distilled\n\nThis file summarizes only Svelte 5–specific guidance (runes, new reactive primitives, and breaking changes from Svelte 4).\n\nKey points\n\nTesting and debugging\n\nThis document intentionally omits generic Svelte usage to keep focus on net-new Svelte 5 behaviors.\n# Svelte 5 Best Practices — distilled\n\nThis file summarizes only Svelte 5–specific guidance (runes, new reactive primitives, and breaking changes from Svelte 4).\n\nKey points\n- Enable runes per-component: `<svelte:options runes={true} />`.\n- Runes (`$state`, `$derived`, `$effect`, `$inspect`) are language-level — do not import them.\n- Props are read-only: destructure once from `$props()`; use local `$state` copies, `$bindable()`, or callback props for writable behavior.\n- Use `$derived` for pure computed values and `$effect` for side effects (effects can return teardown functions).\n- `$inspect` and `$inspect.trace` are dev-only; `$inspect.trace` must be the first statement in a function body.\n- Be aware of syntactic differences from Svelte 4 (see other repo notes for specifics).\n\nTesting and debugging\n- Add `data-testid` attributes for stable selectors in tests.\n- Use `$effect.root` or explicit cleanup in tests to avoid cross-test leaks.\n\nThis document intentionally omits generic Svelte usage to keep focus on net-new Svelte 5 behaviors.\n\n\n# Svelte 5 — $derived (concise)\n\nKey Svelte 5 behaviors for `$derived`:\n\n- `$derived` is built-in; do NOT import it.\n- Use `let x = $derived(expr)` for straightforward computed values.\n- Use `$derived.by(() => { ... })` when returning complex objects; store the object before destructuring.\n- `$derived` auto-updates when dependencies change; avoid side effects inside derived functions.\n\nThis document focuses on Svelte 5 semantics; generic examples removed.\n\n# Svelte 5 Each Blocks — notes\n\nConcise Svelte 5 notes for `{#each}` usage:\n\n- Use stable primitive keys in keyed each blocks: `{#each items as item (item.id)}`.\n- Supported iterables: arrays, Maps, Sets, and array-like objects.\n- Use `{:else}` for empty lists.\n\nNo Svelte 5–specific API changes to `{#each}` beyond standard behavior.\n\n\n# Svelte 5 — $effect (summary)\n\nEssential Svelte 5 behaviors and pitfalls for `$effect`:\n\n- Runes are language-level; do NOT import `$effect` or other `$` runes.\n- Enable runes with `<svelte:options runes={true} />`.\n- `$effect` auto-tracks dependencies read synchronously from `$state`, `$derived`, and `$props`.\n- Return a teardown function; teardown runs before re-run and on destroy.\n- Use `$effect.pre` to run before DOM updates (useful for measurement and `tick()` coordination).\n- Use `$effect.root` to create a non-tracked scope that requires manual cleanup.\n- Do not use `$effect` for pure derived state — prefer `$derived`.\n\nEdge cases:\n- Conditional reads are only tracked when executed; avoid relying on implicit tracking of mutated object internals without reassigning the reference.\n\nExamples and generic usage intentionally omitted.\n\n# Svelte 5 — $inspect (summary)\n\nPractical Svelte 5 points for `$inspect`:\n\n- `$inspect` is a dev-only reactive inspection helper — use it for debugging.\n- `$inspect(...).with(fn)` accepts a callback; the callback's first argument indicates call type (`init` | `update`).\n- `$inspect.trace(label?)` enables tracing and must be the first statement in a function body.\n- `$inspect` and `$inspect.trace` are runes — do not import them; enable runes with `<svelte:options runes={true} />`.\n\nThis file focuses on the API surface; verbose test mandates removed.\n\n# Svelte 5 Props Reference\n\n# Svelte 5 props — focused rules\n\nThis file intentionally keeps only Svelte 5–specific prop semantics and patterns.\n\n- Call and destructure `$props()` exactly once. Example:\n\n  ```svelte\n  let { id, name = 'Guest' } = $props();\n  ```\n\n  Reason: repeated calls or multiple scattered destructurings can confuse the compiler and make intent unclear.\n\n- Props are read-only. If you need mutable local state, copy prop values into local state (e.g., a `$state` value) or design the component to accept callbacks for mutations.\n\n  Alternatives:\n  - Use `$bindable()` for writable bindings where appropriate.\n  - Accept an `onChange`/callback prop so the parent maintains authoritative state.\n\n- Provide sensible defaults when destructuring: `let { count = 0 } = $props();`.\n\n- Per-instance IDs: newer Svelte 5 releases may expose `$props.id()` to obtain a stable instance identifier; prefer that for stable identity in tests or lists rather than generating random IDs inside the component.\n\n- Testing note: prefer stable attributes provided by the parent (for example `data-testid`) instead of relying on component-internal generated IDs.\n\n\n# Svelte 5 Snippets — concise\n\nFocus: Svelte 5–specific snippet rules and minimal examples. Keep only net-new behaviors and guidance.\n\n- Snippets are template constructs (not JS functions). Use `{#snippet name(params)}...{/snippet}` and render with `{@render name(args)}`.\n- Do not use `return` or JSX inside snippets — write template markup directly.\n\nExample (minimal):\n```svelte\n<svelte:options runes={true} />\n\n{#snippet title(text)}\n  <span data-testid=\"title\">{text}</span>\n{/snippet}\n\n{#each items as item}\n  <li>{@render title(item)}</li>\n{/each}\n```\n\nProps & children:\n- Implicit children become a `children` snippet; access via `$props()`.\n- Use `{@render children?.()}` or conditional rendering for fallbacks.\n\nTypeScript:\n- Annotate snippet props with interfaces and destructure from `$props()`.\n\nExported snippets:\n- Svelte 5 supports exporting snippet utilities from module scripts (behavior may vary by patch).\n\nFor complex behavior, combine snippets with runes and composable state helpers."
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>",
        "success": true,
        "errors": [],
        "temperature": 0
      }
    ]
  },
  {
    "testName": "inspect",
    "provider": "LMStudio",
    "modelId": "qwen/qwen3-4b-2507",
    "numSamples": 1,
    "numCorrect": 0,
    "pass1": 0,
    "pass10": 0,
    "context": {
      "used": true,
      "content": "# Svelte 5 Anti-Patterns — focused\n\nKeep only Svelte 5–specific anti-patterns:\n\n- Do NOT import rune identifiers or use external rune libraries — runes are language-level.\n- Avoid mutating props directly; use `$bindable()` or callbacks for writable semantics.\n- Do not use `$effect` to derive state — prefer `$derived` for pure computations.\n- Avoid exporting reassigned `$state` values from `.svelte.js`/`.svelte.ts`; instead expose getters/setters to preserve reactivity.\n- Be cautious with event directive differences from Svelte 4; consult the repo's notes for specific breakages.\n\nRemoved general JS/UX guidance to keep this file tightly scoped.\n- Use modern Svelte 5 APIs instead of legacy APIs (e.g., prefer callback props over `createEventDispatcher`).\n\n\n# Svelte 5 Best Practices — distilled\n\nThis file summarizes only Svelte 5–specific guidance (runes, new reactive primitives, and breaking changes from Svelte 4).\n\nKey points\n\nTesting and debugging\n\nThis document intentionally omits generic Svelte usage to keep focus on net-new Svelte 5 behaviors.\n# Svelte 5 Best Practices — distilled\n\nThis file summarizes only Svelte 5–specific guidance (runes, new reactive primitives, and breaking changes from Svelte 4).\n\nKey points\n- Enable runes per-component: `<svelte:options runes={true} />`.\n- Runes (`$state`, `$derived`, `$effect`, `$inspect`) are language-level — do not import them.\n- Props are read-only: destructure once from `$props()`; use local `$state` copies, `$bindable()`, or callback props for writable behavior.\n- Use `$derived` for pure computed values and `$effect` for side effects (effects can return teardown functions).\n- `$inspect` and `$inspect.trace` are dev-only; `$inspect.trace` must be the first statement in a function body.\n- Be aware of syntactic differences from Svelte 4 (see other repo notes for specifics).\n\nTesting and debugging\n- Add `data-testid` attributes for stable selectors in tests.\n- Use `$effect.root` or explicit cleanup in tests to avoid cross-test leaks.\n\nThis document intentionally omits generic Svelte usage to keep focus on net-new Svelte 5 behaviors.\n\n\n# Svelte 5 — $derived (concise)\n\nKey Svelte 5 behaviors for `$derived`:\n\n- `$derived` is built-in; do NOT import it.\n- Use `let x = $derived(expr)` for straightforward computed values.\n- Use `$derived.by(() => { ... })` when returning complex objects; store the object before destructuring.\n- `$derived` auto-updates when dependencies change; avoid side effects inside derived functions.\n\nThis document focuses on Svelte 5 semantics; generic examples removed.\n\n# Svelte 5 Each Blocks — notes\n\nConcise Svelte 5 notes for `{#each}` usage:\n\n- Use stable primitive keys in keyed each blocks: `{#each items as item (item.id)}`.\n- Supported iterables: arrays, Maps, Sets, and array-like objects.\n- Use `{:else}` for empty lists.\n\nNo Svelte 5–specific API changes to `{#each}` beyond standard behavior.\n\n\n# Svelte 5 — $effect (summary)\n\nEssential Svelte 5 behaviors and pitfalls for `$effect`:\n\n- Runes are language-level; do NOT import `$effect` or other `$` runes.\n- Enable runes with `<svelte:options runes={true} />`.\n- `$effect` auto-tracks dependencies read synchronously from `$state`, `$derived`, and `$props`.\n- Return a teardown function; teardown runs before re-run and on destroy.\n- Use `$effect.pre` to run before DOM updates (useful for measurement and `tick()` coordination).\n- Use `$effect.root` to create a non-tracked scope that requires manual cleanup.\n- Do not use `$effect` for pure derived state — prefer `$derived`.\n\nEdge cases:\n- Conditional reads are only tracked when executed; avoid relying on implicit tracking of mutated object internals without reassigning the reference.\n\nExamples and generic usage intentionally omitted.\n\n# Svelte 5 — $inspect (summary)\n\nPractical Svelte 5 points for `$inspect`:\n\n- `$inspect` is a dev-only reactive inspection helper — use it for debugging.\n- `$inspect(...).with(fn)` accepts a callback; the callback's first argument indicates call type (`init` | `update`).\n- `$inspect.trace(label?)` enables tracing and must be the first statement in a function body.\n- `$inspect` and `$inspect.trace` are runes — do not import them; enable runes with `<svelte:options runes={true} />`.\n\nThis file focuses on the API surface; verbose test mandates removed.\n\n# Svelte 5 Props Reference\n\n# Svelte 5 props — focused rules\n\nThis file intentionally keeps only Svelte 5–specific prop semantics and patterns.\n\n- Call and destructure `$props()` exactly once. Example:\n\n  ```svelte\n  let { id, name = 'Guest' } = $props();\n  ```\n\n  Reason: repeated calls or multiple scattered destructurings can confuse the compiler and make intent unclear.\n\n- Props are read-only. If you need mutable local state, copy prop values into local state (e.g., a `$state` value) or design the component to accept callbacks for mutations.\n\n  Alternatives:\n  - Use `$bindable()` for writable bindings where appropriate.\n  - Accept an `onChange`/callback prop so the parent maintains authoritative state.\n\n- Provide sensible defaults when destructuring: `let { count = 0 } = $props();`.\n\n- Per-instance IDs: newer Svelte 5 releases may expose `$props.id()` to obtain a stable instance identifier; prefer that for stable identity in tests or lists rather than generating random IDs inside the component.\n\n- Testing note: prefer stable attributes provided by the parent (for example `data-testid`) instead of relying on component-internal generated IDs.\n\n\n# Svelte 5 Snippets — concise\n\nFocus: Svelte 5–specific snippet rules and minimal examples. Keep only net-new behaviors and guidance.\n\n- Snippets are template constructs (not JS functions). Use `{#snippet name(params)}...{/snippet}` and render with `{@render name(args)}`.\n- Do not use `return` or JSX inside snippets — write template markup directly.\n\nExample (minimal):\n```svelte\n<svelte:options runes={true} />\n\n{#snippet title(text)}\n  <span data-testid=\"title\">{text}</span>\n{/snippet}\n\n{#each items as item}\n  <li>{@render title(item)}</li>\n{/each}\n```\n\nProps & children:\n- Implicit children become a `children` snippet; access via `$props()`.\n- Use `{@render children?.()}` or conditional rendering for fallbacks.\n\nTypeScript:\n- Annotate snippet props with interfaces and destructure from `$props()`.\n\nExported snippets:\n- Svelte 5 supports exporting snippet utilities from module scripts (behavior may vary by patch).\n\nFor complex behavior, combine snippets with runes and composable state helpers."
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  import { $state, $derived, $effect, $inspect } from 'svelte';\n\n  let text = $state('Hello world');\n\n  const inputUpdates = $inspect(text).with((type, value) => {\n    console.log(`[update] ${type}:, value`);\n  });\n\n  const charCount = $derived(() => text.length);\n\n  $effect(() => {\n    $inspect.trace('input-change');\n  });\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "/Users/Abhijeet.Karpe/apps/svelte-bench/tmp/samples/lmstudio/Component.svelte:4:11 The $ prefix is reserved, and cannot be used for variables and imports\nhttps://svelte.dev/e/dollar_prefix_invalid"
        ],
        "temperature": 0
      }
    ]
  },
  {
    "testName": "props",
    "provider": "LMStudio",
    "modelId": "qwen/qwen3-4b-2507",
    "numSamples": 1,
    "numCorrect": 0,
    "pass1": 0,
    "pass10": 0,
    "context": {
      "used": true,
      "content": "# Svelte 5 Anti-Patterns — focused\n\nKeep only Svelte 5–specific anti-patterns:\n\n- Do NOT import rune identifiers or use external rune libraries — runes are language-level.\n- Avoid mutating props directly; use `$bindable()` or callbacks for writable semantics.\n- Do not use `$effect` to derive state — prefer `$derived` for pure computations.\n- Avoid exporting reassigned `$state` values from `.svelte.js`/`.svelte.ts`; instead expose getters/setters to preserve reactivity.\n- Be cautious with event directive differences from Svelte 4; consult the repo's notes for specific breakages.\n\nRemoved general JS/UX guidance to keep this file tightly scoped.\n- Use modern Svelte 5 APIs instead of legacy APIs (e.g., prefer callback props over `createEventDispatcher`).\n\n\n# Svelte 5 Best Practices — distilled\n\nThis file summarizes only Svelte 5–specific guidance (runes, new reactive primitives, and breaking changes from Svelte 4).\n\nKey points\n\nTesting and debugging\n\nThis document intentionally omits generic Svelte usage to keep focus on net-new Svelte 5 behaviors.\n# Svelte 5 Best Practices — distilled\n\nThis file summarizes only Svelte 5–specific guidance (runes, new reactive primitives, and breaking changes from Svelte 4).\n\nKey points\n- Enable runes per-component: `<svelte:options runes={true} />`.\n- Runes (`$state`, `$derived`, `$effect`, `$inspect`) are language-level — do not import them.\n- Props are read-only: destructure once from `$props()`; use local `$state` copies, `$bindable()`, or callback props for writable behavior.\n- Use `$derived` for pure computed values and `$effect` for side effects (effects can return teardown functions).\n- `$inspect` and `$inspect.trace` are dev-only; `$inspect.trace` must be the first statement in a function body.\n- Be aware of syntactic differences from Svelte 4 (see other repo notes for specifics).\n\nTesting and debugging\n- Add `data-testid` attributes for stable selectors in tests.\n- Use `$effect.root` or explicit cleanup in tests to avoid cross-test leaks.\n\nThis document intentionally omits generic Svelte usage to keep focus on net-new Svelte 5 behaviors.\n\n\n# Svelte 5 — $derived (concise)\n\nKey Svelte 5 behaviors for `$derived`:\n\n- `$derived` is built-in; do NOT import it.\n- Use `let x = $derived(expr)` for straightforward computed values.\n- Use `$derived.by(() => { ... })` when returning complex objects; store the object before destructuring.\n- `$derived` auto-updates when dependencies change; avoid side effects inside derived functions.\n\nThis document focuses on Svelte 5 semantics; generic examples removed.\n\n# Svelte 5 Each Blocks — notes\n\nConcise Svelte 5 notes for `{#each}` usage:\n\n- Use stable primitive keys in keyed each blocks: `{#each items as item (item.id)}`.\n- Supported iterables: arrays, Maps, Sets, and array-like objects.\n- Use `{:else}` for empty lists.\n\nNo Svelte 5–specific API changes to `{#each}` beyond standard behavior.\n\n\n# Svelte 5 — $effect (summary)\n\nEssential Svelte 5 behaviors and pitfalls for `$effect`:\n\n- Runes are language-level; do NOT import `$effect` or other `$` runes.\n- Enable runes with `<svelte:options runes={true} />`.\n- `$effect` auto-tracks dependencies read synchronously from `$state`, `$derived`, and `$props`.\n- Return a teardown function; teardown runs before re-run and on destroy.\n- Use `$effect.pre` to run before DOM updates (useful for measurement and `tick()` coordination).\n- Use `$effect.root` to create a non-tracked scope that requires manual cleanup.\n- Do not use `$effect` for pure derived state — prefer `$derived`.\n\nEdge cases:\n- Conditional reads are only tracked when executed; avoid relying on implicit tracking of mutated object internals without reassigning the reference.\n\nExamples and generic usage intentionally omitted.\n\n# Svelte 5 — $inspect (summary)\n\nPractical Svelte 5 points for `$inspect`:\n\n- `$inspect` is a dev-only reactive inspection helper — use it for debugging.\n- `$inspect(...).with(fn)` accepts a callback; the callback's first argument indicates call type (`init` | `update`).\n- `$inspect.trace(label?)` enables tracing and must be the first statement in a function body.\n- `$inspect` and `$inspect.trace` are runes — do not import them; enable runes with `<svelte:options runes={true} />`.\n\nThis file focuses on the API surface; verbose test mandates removed.\n\n# Svelte 5 Props Reference\n\n# Svelte 5 props — focused rules\n\nThis file intentionally keeps only Svelte 5–specific prop semantics and patterns.\n\n- Call and destructure `$props()` exactly once. Example:\n\n  ```svelte\n  let { id, name = 'Guest' } = $props();\n  ```\n\n  Reason: repeated calls or multiple scattered destructurings can confuse the compiler and make intent unclear.\n\n- Props are read-only. If you need mutable local state, copy prop values into local state (e.g., a `$state` value) or design the component to accept callbacks for mutations.\n\n  Alternatives:\n  - Use `$bindable()` for writable bindings where appropriate.\n  - Accept an `onChange`/callback prop so the parent maintains authoritative state.\n\n- Provide sensible defaults when destructuring: `let { count = 0 } = $props();`.\n\n- Per-instance IDs: newer Svelte 5 releases may expose `$props.id()` to obtain a stable instance identifier; prefer that for stable identity in tests or lists rather than generating random IDs inside the component.\n\n- Testing note: prefer stable attributes provided by the parent (for example `data-testid`) instead of relying on component-internal generated IDs.\n\n\n# Svelte 5 Snippets — concise\n\nFocus: Svelte 5–specific snippet rules and minimal examples. Keep only net-new behaviors and guidance.\n\n- Snippets are template constructs (not JS functions). Use `{#snippet name(params)}...{/snippet}` and render with `{@render name(args)}`.\n- Do not use `return` or JSX inside snippets — write template markup directly.\n\nExample (minimal):\n```svelte\n<svelte:options runes={true} />\n\n{#snippet title(text)}\n  <span data-testid=\"title\">{text}</span>\n{/snippet}\n\n{#each items as item}\n  <li>{@render title(item)}</li>\n{/each}\n```\n\nProps & children:\n- Implicit children become a `children` snippet; access via `$props()`.\n- Use `{@render children?.()}` or conditional rendering for fallbacks.\n\nTypeScript:\n- Annotate snippet props with interfaces and destructure from `$props()`.\n\nExported snippets:\n- Svelte 5 supports exporting snippet utilities from module scripts (behavior may vary by patch).\n\nFor complex behavior, combine snippets with runes and composable state helpers."
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n\n  $state.count = count;\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {count}</p>\n  <button data-testid=\"increment-button\" on:click={() => $state.count++}>\n  </button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {count}</p>\n      <p>ShowDetails is true</p>\n    </div>\n  {/if}\n</div>",
        "success": false,
        "errors": [
          "tmp/samples/lmstudio/Component.svelte:6:2 `$state.count` is not a valid rune\nhttps://svelte.dev/e/rune_invalid_name"
        ],
        "temperature": 0
      }
    ]
  },
  {
    "testName": "snippets",
    "provider": "LMStudio",
    "modelId": "qwen/qwen3-4b-2507",
    "numSamples": 1,
    "numCorrect": 1,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "# Svelte 5 Anti-Patterns — focused\n\nKeep only Svelte 5–specific anti-patterns:\n\n- Do NOT import rune identifiers or use external rune libraries — runes are language-level.\n- Avoid mutating props directly; use `$bindable()` or callbacks for writable semantics.\n- Do not use `$effect` to derive state — prefer `$derived` for pure computations.\n- Avoid exporting reassigned `$state` values from `.svelte.js`/`.svelte.ts`; instead expose getters/setters to preserve reactivity.\n- Be cautious with event directive differences from Svelte 4; consult the repo's notes for specific breakages.\n\nRemoved general JS/UX guidance to keep this file tightly scoped.\n- Use modern Svelte 5 APIs instead of legacy APIs (e.g., prefer callback props over `createEventDispatcher`).\n\n\n# Svelte 5 Best Practices — distilled\n\nThis file summarizes only Svelte 5–specific guidance (runes, new reactive primitives, and breaking changes from Svelte 4).\n\nKey points\n\nTesting and debugging\n\nThis document intentionally omits generic Svelte usage to keep focus on net-new Svelte 5 behaviors.\n# Svelte 5 Best Practices — distilled\n\nThis file summarizes only Svelte 5–specific guidance (runes, new reactive primitives, and breaking changes from Svelte 4).\n\nKey points\n- Enable runes per-component: `<svelte:options runes={true} />`.\n- Runes (`$state`, `$derived`, `$effect`, `$inspect`) are language-level — do not import them.\n- Props are read-only: destructure once from `$props()`; use local `$state` copies, `$bindable()`, or callback props for writable behavior.\n- Use `$derived` for pure computed values and `$effect` for side effects (effects can return teardown functions).\n- `$inspect` and `$inspect.trace` are dev-only; `$inspect.trace` must be the first statement in a function body.\n- Be aware of syntactic differences from Svelte 4 (see other repo notes for specifics).\n\nTesting and debugging\n- Add `data-testid` attributes for stable selectors in tests.\n- Use `$effect.root` or explicit cleanup in tests to avoid cross-test leaks.\n\nThis document intentionally omits generic Svelte usage to keep focus on net-new Svelte 5 behaviors.\n\n\n# Svelte 5 — $derived (concise)\n\nKey Svelte 5 behaviors for `$derived`:\n\n- `$derived` is built-in; do NOT import it.\n- Use `let x = $derived(expr)` for straightforward computed values.\n- Use `$derived.by(() => { ... })` when returning complex objects; store the object before destructuring.\n- `$derived` auto-updates when dependencies change; avoid side effects inside derived functions.\n\nThis document focuses on Svelte 5 semantics; generic examples removed.\n\n# Svelte 5 Each Blocks — notes\n\nConcise Svelte 5 notes for `{#each}` usage:\n\n- Use stable primitive keys in keyed each blocks: `{#each items as item (item.id)}`.\n- Supported iterables: arrays, Maps, Sets, and array-like objects.\n- Use `{:else}` for empty lists.\n\nNo Svelte 5–specific API changes to `{#each}` beyond standard behavior.\n\n\n# Svelte 5 — $effect (summary)\n\nEssential Svelte 5 behaviors and pitfalls for `$effect`:\n\n- Runes are language-level; do NOT import `$effect` or other `$` runes.\n- Enable runes with `<svelte:options runes={true} />`.\n- `$effect` auto-tracks dependencies read synchronously from `$state`, `$derived`, and `$props`.\n- Return a teardown function; teardown runs before re-run and on destroy.\n- Use `$effect.pre` to run before DOM updates (useful for measurement and `tick()` coordination).\n- Use `$effect.root` to create a non-tracked scope that requires manual cleanup.\n- Do not use `$effect` for pure derived state — prefer `$derived`.\n\nEdge cases:\n- Conditional reads are only tracked when executed; avoid relying on implicit tracking of mutated object internals without reassigning the reference.\n\nExamples and generic usage intentionally omitted.\n\n# Svelte 5 — $inspect (summary)\n\nPractical Svelte 5 points for `$inspect`:\n\n- `$inspect` is a dev-only reactive inspection helper — use it for debugging.\n- `$inspect(...).with(fn)` accepts a callback; the callback's first argument indicates call type (`init` | `update`).\n- `$inspect.trace(label?)` enables tracing and must be the first statement in a function body.\n- `$inspect` and `$inspect.trace` are runes — do not import them; enable runes with `<svelte:options runes={true} />`.\n\nThis file focuses on the API surface; verbose test mandates removed.\n\n# Svelte 5 Props Reference\n\n# Svelte 5 props — focused rules\n\nThis file intentionally keeps only Svelte 5–specific prop semantics and patterns.\n\n- Call and destructure `$props()` exactly once. Example:\n\n  ```svelte\n  let { id, name = 'Guest' } = $props();\n  ```\n\n  Reason: repeated calls or multiple scattered destructurings can confuse the compiler and make intent unclear.\n\n- Props are read-only. If you need mutable local state, copy prop values into local state (e.g., a `$state` value) or design the component to accept callbacks for mutations.\n\n  Alternatives:\n  - Use `$bindable()` for writable bindings where appropriate.\n  - Accept an `onChange`/callback prop so the parent maintains authoritative state.\n\n- Provide sensible defaults when destructuring: `let { count = 0 } = $props();`.\n\n- Per-instance IDs: newer Svelte 5 releases may expose `$props.id()` to obtain a stable instance identifier; prefer that for stable identity in tests or lists rather than generating random IDs inside the component.\n\n- Testing note: prefer stable attributes provided by the parent (for example `data-testid`) instead of relying on component-internal generated IDs.\n\n\n# Svelte 5 Snippets — concise\n\nFocus: Svelte 5–specific snippet rules and minimal examples. Keep only net-new behaviors and guidance.\n\n- Snippets are template constructs (not JS functions). Use `{#snippet name(params)}...{/snippet}` and render with `{@render name(args)}`.\n- Do not use `return` or JSX inside snippets — write template markup directly.\n\nExample (minimal):\n```svelte\n<svelte:options runes={true} />\n\n{#snippet title(text)}\n  <span data-testid=\"title\">{text}</span>\n{/snippet}\n\n{#each items as item}\n  <li>{@render title(item)}</li>\n{/each}\n```\n\nProps & children:\n- Implicit children become a `children` snippet; access via `$props()`.\n- Use `{@render children?.()}` or conditional rendering for fallbacks.\n\nTypeScript:\n- Annotate snippet props with interfaces and destructure from `$props()`.\n\nExported snippets:\n- Svelte 5 supports exporting snippet utilities from module scripts (behavior may vary by patch).\n\nFor complex behavior, combine snippets with runes and composable state helpers."
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n{#snippet title(title)}\n  <span data-testid=\"book-title\">{title}</span>\n{/snippet}\n\n<script>\n  let books = [\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"];\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0
      }
    ]
  }
]