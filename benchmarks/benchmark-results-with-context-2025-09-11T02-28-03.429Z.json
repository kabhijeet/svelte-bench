[
  {
    "testName": "counter",
    "provider": "LMStudio",
    "modelId": "unsloth/Qwen3-Coder-30B-A3B-Instruct-GGUF",
    "numSamples": 1,
    "numCorrect": 1,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "# Svelte 5 Anti-Patterns\n\n## ‚ùå CRITICAL: Missing Content\n\n- **Do NOT generate empty components!** Always include the actual content requested\n- For \"Hello World\" tasks: MUST display \"Hello, World!\" text, not just structure\n- Template structure alone is insufficient - include the actual requirements\n\n## Event Handling\n\n- Do not use `on:click`, `on:submit`, or other Svelte 4-style event directives in Svelte 5. Use standard HTML event attributes like `onclick`, `onsubmit`, etc. instead.\n\n## Legacy Practices\n\n- Do not rely on implicit reactivity from Svelte 4 (`let` declarations, `$:` statements`).\n- Use modern Svelte 5 APIs instead of legacy APIs (e.g., prefer callback props over `createEventDispatcher`).\n\n## Build Tools\n\n- Use SvelteKit for new projects; do not opt for plain Vite, Rollup, or Webpack plugins.\n  - **Note:** SvelteKit is strongly recommended and centralizes best practices.\n\n## Runes Misuse\n\n### General\n\n- Do not use runes from Svelte 4 and prior (will cause compilation errors).\n- Do not import runes, they are part of the language\n\n### `$state`\n\n- Do not directly mutate `$state.raw` values (will not trigger reactive updates).\n- Do not directly export reassigned `$state` variables from `.svelte.js`/`.svelte.ts` modules (leads to non-reactive behavior for imports).\n- Do not mutate state you do not \"own\" (i.e., only mutate props marked `$bindable`).\n- For large collections, prefer using `$state.raw` for better performance, and always reassign the collection when making changes.\n- When updating state objects, avoid direct mutation of nested properties; instead, create new objects to ensure predictable state changes.\n\n### `$derived`\n\n- Do not change state (e.g., `count++`) directly within `$derived` expressions.\n- Avoid creating circular dependencies between derived values and state, as this can lead to infinite update loops.\n\n### State Management Patterns\n\n- Do not export state variables directly; instead, provide getter and setter functions to access and update state, preserving reactivity.\n- When exporting objects containing state, use getters and setters for stateful properties to maintain reactivity in consuming modules.\n\n### `$effect`\n\n- Do not update state directly within `$effect` functions (can lead to convoluted code and infinite loops).\n- Do not use `$effect` to synchronize state or derive new `$state` variables; use `$derived` for derivations.\n- Do not link mutually dependent input values using `$effect`; use `oninput` callbacks or function bindings instead.\n- Do not assume values read asynchronously (e.g., after `await` or in `setTimeout`) within an `$effect` are tracked as dependencies.\n- Do not expect an `$effect` to re-run when a property inside a mutated object changes if the object reference itself remains the same.\n\n## Component Communication\n\n- Do not directly mutate props unless they are explicitly declared as `$bindable()`.\n- Do not mutate a reactive state proxy passed as a prop in a child component (triggers `ownership_invalid_mutation` warning).\n- Do not mutate fallback values of non-bindable props (will not trigger updates).\n- Do not provide `undefined` to a `$bindable()` property that has a fallback value and is bound (results in a runtime error).\n\n### Common Props Mistakes (Svelte 5)\n\n- Always destructure needed props from `$props()` for reactivity; do not use the whole props object.\n- Always provide default values for optional props when destructuring.\n- Use `$bindable()` for two-way binding props.\n- Do not modify props directly; use callbacks to update parent state.\n- Use TypeScript types for complex props.\n\n## Debugging\n\n- Do not leave `$inspect` calls in production code (clutters code, even if they become no-ops).\n- Do not overuse `$inspect` (leads to overwhelming console output).\n- Do not use `$inspect` as a substitute for well-structured state management.\n\n## Reusable Reactive Logic\n\n- Do not export reassigned state directly from `.svelte.js`/`.svelte.ts` files (results in non-reactive behavior for external imports).\n\n## `bind:` Directive\n\n- Do not use reset buttons in forms too frequently (can lead to accidental data loss ‚Äî more of a UX warning).\n- Do not expect `DataTransfer` to be available for `bind:files` in server-side JavaScript runtimes (state should be left uninitialized for SSR).\n- Do not use dimension bindings (`bind:offsetWidth`, etc.) on elements with `display: inline` (their dimensions are not observable; change display style).\n- Do not expect dimension bindings to update if an element's size changes solely due to CSS transformations.\n- Do not use the `bind:group` directive across different components (only works for inputs within the same Svelte component).\n- Do not provide `undefined` to a bound `$bindable()` property that has a fallback value (results in a runtime error).\n\n## Asynchronous Operations (`{#await...}`)\n\n- Do not expect any branch other than the pending branch of an `{#await}` block to render during server-side rendering (SSR).\n\n## Keyed Blocks (`{#key...}`)\n\n- Do not use a constantly changing key value in `{#key}` blocks (leads to excessive DOM manipulation and potential performance degradation).\n\n## Attributes\n\n- Do not declare custom √üproperties or attributes that start with `on`.\n\n\n# Svelte 5 Best Practices\n\n## üöÄ Essential Setup & Syntax\n\n### Component Structure\n- **MANDATORY**: Always start with `<svelte:options runes={true} />` at the top\n- Use `<script>` for component-specific logic\n- Use `<style>` for scoped CSS\n- Maintain clear data flow and effective architecture for maintainability\n\n- When a task requires exact output (e.g., Hello-World) render the literal text `Hello, World!` inside an element with `data-testid=\"greeting\"` (no comments or computed empty strings).\n\n### Event Handling - CRITICAL CHANGE FROM SVELTE 4\n- ‚úÖ Use standard HTML attributes for event handling (`onclick`, `onsubmit`, etc.)\n- ‚ùå Do NOT use Svelte 4 syntax: `on:click`, `on:submit` will cause errors\n- For event modifiers, use wrapper functions instead of the pipe syntax from Svelte 4\n- For multiple handlers, combine them into a single function\n- Keep event handlers simple, moving complex logic to separate functions\n- Remember that event names are lowercase in HTML (`onclick`, not `onClick`)\n\n### Template Syntax Basics\n- Use `{#if expression}` for conditionals\n- Use `{#each expression as item}` for lists\n- Use `{#key value}` to force re-creation of content\n- Use `{#await promise}` for managing Promise states\n- Use `{variable}` for displaying values\n- Use snippets for reusable markup chunks\n\n## üß† Runes\n\n### `$state` - Reactive Variables\n\n- ‚úÖ Use `$state` for reactive UI state: `let count = $state(0)`\n- ‚úÖ Update `$state` variables directly (they behave like regular JavaScript variables)\n- ‚ùå NEVER import runes: `import { $state } from 'svelte'` causes parse errors\n- Use arrow functions for class methods relying on `this` with reactive state\n- Use `$state.raw` for large arrays/objects where deep reactivity isn't needed\n- Use `$state.snapshot` to get a non-reactive copy of state for external libraries\n- Pass getter functions (e.g., `() => a`) to functions needing the current reactive value of `$state` variables\n- When sharing `$state` from `.svelte.js`/`.svelte.ts` files:\n  - Export an object whose properties are mutated\n  - Or export getter functions\n\n### `$derived` - Computed Values\n\n- ‚úÖ Use `$derived` for computed values that are free of side effects: `let doubled = $derived(count * 2)`\n- ‚ùå NEVER import: `import { $derived } from 'svelte'` causes parse errors\n- Use `$derived.by` for complex derivation logic\n- Derived values can be temporarily reassigned for optimistic UI updates\n\n### `$effect` - Side Effects\n\n- ‚úÖ Use `$effect` for side effects and external interactions (e.g., third-party libraries, API calls, analytics, DOM manipulation)\n- ‚ùå NEVER import: `import { $effect } from 'svelte'` causes parse errors\n- Return a teardown function from `$effect` for cleanup (e.g., clearing intervals)\n- Use `$effect.pre` for logic that must run before DOM updates\n- Use `$effect.tracking` to check if code is running in a tracking context\n- Use `$effect.root` for creating non-tracked scopes with manual cleanup for nested effects\n- ‚ùå Do not update state inside effects - use `$derived` for derivations instead\n\n## üîÑ Component Communication & Props\n\n- **CRITICAL**: Props are READ-ONLY. Never assign directly to props\n- Destructure props directly from `$props()` for clarity: `let { name } = $props()`\n- Declare fallback values during destructuring: `let { name = \"default\" } = $props()`\n- Rename props during destructuring if they are invalid JavaScript identifiers\n- Use rest properties (`...others`) to capture remaining props\n- Add type safety using TypeScript interfaces or JSDoc\n- Use `$props.id()` (Svelte 5.20.0+) for unique, consistent component instance IDs\n- Use callback properties for child-to-parent communication (replaces `createEventDispatcher`)\n\n## üîó `bind:` Directive (Two-Way Data Binding)\n\n- Use `bind:` for two-way data flow from child to parent\n- Use shorthand `bind:property` when names match\n- Use function bindings (get/set) for validation or transformation (Svelte 5.9.0+)\n- For readonly bindings, set the get function to `null`\n- Access `bind:this` variables inside `$effect` or event handlers (they are undefined until mount)\n- Mark bindable properties with `$bindable()`\n- Provide fallback values for `$bindable()` properties\n\n## üêû Debugging (`$inspect`)\n\n- Use `$inspect` exclusively for development debugging; it tracks reactive state deeply.\n- Use `$inspect.with()` for custom debugging actions (e.g., `debugger`, `console.trace`).\n- Use `$inspect.trace()` (Svelte 5.14+) to trace function re-runs and identify causes.\n\n## ‚ôªÔ∏è Reusable Logic & State\n\n- Use `.svelte.js` and `.svelte.ts` files to create reusable reactive logic and share reactive state using runes.\n- Keep state logic separate from the wire components.\n\n## üß± Component Structure\n\n- Use `<script>` for component-specific logic.\n- Use `<style>` for scoped CSS.\n- Maintain clear data flow and effective architecture for maintainability.\n\n## üîó `bind:` Directive (Two-Way Data Binding)\n\n- Use `bind:` for two-way data flow from child to parent.\n- Use shorthand `bind:property` when names match.\n- Use function bindings (get/set) for validation or transformation (Svelte 5.9.0+).\n- For readonly bindings, set the get function to `null`.\n- Access `bind:this` variables inside `$effect` or event handlers (they are undefined until mount).\n- Mark bindable properties with `$bindable()`.\n- Provide fallback values for `$bindable()` properties.\n\n## üß© Template Syntax\n\n- Use `{#if expression}` for conditionals.\n- Use `{#each expression as item}` for lists.\n- Use `{#key value}` to force re-creation of content.\n- Use `{#await promise}` for managing Promise states.\n- Use snippets for reusable markup chunks.\n\n## üéâ Event Handling\n\n- Use standard HTML attributes for event handling (onclick, onsubmit, etc.)\n- For event modifiers, use wrapper functions instead of the pipe syntax from Svelte 4\n- For multiple handlers, combine them into a single function\n- Keep event handlers simple, moving complex logic to separate functions\n- Remember that event names are lowercase in HTML (onclick, not onClick)Event Handing\n\n## Component Events\n\n- Use callback props instead of event dispatching for component communication\n- Name callback props with an \"on\" prefix (e.g., onSubmit, onChange)\n- Pass data as an object to allow for future extensibility\n- For multiple events, use multiple callback props\n- Consider using TypeScript to type your callback props\n\n## Snippets\n\n- Use snippets to reduce duplication in your templates\n- Snippets can be passed as props to components\n- Snippets have lexical scoping rules - they are only visible in the same scope they are defined in\n- Use parameters to make snippets more flexible\n- Snippets can reference other snippets and even themselves (for recursion)\n\n## üè™ Store\n\n- Use stores only for:\n  - Interoperability with external libraries.\n  - Complex async data streams.\n  - Large apps.\n  - Scenarios needing explicit subscribe/unsubscribe behavior.\n\n## üß† Context\n\n- Store reactive state in context for child component access.\n- Wrap `setContext` and `getContext` in helper functions for type safety.\n- Context can and should be used for small to medium-sized applications to share state between components. It is also ideal for shared state, especially in SSR, as it avoids cross-request data leakage.\n\n## üß† Context\n\n- Store reactive state in context for child component access.\n- Wrap `setContext` and `getContext` in helper functions for type safety.\n- Context is ideal for shared state, especially in SSR, as it avoids cross-request data leakage.\n\n## üß™ Testing\n\n- Use **Vitest** for unit and integration testing.\n- Adjust `vite.config.js` to use browser entry points or alias backend libraries.\n- Include `.svelte` in test filenames for rune processing.\n- Wrap `$effects` in `$effect.root` during tests.\n- Use `flushSync` to run pending effects synchronously.\n- Use https://testing-library.com/docs/svelte-testing-library/intro.\n- Use **Playwright** for E2E testing.\n\n## üì¶ Packages\n\n- Explore new/popular packages at https://www.sveltesociety.dev/packages.\n\n## üîê Security\n\n- To prevent XSS attacks:\n  - Escape strings passed to `{@html ...}`.\n  - Ensure content is from trusted sources.\n  - The expression must be valid standalone HTML.\n\n## üß± Error Boundaries\n\n- Use `onerror` to integrate with error reporting services.\n- Wrap flaky components in `<svelte:boundary>` to isolate errors.\n- `<svelte:boundary>` requires a failed snippet or `onerror` function.\n- It does **not** catch errors outside rendering (e.g., event handlers, `setTimeout`, async work).\n\n\n# Svelte 5 $derived - LLM Context Guide\n\n**CRITICAL: $derived is built-in - NO imports needed. Importing causes parse errors.**\n\n## Syntax Rules\n- ‚úÖ `let x = $derived(expr)` - simple expressions  \n- ‚úÖ `let x = $derived.by(() => {...})` - complex logic\n- ‚úÖ `onclick={handler}` - NOT `on:click`\n- ‚úÖ `<svelte:options runes={true} />`\n- ‚ùå NEVER `import { $derived } from 'svelte/runes'`\n\n## Verified Working Template\n```svelte\n<svelte:options runes={true} />\n<script>\n\tlet count = $state(0);\n\tlet doubled = $derived(count * 2);\n\tconst increment = () => count++;\n</script>\n<div>\n\t<p data-testid=\"count-value\">Count: {count}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>\n```\n\n## $derived.by Example\n```svelte\n<script>\n\tlet items = $state([1, 2, 3]);\n\tlet sum = $derived.by(() => items.reduce((a, b) => a + b, 0));\n\t\n\t// ‚ùå INVALID - Cannot destructure $derived.by() return\n\t// const { wordCount, charCount } = $derived.by(() => ({ ... }));\n\t\n\t// ‚úÖ CORRECT - Store return value first\n\tlet stats = $derived.by(() => {\n\t\tconst words = text.split(' ').length;\n\t\tconst chars = text.length;\n\t\treturn { wordCount: words, charCount: chars, isLong: chars > 50 };\n\t});\n\t// Then access: stats.wordCount, stats.charCount, stats.isLong\n</script>\n```\n\n## Key Behaviors\n- Auto-updates when dependencies change\n- Pure expressions only (no mutations)\n- Push-pull: dependencies notify, values calculate on read\n- Can destructure: `let { a, b } = $derived(obj())` - ONLY simple $derived\n- **CRITICAL**: Cannot destructure `$derived.by()` - store return value first\n- Overridable since 5.25+\n\n# Svelte 5 Each Blocks\n\nIterate over arrays, array-like objects, or iterables (Map, Set) using `{#each}` blocks. Supports destructuring and optional keys for efficient DOM updates.\n\n## Basic Syntax\n\n```svelte\n{#each expression as name}...{/each}\n{#each expression as name, index}...{/each}\n```\n\n```svelte\n<ul>\n\t{#each items as item}\n\t\t<li>{item.name} x {item.qty}</li>\n\t{/each}\n</ul>\n```\n\n## Keyed Each Blocks\n\nUse unique keys to optimize DOM updates when data changes:\n\n```svelte\n{#each expression as name (key)}...{/each}\n```\n\n```svelte\n{#each items as item (item.id)}\n\t<li>{item.name} x {item.qty}</li>\n{/each}\n```\n\nKeys should be strings or numbers for identity persistence.\n\n## Destructuring\n\n```svelte\n{#each items as { id, name, qty }, i (id)}\n\t<li>{i + 1}: {name} x {qty}</li>\n{/each}\n```\n\n## Rendering N Times\n\n```svelte\n{#each { length: 8 }, index}\n\t<div>Item {index}</div>\n{/each}\n```\n\n## Else Clause\n\n```svelte\n{#each todos as todo}\n\t<p>{todo.text}</p>\n{:else}\n\t<p>No tasks today!</p>\n{/each}\n\n# Svelte 5 ‚Äî $effect (compressed)\n\nPurpose: browser-only rune for side effects after mount and after state updates. Do not use for derived state.\n\nCritical rules\n- Runes are built-in; DO NOT import `$state`, `$effect`, etc. (e.g. `import { $effect } from 'svelte/runes'` causes parse errors ‚Äî \"The $ prefix is reserved\").\n- Enable runes with `<svelte:options runes={true} />`.\n- Use `onclick={handler}` (Svelte 5), not `on:click={...}`.\n\nBehavior\n- Runs after component mount and in a microtask after state changes.\n- Dependencies: automatically tracked ‚Äî any `$state`, `$derived`, `$props` read synchronously inside the effect become dependencies.\n- Conditional reads are tracked only when executed (dependency set is recalculated each run).\n- Return a teardown function to cleanup; teardown runs before re-run and on destroy.\n\nSpecial variants\n- `$effect.pre(fn)`: runs before DOM update (useful for measuring DOM & scheduling `tick()`).\n- `$effect.root(fn)`: create a non-tracked scope that doesn't auto-cleanup; returns a `destroy()` to call manually.\n\nWhen to use\n- DOM manipulation (canvas), third-party libs, event listeners, timers, network requests.\n\nWhen NOT to use\n- State synchronization. Use `$derived(...)` for derived/computed state.\n\nCanonical minimal snippets (copy-paste safe)\n\nEnable runes:\n<svelte:options runes={true} />\n\nBasic effect (derived incorrectly shown only for demonstration ‚Äî prefer `$derived` in real code):\n```svelte\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n```\n\nCleanup (interval):\n```svelte\n<script>\n  let count = $state(0);\n  let milliseconds = $state(1000);\n\n  $effect(() => {\n    const interval = setInterval(() => count += 1, milliseconds);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\nPre-effect (before DOM update):\n```svelte\n<script>\n  import { tick } from 'svelte';\n  let div = $state();\n  let messages = $state([]);\n\n  $effect.pre(() => {\n    if (!div) return;\n    messages.length; // track\n    if (div.offsetHeight + div.scrollTop > div.scrollHeight - 20) {\n      tick().then(() => div.scrollTo(0, div.scrollHeight));\n    }\n  });\n</script>\n```\n\nroot scope:\n```js\nconst destroy = $effect.root(() => {\n  $effect(() => { /* setup */ });\n  return () => { /* cleanup */ };\n});\n// later: destroy();\n```\n\nEdge cases / pitfalls\n- Invalid imports break parsing ‚Äî never import `$` runes.\n- Mutating an object vs reassigning: read specific properties to track them (mutating top-level object may not retrigger effects that only read the object reference).\n- Conditional reads: a value read only inside an `if` is only a dependency when that branch executed.\n- Use `$effect.pre` when you must measure DOM before updates.\n- `$effect.root` requires manual cleanup (not auto-cleaned).\n\nTesting & best-practices\n- Include `data-testid` in examples for tests.\n- Prefer `$derived` for computed values; `$effect` only for side effects.\n\nOne-line summary: `$effect` = built-in Svelte 5 side-effect rune; no imports; auto-deps; return teardown for cleanup; use `$derived` for pure derived state.\n\n# Svelte 5 $inspect Rune - Dense Reference\n\n**Dev-only reactive debugger. Re-runs on reactive state changes. Template literals MUST use backticks (`)**\n\n## Core Implementation\n```svelte\n<svelte:options runes={true} />\n<script>\n\tlet text = $state(\"Hello world\");\n\t$inspect(text); // Basic usage\n\t$inspect(text).with((type, value) => { // Custom logging\n\t\tif (type === \"update\") console.log(`Text updated to: \"${value}\"`);\n\t});\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // MUST be first statement\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\t});\n</script>\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n</div>\n```\n\n## Basic Usage\n\nThe simplest form of `$inspect` logs values to the console whenever they change:\n\n```svelte\n<script>\n\tlet count = $state(0);\n\tlet message = $state('hello');\n\n\t$inspect(count, message); // will console.log when `count` or `message` change\n</script>\n\n<button onclick={() => count++}>Increment</button>\n<input bind:value={message} />\n```\n\n## Text Input Example with Quotes\n\nWhen working with text inputs, you often want to display the value with quotes to show empty strings clearly:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// Basic $inspect usage\n\t$inspect(text);\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n\t<p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>\n```\n\nNote: Always wrap text values in quotes when displaying them in UI to make empty strings visible.\n\n## $inspect(...).with\n\n`$inspect` returns a property `with`, which you can invoke with a callback, which will then be invoked instead of `console.log`. The first argument to the callback is either `\"init\"` or `\"update\"`; subsequent arguments are the values passed to `$inspect`.\n\n### Custom Console Logging\n\n**MANDATORY SYNTAX**: Template literals MUST use backticks (`), not quotes:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\n\t// Custom callback for tracking text changes\n\t$inspect(text).with((type, value) => {\n\t\tif (type === \"update\") {\n\t\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t\t}\n\t});\n</script>\n\n<input bind:value={text} />\n```\n\n**CRITICAL**: Always use backticks (`) for template literals:\n- ‚úÖ `console.log(\\`Text updated to: \"${value}\"\\`);`\n- ‚ùå `console.log(Text updated to: \"${value}\");` ‚Üê Missing backticks causes syntax error\n\nThe callback receives:\n- `type`: Either `\"init\"` (first call) or `\"update\"` (subsequent changes)  \n- `value`: The current value being inspected\n\n### Debugging Example\n\n```svelte\n<script>\n\tlet count = $state(0);\n\n\t$inspect(count).with((type, count) => {\n\t\tif (type === 'update') {\n\t\t\tdebugger; // or `console.trace`, or whatever you want\n\t\t}\n\t});\n</script>\n\n<button onclick={() => count++}>Increment</button>\n```\n\nA convenient way to find the origin of some change is to pass `console.trace` to `with`:\n\n```js\n$inspect(stuff).with(console.trace);\n```\n\n## $inspect.trace(...)\n\nThis rune, added in 5.14, causes the surrounding function to be _traced_ in development. Any time the function re-runs as part of an effect or a derived, information will be printed to the console about which pieces of reactive state caused the effect to fire.\n\n**üö® CRITICAL PLACEMENT WARNING**: `$inspect.trace` MUST be the first statement of a function body. Placing it anywhere else will cause a compile error.\n\n### ‚ùå WRONG - $inspect.trace not in first position\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t$effect(() => {\n\t\tconsole.log('[$effect] Input text changed to:', text); // ‚ùå Statement before $inspect.trace\n\t\t$inspect.trace(); // ‚ùå WRONG POSITION - will cause compile error\n\t});\n</script>\n```\n\n**Error**: `$inspect.trace(...)` must be the first statement of a function body\n\n### ‚úÖ CORRECT - $inspect.trace as first statement\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // ‚úÖ CORRECT - First statement\n\t\tconsole.log(`[$effect] Input text changed to: \"${text}\"`);\n\t});\n</script>\n```\n\n### Basic Usage in Effects\n\n**MANDATORY**: Always place `$inspect.trace` as the very first line inside function bodies:\n\n```svelte\n<script>\n\timport { doSomeWork } from './elsewhere';\n\n\t$effect(() => {\n\t\t$inspect.trace(); // ‚úÖ Must be first statement\n\t\tdoSomeWork();\n\t});\n</script>\n```\n\n### Text Input Tracking with Effects\n\nFor text input tracking, combine `$inspect.trace` with effects to monitor changes:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// ‚úÖ CORRECT - $inspect.trace as first statement\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // ‚úÖ Optional label, MUST be first\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\t});\n</script>\n\n<input bind:value={text} />\n```\n\n**CRITICAL SYNTAX RULES:**\n1. ‚úÖ `$inspect.trace()` MUST be the very first statement inside `$effect(() => {`  \n2. ‚ùå NEVER put any other code before `$inspect.trace()`\n3. ‚úÖ Use template literals with backticks: `` console.log(`text: \"${text}\"`) ``\n4. ‚ùå NEVER omit backticks: `console.log(text: \"${text}\")` ‚Üê SYNTAX ERROR\n\n`$inspect.trace` takes an optional first argument which will be used as the label.\n\n## Complete Working Example\n\nHere's a complete example that demonstrates all `$inspect` features with proper formatting:\n\n```svelte\n<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// 1. Basic $inspect usage\n\t$inspect(text);\n\t\n\t// 2. Using $inspect(...).with for custom logging\n\t$inspect(text).with((type, value) => {\n\t\tif (type === \"update\") {\n\t\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t\t}\n\t});\n\t\n\t// 3. MANDATORY: $effect with $inspect.trace AND console.log\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // MUST be first\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`); // REQUIRED\n\t});\n</script>\n\n<div>\n\t<label for=\"text-input\">Edit text:</label>\n\t<input \n\t\tdata-testid=\"text-input\" \n\t\tid=\"text-input\" \n\t\ttype=\"text\" \n\t\tbind:value={text} \n\t/>\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n\t<p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>\n```\n\n## MANDATORY Patterns for Tests\n\n**$effect with $inspect MUST include console.log:**\n```js\n$effect(() => {\n\t$inspect.trace(\"text-changes\"); // Always first statement\n\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`); // REQUIRED format\n});\n```\n\n**$inspect.with MUST check update type:**\n```js\n$inspect(text).with((type, value) => {\n\tif (type === \"update\") { // REQUIRED check\n\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t}\n});\n```\n\n## Key Points for Testing\n\n- Always wrap displayed text values in quotes to show empty strings clearly\n- Use specific console.log message formats for predictable testing\n- Include proper `data-testid` attributes for test targeting\n- The `$inspect(...).with` callback should check for `type === \"update\"` to avoid init logs\n- Console messages should include the exact format: `Text updated to: \"${value}\"`\n- Effect logging should follow the pattern: `The text is now: \"${text}\" (${text.length} characters)`\n\n### Critical Syntax Reminders\n\n**Template Literals**: Always use backticks (`) for template literals, not regular quotes:\n```javascript\n// ‚úÖ CORRECT\nconsole.log(`Text updated to: \"${value}\"`);\nconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\n// ‚ùå WRONG - missing backticks\nconsole.log(Text updated to: \"${value}\");\nconsole.log(The text is now: \"${text}\" (${text.length} characters));\n```\n\n**Input Element**: Always include all required attributes:\n```html\n<!-- ‚úÖ CORRECT -->\n<input \n    data-testid=\"text-input\" \n    id=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n/>\n\n<!-- ‚ùå WRONG - incomplete -->\n<input \n```\n\n# Svelte 5 Props Reference\n\n## Basic Props\n```svelte\n<!-- Parent -->\n<MyComponent adjective=\"cool\" />\n\n<!-- Child -->\n<script>\n  let { adjective } = $props(); // destructured (recommended)\n  let props = $props(); // or access via props.adjective\n</script>\n```\n\n## Fallbacks & Renaming\n```js\nlet { adjective = 'happy' } = $props(); // fallback value\nlet { super: trouper = 'default' } = $props(); // rename invalid identifier\nlet { a, b, ...others } = $props(); // rest props\n```\n\nCall $props() exactly once ‚Äî destructure all props in a single call or use a single props object to avoid the `props_duplicate` compile error.\n\nMinimal correct pattern:\n```svelte\n// correct ‚Äî single $props() call\nlet props = $props(); let { name = \"World\", count = 0, showDetails = false } = props;\n```\n\n## Prop Mutation Rules - CRITICAL\n\n**Props are READ-ONLY. Never assign to props directly:**\n\n‚ùå **FORBIDDEN - Will cause compilation errors:**\n```js\nlet { text } = $props();\ntext = \"new value\"; // ‚ùå COMPILE ERROR - props are read-only\n```\n\n‚úÖ **CORRECT - Use local state for modifications:**\n```js\nlet { text } = $props();\nlet localText = $state(text); // Copy to local state\n// Now modify localText: localText = \"new value\"; ‚úÖ\n```\n\n**Rules:**\n- ‚ùå Direct assignment: `prop = value` causes compilation errors\n- ‚ùå Direct mutation: `prop.property = value` (unless `$bindable`) \n- ‚úÖ Local state: `let local = $state(prop)` then modify `local`\n- ‚úÖ Temporary reassignment: only for local scope override\n- Regular objects: mutations have no effect\n- Reactive proxies: mutations work but trigger warnings\n- Fallback values: not reactive, mutations ignored\n\n## Type Safety\n```svelte\n<script lang=\"ts\">\n  interface Props { adjective: string; }\n  let { adjective }: Props = $props();\n  \n  // Or inline\n  let { adjective }: { adjective: string } = $props();\n  \n  // JSDoc\n  /** @type {{ adjective: string }} */\n  let { adjective } = $props();\n</script>\n```\n\n## Unique IDs\n```svelte\n<script>\n  const uid = $props.id(); // unique per component instance\n</script>\n<label for=\"{uid}-input\">Label</label>\n<input id=\"{uid}-input\" />\n```\n\n## Key Points\n- Props update reactively when parent changes\n- Use callbacks or `$bindable` for child-to-parent communication\n- Fallback values aren't reactive proxies\n- Type annotations recommended for discoverability\n- DOM element interfaces in `svelte/elements`\n\n# Svelte 5 Snippets\n```svelte\n<svelte:options runes={true} />\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n<style></style>\n```\n\n## CRITICAL SYNTAX RULES\n- ‚ùå NEVER use `return` keyword or JSX syntax `<span>`\n- ‚úÖ ALWAYS use pure Svelte template syntax: `{#snippet name(params)}...{/snippet}`\n- ‚ùå NOT: `const title = snippet((param) => { return <span>{param}</span>; })`\n- ‚úÖ CORRECT: `{#snippet title(param)}<span>{param}</span>{/snippet}`\n\n## Basic Syntax\n```svelte\n{#snippet name()}...{/snippet}\n{#snippet name(param1, param2)}...{/snippet}\n{@render name(args)}\n```\n\n## Working Example\n```svelte\n<svelte:options runes={true} />\n<script>\n\tconst items = [\"item1\", \"item2\"];\n</script>\n{#snippet title(text)}\n\t<span data-testid=\"title\">{text}</span>\n{/snippet}\n<ul>\n\t{#each items as item}\n\t\t<li>{@render title(item)}</li>\n\t{/each}\n</ul>\n```\n\n## Scope & Parameters\n- Snippets access lexical scope variables\n- Support default values & destructuring: `{#snippet name(param = default)}`\n- Can reference themselves (recursion) and siblings\n- No rest parameters support\n\n## Component Props\n**Explicit:** `<Table {header} {row} />`\n**Implicit:** Content inside component becomes props automatically\n**Children:** Non-snippet content becomes `children` snippet\n\n```svelte\n<!-- Implicit children -->\n<Button>click me</Button>\n\n<!-- Button.svelte -->\n<script>let { children } = $props();</script>\n<button>{@render children()}</button>\n\n<!-- Optional snippets -->\n{@render children?.()}\n{#if children}{@render children()}{:else}fallback{/if}\n```\n\n## TypeScript\n```svelte\n<script lang=\"ts\">\n\timport type { Snippet } from 'svelte';\n\tinterface Props {\n\t\tchildren: Snippet;\n\t\trow: Snippet<[DataType]>;\n\t}\n\tlet { children, row }: Props = $props();\n</script>\n```\n\n## Export (Svelte 5.5.0+)\n```svelte\n<script module>export { add };</script>\n{#snippet add(a, b)}{a} + {b} = {a + b}{/snippet}\n```\n\n## Key Facts\n- Replace Svelte 4 slots with more power/flexibility\n- Template constructs, not JS functions\n- Avoid props named `children` with implicit children\n- Use `createRawSnippet` API for advanced cases"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n<script>\n\tlet count = $state(0);\n\tconst increment = () => count++;\n\tconst decrement = () => count--;\n</script>\n<div class=\"counter\">\n\t<button data-testid=\"decrement-button\" onclick={decrement}>-</button>\n\t<span data-testid=\"count-value\">{count}</span>\n\t<button data-testid=\"increment-button\" onclick={increment}>+</button>\n</div>\n<style>\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0
      }
    ]
  },
  {
    "testName": "derived",
    "provider": "LMStudio",
    "modelId": "unsloth/Qwen3-Coder-30B-A3B-Instruct-GGUF",
    "numSamples": 1,
    "numCorrect": 0,
    "pass1": 0,
    "pass10": 0,
    "context": {
      "used": true,
      "content": "# Svelte 5 Anti-Patterns\n\n## ‚ùå CRITICAL: Missing Content\n\n- **Do NOT generate empty components!** Always include the actual content requested\n- For \"Hello World\" tasks: MUST display \"Hello, World!\" text, not just structure\n- Template structure alone is insufficient - include the actual requirements\n\n## Event Handling\n\n- Do not use `on:click`, `on:submit`, or other Svelte 4-style event directives in Svelte 5. Use standard HTML event attributes like `onclick`, `onsubmit`, etc. instead.\n\n## Legacy Practices\n\n- Do not rely on implicit reactivity from Svelte 4 (`let` declarations, `$:` statements`).\n- Use modern Svelte 5 APIs instead of legacy APIs (e.g., prefer callback props over `createEventDispatcher`).\n\n## Build Tools\n\n- Use SvelteKit for new projects; do not opt for plain Vite, Rollup, or Webpack plugins.\n  - **Note:** SvelteKit is strongly recommended and centralizes best practices.\n\n## Runes Misuse\n\n### General\n\n- Do not use runes from Svelte 4 and prior (will cause compilation errors).\n- Do not import runes, they are part of the language\n\n### `$state`\n\n- Do not directly mutate `$state.raw` values (will not trigger reactive updates).\n- Do not directly export reassigned `$state` variables from `.svelte.js`/`.svelte.ts` modules (leads to non-reactive behavior for imports).\n- Do not mutate state you do not \"own\" (i.e., only mutate props marked `$bindable`).\n- For large collections, prefer using `$state.raw` for better performance, and always reassign the collection when making changes.\n- When updating state objects, avoid direct mutation of nested properties; instead, create new objects to ensure predictable state changes.\n\n### `$derived`\n\n- Do not change state (e.g., `count++`) directly within `$derived` expressions.\n- Avoid creating circular dependencies between derived values and state, as this can lead to infinite update loops.\n\n### State Management Patterns\n\n- Do not export state variables directly; instead, provide getter and setter functions to access and update state, preserving reactivity.\n- When exporting objects containing state, use getters and setters for stateful properties to maintain reactivity in consuming modules.\n\n### `$effect`\n\n- Do not update state directly within `$effect` functions (can lead to convoluted code and infinite loops).\n- Do not use `$effect` to synchronize state or derive new `$state` variables; use `$derived` for derivations.\n- Do not link mutually dependent input values using `$effect`; use `oninput` callbacks or function bindings instead.\n- Do not assume values read asynchronously (e.g., after `await` or in `setTimeout`) within an `$effect` are tracked as dependencies.\n- Do not expect an `$effect` to re-run when a property inside a mutated object changes if the object reference itself remains the same.\n\n## Component Communication\n\n- Do not directly mutate props unless they are explicitly declared as `$bindable()`.\n- Do not mutate a reactive state proxy passed as a prop in a child component (triggers `ownership_invalid_mutation` warning).\n- Do not mutate fallback values of non-bindable props (will not trigger updates).\n- Do not provide `undefined` to a `$bindable()` property that has a fallback value and is bound (results in a runtime error).\n\n### Common Props Mistakes (Svelte 5)\n\n- Always destructure needed props from `$props()` for reactivity; do not use the whole props object.\n- Always provide default values for optional props when destructuring.\n- Use `$bindable()` for two-way binding props.\n- Do not modify props directly; use callbacks to update parent state.\n- Use TypeScript types for complex props.\n\n## Debugging\n\n- Do not leave `$inspect` calls in production code (clutters code, even if they become no-ops).\n- Do not overuse `$inspect` (leads to overwhelming console output).\n- Do not use `$inspect` as a substitute for well-structured state management.\n\n## Reusable Reactive Logic\n\n- Do not export reassigned state directly from `.svelte.js`/`.svelte.ts` files (results in non-reactive behavior for external imports).\n\n## `bind:` Directive\n\n- Do not use reset buttons in forms too frequently (can lead to accidental data loss ‚Äî more of a UX warning).\n- Do not expect `DataTransfer` to be available for `bind:files` in server-side JavaScript runtimes (state should be left uninitialized for SSR).\n- Do not use dimension bindings (`bind:offsetWidth`, etc.) on elements with `display: inline` (their dimensions are not observable; change display style).\n- Do not expect dimension bindings to update if an element's size changes solely due to CSS transformations.\n- Do not use the `bind:group` directive across different components (only works for inputs within the same Svelte component).\n- Do not provide `undefined` to a bound `$bindable()` property that has a fallback value (results in a runtime error).\n\n## Asynchronous Operations (`{#await...}`)\n\n- Do not expect any branch other than the pending branch of an `{#await}` block to render during server-side rendering (SSR).\n\n## Keyed Blocks (`{#key...}`)\n\n- Do not use a constantly changing key value in `{#key}` blocks (leads to excessive DOM manipulation and potential performance degradation).\n\n## Attributes\n\n- Do not declare custom √üproperties or attributes that start with `on`.\n\n\n# Svelte 5 Best Practices\n\n## üöÄ Essential Setup & Syntax\n\n### Component Structure\n- **MANDATORY**: Always start with `<svelte:options runes={true} />` at the top\n- Use `<script>` for component-specific logic\n- Use `<style>` for scoped CSS\n- Maintain clear data flow and effective architecture for maintainability\n\n- When a task requires exact output (e.g., Hello-World) render the literal text `Hello, World!` inside an element with `data-testid=\"greeting\"` (no comments or computed empty strings).\n\n### Event Handling - CRITICAL CHANGE FROM SVELTE 4\n- ‚úÖ Use standard HTML attributes for event handling (`onclick`, `onsubmit`, etc.)\n- ‚ùå Do NOT use Svelte 4 syntax: `on:click`, `on:submit` will cause errors\n- For event modifiers, use wrapper functions instead of the pipe syntax from Svelte 4\n- For multiple handlers, combine them into a single function\n- Keep event handlers simple, moving complex logic to separate functions\n- Remember that event names are lowercase in HTML (`onclick`, not `onClick`)\n\n### Template Syntax Basics\n- Use `{#if expression}` for conditionals\n- Use `{#each expression as item}` for lists\n- Use `{#key value}` to force re-creation of content\n- Use `{#await promise}` for managing Promise states\n- Use `{variable}` for displaying values\n- Use snippets for reusable markup chunks\n\n## üß† Runes\n\n### `$state` - Reactive Variables\n\n- ‚úÖ Use `$state` for reactive UI state: `let count = $state(0)`\n- ‚úÖ Update `$state` variables directly (they behave like regular JavaScript variables)\n- ‚ùå NEVER import runes: `import { $state } from 'svelte'` causes parse errors\n- Use arrow functions for class methods relying on `this` with reactive state\n- Use `$state.raw` for large arrays/objects where deep reactivity isn't needed\n- Use `$state.snapshot` to get a non-reactive copy of state for external libraries\n- Pass getter functions (e.g., `() => a`) to functions needing the current reactive value of `$state` variables\n- When sharing `$state` from `.svelte.js`/`.svelte.ts` files:\n  - Export an object whose properties are mutated\n  - Or export getter functions\n\n### `$derived` - Computed Values\n\n- ‚úÖ Use `$derived` for computed values that are free of side effects: `let doubled = $derived(count * 2)`\n- ‚ùå NEVER import: `import { $derived } from 'svelte'` causes parse errors\n- Use `$derived.by` for complex derivation logic\n- Derived values can be temporarily reassigned for optimistic UI updates\n\n### `$effect` - Side Effects\n\n- ‚úÖ Use `$effect` for side effects and external interactions (e.g., third-party libraries, API calls, analytics, DOM manipulation)\n- ‚ùå NEVER import: `import { $effect } from 'svelte'` causes parse errors\n- Return a teardown function from `$effect` for cleanup (e.g., clearing intervals)\n- Use `$effect.pre` for logic that must run before DOM updates\n- Use `$effect.tracking` to check if code is running in a tracking context\n- Use `$effect.root` for creating non-tracked scopes with manual cleanup for nested effects\n- ‚ùå Do not update state inside effects - use `$derived` for derivations instead\n\n## üîÑ Component Communication & Props\n\n- **CRITICAL**: Props are READ-ONLY. Never assign directly to props\n- Destructure props directly from `$props()` for clarity: `let { name } = $props()`\n- Declare fallback values during destructuring: `let { name = \"default\" } = $props()`\n- Rename props during destructuring if they are invalid JavaScript identifiers\n- Use rest properties (`...others`) to capture remaining props\n- Add type safety using TypeScript interfaces or JSDoc\n- Use `$props.id()` (Svelte 5.20.0+) for unique, consistent component instance IDs\n- Use callback properties for child-to-parent communication (replaces `createEventDispatcher`)\n\n## üîó `bind:` Directive (Two-Way Data Binding)\n\n- Use `bind:` for two-way data flow from child to parent\n- Use shorthand `bind:property` when names match\n- Use function bindings (get/set) for validation or transformation (Svelte 5.9.0+)\n- For readonly bindings, set the get function to `null`\n- Access `bind:this` variables inside `$effect` or event handlers (they are undefined until mount)\n- Mark bindable properties with `$bindable()`\n- Provide fallback values for `$bindable()` properties\n\n## üêû Debugging (`$inspect`)\n\n- Use `$inspect` exclusively for development debugging; it tracks reactive state deeply.\n- Use `$inspect.with()` for custom debugging actions (e.g., `debugger`, `console.trace`).\n- Use `$inspect.trace()` (Svelte 5.14+) to trace function re-runs and identify causes.\n\n## ‚ôªÔ∏è Reusable Logic & State\n\n- Use `.svelte.js` and `.svelte.ts` files to create reusable reactive logic and share reactive state using runes.\n- Keep state logic separate from the wire components.\n\n## üß± Component Structure\n\n- Use `<script>` for component-specific logic.\n- Use `<style>` for scoped CSS.\n- Maintain clear data flow and effective architecture for maintainability.\n\n## üîó `bind:` Directive (Two-Way Data Binding)\n\n- Use `bind:` for two-way data flow from child to parent.\n- Use shorthand `bind:property` when names match.\n- Use function bindings (get/set) for validation or transformation (Svelte 5.9.0+).\n- For readonly bindings, set the get function to `null`.\n- Access `bind:this` variables inside `$effect` or event handlers (they are undefined until mount).\n- Mark bindable properties with `$bindable()`.\n- Provide fallback values for `$bindable()` properties.\n\n## üß© Template Syntax\n\n- Use `{#if expression}` for conditionals.\n- Use `{#each expression as item}` for lists.\n- Use `{#key value}` to force re-creation of content.\n- Use `{#await promise}` for managing Promise states.\n- Use snippets for reusable markup chunks.\n\n## üéâ Event Handling\n\n- Use standard HTML attributes for event handling (onclick, onsubmit, etc.)\n- For event modifiers, use wrapper functions instead of the pipe syntax from Svelte 4\n- For multiple handlers, combine them into a single function\n- Keep event handlers simple, moving complex logic to separate functions\n- Remember that event names are lowercase in HTML (onclick, not onClick)Event Handing\n\n## Component Events\n\n- Use callback props instead of event dispatching for component communication\n- Name callback props with an \"on\" prefix (e.g., onSubmit, onChange)\n- Pass data as an object to allow for future extensibility\n- For multiple events, use multiple callback props\n- Consider using TypeScript to type your callback props\n\n## Snippets\n\n- Use snippets to reduce duplication in your templates\n- Snippets can be passed as props to components\n- Snippets have lexical scoping rules - they are only visible in the same scope they are defined in\n- Use parameters to make snippets more flexible\n- Snippets can reference other snippets and even themselves (for recursion)\n\n## üè™ Store\n\n- Use stores only for:\n  - Interoperability with external libraries.\n  - Complex async data streams.\n  - Large apps.\n  - Scenarios needing explicit subscribe/unsubscribe behavior.\n\n## üß† Context\n\n- Store reactive state in context for child component access.\n- Wrap `setContext` and `getContext` in helper functions for type safety.\n- Context can and should be used for small to medium-sized applications to share state between components. It is also ideal for shared state, especially in SSR, as it avoids cross-request data leakage.\n\n## üß† Context\n\n- Store reactive state in context for child component access.\n- Wrap `setContext` and `getContext` in helper functions for type safety.\n- Context is ideal for shared state, especially in SSR, as it avoids cross-request data leakage.\n\n## üß™ Testing\n\n- Use **Vitest** for unit and integration testing.\n- Adjust `vite.config.js` to use browser entry points or alias backend libraries.\n- Include `.svelte` in test filenames for rune processing.\n- Wrap `$effects` in `$effect.root` during tests.\n- Use `flushSync` to run pending effects synchronously.\n- Use https://testing-library.com/docs/svelte-testing-library/intro.\n- Use **Playwright** for E2E testing.\n\n## üì¶ Packages\n\n- Explore new/popular packages at https://www.sveltesociety.dev/packages.\n\n## üîê Security\n\n- To prevent XSS attacks:\n  - Escape strings passed to `{@html ...}`.\n  - Ensure content is from trusted sources.\n  - The expression must be valid standalone HTML.\n\n## üß± Error Boundaries\n\n- Use `onerror` to integrate with error reporting services.\n- Wrap flaky components in `<svelte:boundary>` to isolate errors.\n- `<svelte:boundary>` requires a failed snippet or `onerror` function.\n- It does **not** catch errors outside rendering (e.g., event handlers, `setTimeout`, async work).\n\n\n# Svelte 5 $derived - LLM Context Guide\n\n**CRITICAL: $derived is built-in - NO imports needed. Importing causes parse errors.**\n\n## Syntax Rules\n- ‚úÖ `let x = $derived(expr)` - simple expressions  \n- ‚úÖ `let x = $derived.by(() => {...})` - complex logic\n- ‚úÖ `onclick={handler}` - NOT `on:click`\n- ‚úÖ `<svelte:options runes={true} />`\n- ‚ùå NEVER `import { $derived } from 'svelte/runes'`\n\n## Verified Working Template\n```svelte\n<svelte:options runes={true} />\n<script>\n\tlet count = $state(0);\n\tlet doubled = $derived(count * 2);\n\tconst increment = () => count++;\n</script>\n<div>\n\t<p data-testid=\"count-value\">Count: {count}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>\n```\n\n## $derived.by Example\n```svelte\n<script>\n\tlet items = $state([1, 2, 3]);\n\tlet sum = $derived.by(() => items.reduce((a, b) => a + b, 0));\n\t\n\t// ‚ùå INVALID - Cannot destructure $derived.by() return\n\t// const { wordCount, charCount } = $derived.by(() => ({ ... }));\n\t\n\t// ‚úÖ CORRECT - Store return value first\n\tlet stats = $derived.by(() => {\n\t\tconst words = text.split(' ').length;\n\t\tconst chars = text.length;\n\t\treturn { wordCount: words, charCount: chars, isLong: chars > 50 };\n\t});\n\t// Then access: stats.wordCount, stats.charCount, stats.isLong\n</script>\n```\n\n## Key Behaviors\n- Auto-updates when dependencies change\n- Pure expressions only (no mutations)\n- Push-pull: dependencies notify, values calculate on read\n- Can destructure: `let { a, b } = $derived(obj())` - ONLY simple $derived\n- **CRITICAL**: Cannot destructure `$derived.by()` - store return value first\n- Overridable since 5.25+\n\n# Svelte 5 Each Blocks\n\nIterate over arrays, array-like objects, or iterables (Map, Set) using `{#each}` blocks. Supports destructuring and optional keys for efficient DOM updates.\n\n## Basic Syntax\n\n```svelte\n{#each expression as name}...{/each}\n{#each expression as name, index}...{/each}\n```\n\n```svelte\n<ul>\n\t{#each items as item}\n\t\t<li>{item.name} x {item.qty}</li>\n\t{/each}\n</ul>\n```\n\n## Keyed Each Blocks\n\nUse unique keys to optimize DOM updates when data changes:\n\n```svelte\n{#each expression as name (key)}...{/each}\n```\n\n```svelte\n{#each items as item (item.id)}\n\t<li>{item.name} x {item.qty}</li>\n{/each}\n```\n\nKeys should be strings or numbers for identity persistence.\n\n## Destructuring\n\n```svelte\n{#each items as { id, name, qty }, i (id)}\n\t<li>{i + 1}: {name} x {qty}</li>\n{/each}\n```\n\n## Rendering N Times\n\n```svelte\n{#each { length: 8 }, index}\n\t<div>Item {index}</div>\n{/each}\n```\n\n## Else Clause\n\n```svelte\n{#each todos as todo}\n\t<p>{todo.text}</p>\n{:else}\n\t<p>No tasks today!</p>\n{/each}\n\n# Svelte 5 ‚Äî $effect (compressed)\n\nPurpose: browser-only rune for side effects after mount and after state updates. Do not use for derived state.\n\nCritical rules\n- Runes are built-in; DO NOT import `$state`, `$effect`, etc. (e.g. `import { $effect } from 'svelte/runes'` causes parse errors ‚Äî \"The $ prefix is reserved\").\n- Enable runes with `<svelte:options runes={true} />`.\n- Use `onclick={handler}` (Svelte 5), not `on:click={...}`.\n\nBehavior\n- Runs after component mount and in a microtask after state changes.\n- Dependencies: automatically tracked ‚Äî any `$state`, `$derived`, `$props` read synchronously inside the effect become dependencies.\n- Conditional reads are tracked only when executed (dependency set is recalculated each run).\n- Return a teardown function to cleanup; teardown runs before re-run and on destroy.\n\nSpecial variants\n- `$effect.pre(fn)`: runs before DOM update (useful for measuring DOM & scheduling `tick()`).\n- `$effect.root(fn)`: create a non-tracked scope that doesn't auto-cleanup; returns a `destroy()` to call manually.\n\nWhen to use\n- DOM manipulation (canvas), third-party libs, event listeners, timers, network requests.\n\nWhen NOT to use\n- State synchronization. Use `$derived(...)` for derived/computed state.\n\nCanonical minimal snippets (copy-paste safe)\n\nEnable runes:\n<svelte:options runes={true} />\n\nBasic effect (derived incorrectly shown only for demonstration ‚Äî prefer `$derived` in real code):\n```svelte\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n```\n\nCleanup (interval):\n```svelte\n<script>\n  let count = $state(0);\n  let milliseconds = $state(1000);\n\n  $effect(() => {\n    const interval = setInterval(() => count += 1, milliseconds);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\nPre-effect (before DOM update):\n```svelte\n<script>\n  import { tick } from 'svelte';\n  let div = $state();\n  let messages = $state([]);\n\n  $effect.pre(() => {\n    if (!div) return;\n    messages.length; // track\n    if (div.offsetHeight + div.scrollTop > div.scrollHeight - 20) {\n      tick().then(() => div.scrollTo(0, div.scrollHeight));\n    }\n  });\n</script>\n```\n\nroot scope:\n```js\nconst destroy = $effect.root(() => {\n  $effect(() => { /* setup */ });\n  return () => { /* cleanup */ };\n});\n// later: destroy();\n```\n\nEdge cases / pitfalls\n- Invalid imports break parsing ‚Äî never import `$` runes.\n- Mutating an object vs reassigning: read specific properties to track them (mutating top-level object may not retrigger effects that only read the object reference).\n- Conditional reads: a value read only inside an `if` is only a dependency when that branch executed.\n- Use `$effect.pre` when you must measure DOM before updates.\n- `$effect.root` requires manual cleanup (not auto-cleaned).\n\nTesting & best-practices\n- Include `data-testid` in examples for tests.\n- Prefer `$derived` for computed values; `$effect` only for side effects.\n\nOne-line summary: `$effect` = built-in Svelte 5 side-effect rune; no imports; auto-deps; return teardown for cleanup; use `$derived` for pure derived state.\n\n# Svelte 5 $inspect Rune - Dense Reference\n\n**Dev-only reactive debugger. Re-runs on reactive state changes. Template literals MUST use backticks (`)**\n\n## Core Implementation\n```svelte\n<svelte:options runes={true} />\n<script>\n\tlet text = $state(\"Hello world\");\n\t$inspect(text); // Basic usage\n\t$inspect(text).with((type, value) => { // Custom logging\n\t\tif (type === \"update\") console.log(`Text updated to: \"${value}\"`);\n\t});\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // MUST be first statement\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\t});\n</script>\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n</div>\n```\n\n## Basic Usage\n\nThe simplest form of `$inspect` logs values to the console whenever they change:\n\n```svelte\n<script>\n\tlet count = $state(0);\n\tlet message = $state('hello');\n\n\t$inspect(count, message); // will console.log when `count` or `message` change\n</script>\n\n<button onclick={() => count++}>Increment</button>\n<input bind:value={message} />\n```\n\n## Text Input Example with Quotes\n\nWhen working with text inputs, you often want to display the value with quotes to show empty strings clearly:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// Basic $inspect usage\n\t$inspect(text);\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n\t<p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>\n```\n\nNote: Always wrap text values in quotes when displaying them in UI to make empty strings visible.\n\n## $inspect(...).with\n\n`$inspect` returns a property `with`, which you can invoke with a callback, which will then be invoked instead of `console.log`. The first argument to the callback is either `\"init\"` or `\"update\"`; subsequent arguments are the values passed to `$inspect`.\n\n### Custom Console Logging\n\n**MANDATORY SYNTAX**: Template literals MUST use backticks (`), not quotes:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\n\t// Custom callback for tracking text changes\n\t$inspect(text).with((type, value) => {\n\t\tif (type === \"update\") {\n\t\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t\t}\n\t});\n</script>\n\n<input bind:value={text} />\n```\n\n**CRITICAL**: Always use backticks (`) for template literals:\n- ‚úÖ `console.log(\\`Text updated to: \"${value}\"\\`);`\n- ‚ùå `console.log(Text updated to: \"${value}\");` ‚Üê Missing backticks causes syntax error\n\nThe callback receives:\n- `type`: Either `\"init\"` (first call) or `\"update\"` (subsequent changes)  \n- `value`: The current value being inspected\n\n### Debugging Example\n\n```svelte\n<script>\n\tlet count = $state(0);\n\n\t$inspect(count).with((type, count) => {\n\t\tif (type === 'update') {\n\t\t\tdebugger; // or `console.trace`, or whatever you want\n\t\t}\n\t});\n</script>\n\n<button onclick={() => count++}>Increment</button>\n```\n\nA convenient way to find the origin of some change is to pass `console.trace` to `with`:\n\n```js\n$inspect(stuff).with(console.trace);\n```\n\n## $inspect.trace(...)\n\nThis rune, added in 5.14, causes the surrounding function to be _traced_ in development. Any time the function re-runs as part of an effect or a derived, information will be printed to the console about which pieces of reactive state caused the effect to fire.\n\n**üö® CRITICAL PLACEMENT WARNING**: `$inspect.trace` MUST be the first statement of a function body. Placing it anywhere else will cause a compile error.\n\n### ‚ùå WRONG - $inspect.trace not in first position\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t$effect(() => {\n\t\tconsole.log('[$effect] Input text changed to:', text); // ‚ùå Statement before $inspect.trace\n\t\t$inspect.trace(); // ‚ùå WRONG POSITION - will cause compile error\n\t});\n</script>\n```\n\n**Error**: `$inspect.trace(...)` must be the first statement of a function body\n\n### ‚úÖ CORRECT - $inspect.trace as first statement\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // ‚úÖ CORRECT - First statement\n\t\tconsole.log(`[$effect] Input text changed to: \"${text}\"`);\n\t});\n</script>\n```\n\n### Basic Usage in Effects\n\n**MANDATORY**: Always place `$inspect.trace` as the very first line inside function bodies:\n\n```svelte\n<script>\n\timport { doSomeWork } from './elsewhere';\n\n\t$effect(() => {\n\t\t$inspect.trace(); // ‚úÖ Must be first statement\n\t\tdoSomeWork();\n\t});\n</script>\n```\n\n### Text Input Tracking with Effects\n\nFor text input tracking, combine `$inspect.trace` with effects to monitor changes:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// ‚úÖ CORRECT - $inspect.trace as first statement\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // ‚úÖ Optional label, MUST be first\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\t});\n</script>\n\n<input bind:value={text} />\n```\n\n**CRITICAL SYNTAX RULES:**\n1. ‚úÖ `$inspect.trace()` MUST be the very first statement inside `$effect(() => {`  \n2. ‚ùå NEVER put any other code before `$inspect.trace()`\n3. ‚úÖ Use template literals with backticks: `` console.log(`text: \"${text}\"`) ``\n4. ‚ùå NEVER omit backticks: `console.log(text: \"${text}\")` ‚Üê SYNTAX ERROR\n\n`$inspect.trace` takes an optional first argument which will be used as the label.\n\n## Complete Working Example\n\nHere's a complete example that demonstrates all `$inspect` features with proper formatting:\n\n```svelte\n<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// 1. Basic $inspect usage\n\t$inspect(text);\n\t\n\t// 2. Using $inspect(...).with for custom logging\n\t$inspect(text).with((type, value) => {\n\t\tif (type === \"update\") {\n\t\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t\t}\n\t});\n\t\n\t// 3. MANDATORY: $effect with $inspect.trace AND console.log\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // MUST be first\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`); // REQUIRED\n\t});\n</script>\n\n<div>\n\t<label for=\"text-input\">Edit text:</label>\n\t<input \n\t\tdata-testid=\"text-input\" \n\t\tid=\"text-input\" \n\t\ttype=\"text\" \n\t\tbind:value={text} \n\t/>\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n\t<p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>\n```\n\n## MANDATORY Patterns for Tests\n\n**$effect with $inspect MUST include console.log:**\n```js\n$effect(() => {\n\t$inspect.trace(\"text-changes\"); // Always first statement\n\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`); // REQUIRED format\n});\n```\n\n**$inspect.with MUST check update type:**\n```js\n$inspect(text).with((type, value) => {\n\tif (type === \"update\") { // REQUIRED check\n\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t}\n});\n```\n\n## Key Points for Testing\n\n- Always wrap displayed text values in quotes to show empty strings clearly\n- Use specific console.log message formats for predictable testing\n- Include proper `data-testid` attributes for test targeting\n- The `$inspect(...).with` callback should check for `type === \"update\"` to avoid init logs\n- Console messages should include the exact format: `Text updated to: \"${value}\"`\n- Effect logging should follow the pattern: `The text is now: \"${text}\" (${text.length} characters)`\n\n### Critical Syntax Reminders\n\n**Template Literals**: Always use backticks (`) for template literals, not regular quotes:\n```javascript\n// ‚úÖ CORRECT\nconsole.log(`Text updated to: \"${value}\"`);\nconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\n// ‚ùå WRONG - missing backticks\nconsole.log(Text updated to: \"${value}\");\nconsole.log(The text is now: \"${text}\" (${text.length} characters));\n```\n\n**Input Element**: Always include all required attributes:\n```html\n<!-- ‚úÖ CORRECT -->\n<input \n    data-testid=\"text-input\" \n    id=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n/>\n\n<!-- ‚ùå WRONG - incomplete -->\n<input \n```\n\n# Svelte 5 Props Reference\n\n## Basic Props\n```svelte\n<!-- Parent -->\n<MyComponent adjective=\"cool\" />\n\n<!-- Child -->\n<script>\n  let { adjective } = $props(); // destructured (recommended)\n  let props = $props(); // or access via props.adjective\n</script>\n```\n\n## Fallbacks & Renaming\n```js\nlet { adjective = 'happy' } = $props(); // fallback value\nlet { super: trouper = 'default' } = $props(); // rename invalid identifier\nlet { a, b, ...others } = $props(); // rest props\n```\n\nCall $props() exactly once ‚Äî destructure all props in a single call or use a single props object to avoid the `props_duplicate` compile error.\n\nMinimal correct pattern:\n```svelte\n// correct ‚Äî single $props() call\nlet props = $props(); let { name = \"World\", count = 0, showDetails = false } = props;\n```\n\n## Prop Mutation Rules - CRITICAL\n\n**Props are READ-ONLY. Never assign to props directly:**\n\n‚ùå **FORBIDDEN - Will cause compilation errors:**\n```js\nlet { text } = $props();\ntext = \"new value\"; // ‚ùå COMPILE ERROR - props are read-only\n```\n\n‚úÖ **CORRECT - Use local state for modifications:**\n```js\nlet { text } = $props();\nlet localText = $state(text); // Copy to local state\n// Now modify localText: localText = \"new value\"; ‚úÖ\n```\n\n**Rules:**\n- ‚ùå Direct assignment: `prop = value` causes compilation errors\n- ‚ùå Direct mutation: `prop.property = value` (unless `$bindable`) \n- ‚úÖ Local state: `let local = $state(prop)` then modify `local`\n- ‚úÖ Temporary reassignment: only for local scope override\n- Regular objects: mutations have no effect\n- Reactive proxies: mutations work but trigger warnings\n- Fallback values: not reactive, mutations ignored\n\n## Type Safety\n```svelte\n<script lang=\"ts\">\n  interface Props { adjective: string; }\n  let { adjective }: Props = $props();\n  \n  // Or inline\n  let { adjective }: { adjective: string } = $props();\n  \n  // JSDoc\n  /** @type {{ adjective: string }} */\n  let { adjective } = $props();\n</script>\n```\n\n## Unique IDs\n```svelte\n<script>\n  const uid = $props.id(); // unique per component instance\n</script>\n<label for=\"{uid}-input\">Label</label>\n<input id=\"{uid}-input\" />\n```\n\n## Key Points\n- Props update reactively when parent changes\n- Use callbacks or `$bindable` for child-to-parent communication\n- Fallback values aren't reactive proxies\n- Type annotations recommended for discoverability\n- DOM element interfaces in `svelte/elements`\n\n# Svelte 5 Snippets\n```svelte\n<svelte:options runes={true} />\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n<style></style>\n```\n\n## CRITICAL SYNTAX RULES\n- ‚ùå NEVER use `return` keyword or JSX syntax `<span>`\n- ‚úÖ ALWAYS use pure Svelte template syntax: `{#snippet name(params)}...{/snippet}`\n- ‚ùå NOT: `const title = snippet((param) => { return <span>{param}</span>; })`\n- ‚úÖ CORRECT: `{#snippet title(param)}<span>{param}</span>{/snippet}`\n\n## Basic Syntax\n```svelte\n{#snippet name()}...{/snippet}\n{#snippet name(param1, param2)}...{/snippet}\n{@render name(args)}\n```\n\n## Working Example\n```svelte\n<svelte:options runes={true} />\n<script>\n\tconst items = [\"item1\", \"item2\"];\n</script>\n{#snippet title(text)}\n\t<span data-testid=\"title\">{text}</span>\n{/snippet}\n<ul>\n\t{#each items as item}\n\t\t<li>{@render title(item)}</li>\n\t{/each}\n</ul>\n```\n\n## Scope & Parameters\n- Snippets access lexical scope variables\n- Support default values & destructuring: `{#snippet name(param = default)}`\n- Can reference themselves (recursion) and siblings\n- No rest parameters support\n\n## Component Props\n**Explicit:** `<Table {header} {row} />`\n**Implicit:** Content inside component becomes props automatically\n**Children:** Non-snippet content becomes `children` snippet\n\n```svelte\n<!-- Implicit children -->\n<Button>click me</Button>\n\n<!-- Button.svelte -->\n<script>let { children } = $props();</script>\n<button>{@render children()}</button>\n\n<!-- Optional snippets -->\n{@render children?.()}\n{#if children}{@render children()}{:else}fallback{/if}\n```\n\n## TypeScript\n```svelte\n<script lang=\"ts\">\n\timport type { Snippet } from 'svelte';\n\tinterface Props {\n\t\tchildren: Snippet;\n\t\trow: Snippet<[DataType]>;\n\t}\n\tlet { children, row }: Props = $props();\n</script>\n```\n\n## Export (Svelte 5.5.0+)\n```svelte\n<script module>export { add };</script>\n{#snippet add(a, b)}{a} + {b} = {a + b}{/snippet}\n```\n\n## Key Facts\n- Replace Svelte 4 slots with more power/flexibility\n- Template constructs, not JS functions\n- Avoid props named `children` with implicit children\n- Use `createRawSnippet` API for advanced cases"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n<script>\n\tlet count = $state(0);\n\tlet doubled = $derived(count * 2);\n\tconst increment = () => count++;\n</script>\n<div>\n\t<p data-testid=\"count-value\">Count: {count}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": false,
        "errors": [
          "Unable to find an element by: [data-testid=\"number-value\"]\n\nIgnored nodes: comments, script, style\n\u001b[36m<body>\u001b[39m\n  \u001b[36m<div>\u001b[39m\n    \u001b[36m<div>\u001b[39m\n      \u001b[36m<p\u001b[39m\n        \u001b[33mdata-testid\u001b[39m=\u001b[32m\"count-value\"\u001b[39m\n      \u001b[36m>\u001b[39m\n        \u001b[0mCount: 0\u001b[0m\n      \u001b[36m</p>\u001b[39m\n      \u001b[0m \u001b[0m\n      \u001b[36m<p\u001b[39m\n        \u001b[33mdata-testid\u001b[39m=\u001b[32m\"doubled-value\"\u001b[39m\n      \u001b[36m>\u001b[39m\n        \u001b[0mDoubled: 0\u001b[0m\n      \u001b[36m</p>\u001b[39m\n      \u001b[0m \u001b[0m\n      \u001b[36m<button\u001b[39m\n        \u001b[33mdata-testid\u001b[39m=\u001b[32m\"increment-button\"\u001b[39m\n      \u001b[36m>\u001b[39m\n        \u001b[0mIncrement\u001b[0m\n      \u001b[36m</button>\u001b[39m\n    \u001b[36m</div>\u001b[39m\n    \u001b[0m\u001b[0m\n  \u001b[36m</div>\u001b[39m\n\u001b[36m</body>\u001b[39m",
          "Unable to find an element by: [data-testid=\"number-value\"]\n\nIgnored nodes: comments, script, style\n\u001b[36m<body>\u001b[39m\n  \u001b[36m<div>\u001b[39m\n    \u001b[36m<div>\u001b[39m\n      \u001b[36m<p\u001b[39m\n        \u001b[33mdata-testid\u001b[39m=\u001b[32m\"count-value\"\u001b[39m\n      \u001b[36m>\u001b[39m\n        \u001b[0mCount: 1\u001b[0m\n      \u001b[36m</p>\u001b[39m\n      \u001b[0m \u001b[0m\n      \u001b[36m<p\u001b[39m\n        \u001b[33mdata-testid\u001b[39m=\u001b[32m\"doubled-value\"\u001b[39m\n      \u001b[36m>\u001b[39m\n        \u001b[0mDoubled: 2\u001b[0m\n      \u001b[36m</p>\u001b[39m\n      \u001b[0m \u001b[0m\n      \u001b[36m<button\u001b[39m\n        \u001b[33mdata-testid\u001b[39m=\u001b[32m\"increment-button\"\u001b[39m\n      \u001b[36m>\u001b[39m\n        \u001b[0mIncrement\u001b[0m\n      \u001b[36m</button>\u001b[39m\n    \u001b[36m</div>\u001b[39m\n    \u001b[0m\u001b[0m\n  \u001b[36m</div>\u001b[39m\n\u001b[36m</body>\u001b[39m"
        ],
        "temperature": 0
      }
    ]
  },
  {
    "testName": "derived-by",
    "provider": "LMStudio",
    "modelId": "unsloth/Qwen3-Coder-30B-A3B-Instruct-GGUF",
    "numSamples": 1,
    "numCorrect": 1,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "# Svelte 5 Anti-Patterns\n\n## ‚ùå CRITICAL: Missing Content\n\n- **Do NOT generate empty components!** Always include the actual content requested\n- For \"Hello World\" tasks: MUST display \"Hello, World!\" text, not just structure\n- Template structure alone is insufficient - include the actual requirements\n\n## Event Handling\n\n- Do not use `on:click`, `on:submit`, or other Svelte 4-style event directives in Svelte 5. Use standard HTML event attributes like `onclick`, `onsubmit`, etc. instead.\n\n## Legacy Practices\n\n- Do not rely on implicit reactivity from Svelte 4 (`let` declarations, `$:` statements`).\n- Use modern Svelte 5 APIs instead of legacy APIs (e.g., prefer callback props over `createEventDispatcher`).\n\n## Build Tools\n\n- Use SvelteKit for new projects; do not opt for plain Vite, Rollup, or Webpack plugins.\n  - **Note:** SvelteKit is strongly recommended and centralizes best practices.\n\n## Runes Misuse\n\n### General\n\n- Do not use runes from Svelte 4 and prior (will cause compilation errors).\n- Do not import runes, they are part of the language\n\n### `$state`\n\n- Do not directly mutate `$state.raw` values (will not trigger reactive updates).\n- Do not directly export reassigned `$state` variables from `.svelte.js`/`.svelte.ts` modules (leads to non-reactive behavior for imports).\n- Do not mutate state you do not \"own\" (i.e., only mutate props marked `$bindable`).\n- For large collections, prefer using `$state.raw` for better performance, and always reassign the collection when making changes.\n- When updating state objects, avoid direct mutation of nested properties; instead, create new objects to ensure predictable state changes.\n\n### `$derived`\n\n- Do not change state (e.g., `count++`) directly within `$derived` expressions.\n- Avoid creating circular dependencies between derived values and state, as this can lead to infinite update loops.\n\n### State Management Patterns\n\n- Do not export state variables directly; instead, provide getter and setter functions to access and update state, preserving reactivity.\n- When exporting objects containing state, use getters and setters for stateful properties to maintain reactivity in consuming modules.\n\n### `$effect`\n\n- Do not update state directly within `$effect` functions (can lead to convoluted code and infinite loops).\n- Do not use `$effect` to synchronize state or derive new `$state` variables; use `$derived` for derivations.\n- Do not link mutually dependent input values using `$effect`; use `oninput` callbacks or function bindings instead.\n- Do not assume values read asynchronously (e.g., after `await` or in `setTimeout`) within an `$effect` are tracked as dependencies.\n- Do not expect an `$effect` to re-run when a property inside a mutated object changes if the object reference itself remains the same.\n\n## Component Communication\n\n- Do not directly mutate props unless they are explicitly declared as `$bindable()`.\n- Do not mutate a reactive state proxy passed as a prop in a child component (triggers `ownership_invalid_mutation` warning).\n- Do not mutate fallback values of non-bindable props (will not trigger updates).\n- Do not provide `undefined` to a `$bindable()` property that has a fallback value and is bound (results in a runtime error).\n\n### Common Props Mistakes (Svelte 5)\n\n- Always destructure needed props from `$props()` for reactivity; do not use the whole props object.\n- Always provide default values for optional props when destructuring.\n- Use `$bindable()` for two-way binding props.\n- Do not modify props directly; use callbacks to update parent state.\n- Use TypeScript types for complex props.\n\n## Debugging\n\n- Do not leave `$inspect` calls in production code (clutters code, even if they become no-ops).\n- Do not overuse `$inspect` (leads to overwhelming console output).\n- Do not use `$inspect` as a substitute for well-structured state management.\n\n## Reusable Reactive Logic\n\n- Do not export reassigned state directly from `.svelte.js`/`.svelte.ts` files (results in non-reactive behavior for external imports).\n\n## `bind:` Directive\n\n- Do not use reset buttons in forms too frequently (can lead to accidental data loss ‚Äî more of a UX warning).\n- Do not expect `DataTransfer` to be available for `bind:files` in server-side JavaScript runtimes (state should be left uninitialized for SSR).\n- Do not use dimension bindings (`bind:offsetWidth`, etc.) on elements with `display: inline` (their dimensions are not observable; change display style).\n- Do not expect dimension bindings to update if an element's size changes solely due to CSS transformations.\n- Do not use the `bind:group` directive across different components (only works for inputs within the same Svelte component).\n- Do not provide `undefined` to a bound `$bindable()` property that has a fallback value (results in a runtime error).\n\n## Asynchronous Operations (`{#await...}`)\n\n- Do not expect any branch other than the pending branch of an `{#await}` block to render during server-side rendering (SSR).\n\n## Keyed Blocks (`{#key...}`)\n\n- Do not use a constantly changing key value in `{#key}` blocks (leads to excessive DOM manipulation and potential performance degradation).\n\n## Attributes\n\n- Do not declare custom √üproperties or attributes that start with `on`.\n\n\n# Svelte 5 Best Practices\n\n## üöÄ Essential Setup & Syntax\n\n### Component Structure\n- **MANDATORY**: Always start with `<svelte:options runes={true} />` at the top\n- Use `<script>` for component-specific logic\n- Use `<style>` for scoped CSS\n- Maintain clear data flow and effective architecture for maintainability\n\n- When a task requires exact output (e.g., Hello-World) render the literal text `Hello, World!` inside an element with `data-testid=\"greeting\"` (no comments or computed empty strings).\n\n### Event Handling - CRITICAL CHANGE FROM SVELTE 4\n- ‚úÖ Use standard HTML attributes for event handling (`onclick`, `onsubmit`, etc.)\n- ‚ùå Do NOT use Svelte 4 syntax: `on:click`, `on:submit` will cause errors\n- For event modifiers, use wrapper functions instead of the pipe syntax from Svelte 4\n- For multiple handlers, combine them into a single function\n- Keep event handlers simple, moving complex logic to separate functions\n- Remember that event names are lowercase in HTML (`onclick`, not `onClick`)\n\n### Template Syntax Basics\n- Use `{#if expression}` for conditionals\n- Use `{#each expression as item}` for lists\n- Use `{#key value}` to force re-creation of content\n- Use `{#await promise}` for managing Promise states\n- Use `{variable}` for displaying values\n- Use snippets for reusable markup chunks\n\n## üß† Runes\n\n### `$state` - Reactive Variables\n\n- ‚úÖ Use `$state` for reactive UI state: `let count = $state(0)`\n- ‚úÖ Update `$state` variables directly (they behave like regular JavaScript variables)\n- ‚ùå NEVER import runes: `import { $state } from 'svelte'` causes parse errors\n- Use arrow functions for class methods relying on `this` with reactive state\n- Use `$state.raw` for large arrays/objects where deep reactivity isn't needed\n- Use `$state.snapshot` to get a non-reactive copy of state for external libraries\n- Pass getter functions (e.g., `() => a`) to functions needing the current reactive value of `$state` variables\n- When sharing `$state` from `.svelte.js`/`.svelte.ts` files:\n  - Export an object whose properties are mutated\n  - Or export getter functions\n\n### `$derived` - Computed Values\n\n- ‚úÖ Use `$derived` for computed values that are free of side effects: `let doubled = $derived(count * 2)`\n- ‚ùå NEVER import: `import { $derived } from 'svelte'` causes parse errors\n- Use `$derived.by` for complex derivation logic\n- Derived values can be temporarily reassigned for optimistic UI updates\n\n### `$effect` - Side Effects\n\n- ‚úÖ Use `$effect` for side effects and external interactions (e.g., third-party libraries, API calls, analytics, DOM manipulation)\n- ‚ùå NEVER import: `import { $effect } from 'svelte'` causes parse errors\n- Return a teardown function from `$effect` for cleanup (e.g., clearing intervals)\n- Use `$effect.pre` for logic that must run before DOM updates\n- Use `$effect.tracking` to check if code is running in a tracking context\n- Use `$effect.root` for creating non-tracked scopes with manual cleanup for nested effects\n- ‚ùå Do not update state inside effects - use `$derived` for derivations instead\n\n## üîÑ Component Communication & Props\n\n- **CRITICAL**: Props are READ-ONLY. Never assign directly to props\n- Destructure props directly from `$props()` for clarity: `let { name } = $props()`\n- Declare fallback values during destructuring: `let { name = \"default\" } = $props()`\n- Rename props during destructuring if they are invalid JavaScript identifiers\n- Use rest properties (`...others`) to capture remaining props\n- Add type safety using TypeScript interfaces or JSDoc\n- Use `$props.id()` (Svelte 5.20.0+) for unique, consistent component instance IDs\n- Use callback properties for child-to-parent communication (replaces `createEventDispatcher`)\n\n## üîó `bind:` Directive (Two-Way Data Binding)\n\n- Use `bind:` for two-way data flow from child to parent\n- Use shorthand `bind:property` when names match\n- Use function bindings (get/set) for validation or transformation (Svelte 5.9.0+)\n- For readonly bindings, set the get function to `null`\n- Access `bind:this` variables inside `$effect` or event handlers (they are undefined until mount)\n- Mark bindable properties with `$bindable()`\n- Provide fallback values for `$bindable()` properties\n\n## üêû Debugging (`$inspect`)\n\n- Use `$inspect` exclusively for development debugging; it tracks reactive state deeply.\n- Use `$inspect.with()` for custom debugging actions (e.g., `debugger`, `console.trace`).\n- Use `$inspect.trace()` (Svelte 5.14+) to trace function re-runs and identify causes.\n\n## ‚ôªÔ∏è Reusable Logic & State\n\n- Use `.svelte.js` and `.svelte.ts` files to create reusable reactive logic and share reactive state using runes.\n- Keep state logic separate from the wire components.\n\n## üß± Component Structure\n\n- Use `<script>` for component-specific logic.\n- Use `<style>` for scoped CSS.\n- Maintain clear data flow and effective architecture for maintainability.\n\n## üîó `bind:` Directive (Two-Way Data Binding)\n\n- Use `bind:` for two-way data flow from child to parent.\n- Use shorthand `bind:property` when names match.\n- Use function bindings (get/set) for validation or transformation (Svelte 5.9.0+).\n- For readonly bindings, set the get function to `null`.\n- Access `bind:this` variables inside `$effect` or event handlers (they are undefined until mount).\n- Mark bindable properties with `$bindable()`.\n- Provide fallback values for `$bindable()` properties.\n\n## üß© Template Syntax\n\n- Use `{#if expression}` for conditionals.\n- Use `{#each expression as item}` for lists.\n- Use `{#key value}` to force re-creation of content.\n- Use `{#await promise}` for managing Promise states.\n- Use snippets for reusable markup chunks.\n\n## üéâ Event Handling\n\n- Use standard HTML attributes for event handling (onclick, onsubmit, etc.)\n- For event modifiers, use wrapper functions instead of the pipe syntax from Svelte 4\n- For multiple handlers, combine them into a single function\n- Keep event handlers simple, moving complex logic to separate functions\n- Remember that event names are lowercase in HTML (onclick, not onClick)Event Handing\n\n## Component Events\n\n- Use callback props instead of event dispatching for component communication\n- Name callback props with an \"on\" prefix (e.g., onSubmit, onChange)\n- Pass data as an object to allow for future extensibility\n- For multiple events, use multiple callback props\n- Consider using TypeScript to type your callback props\n\n## Snippets\n\n- Use snippets to reduce duplication in your templates\n- Snippets can be passed as props to components\n- Snippets have lexical scoping rules - they are only visible in the same scope they are defined in\n- Use parameters to make snippets more flexible\n- Snippets can reference other snippets and even themselves (for recursion)\n\n## üè™ Store\n\n- Use stores only for:\n  - Interoperability with external libraries.\n  - Complex async data streams.\n  - Large apps.\n  - Scenarios needing explicit subscribe/unsubscribe behavior.\n\n## üß† Context\n\n- Store reactive state in context for child component access.\n- Wrap `setContext` and `getContext` in helper functions for type safety.\n- Context can and should be used for small to medium-sized applications to share state between components. It is also ideal for shared state, especially in SSR, as it avoids cross-request data leakage.\n\n## üß† Context\n\n- Store reactive state in context for child component access.\n- Wrap `setContext` and `getContext` in helper functions for type safety.\n- Context is ideal for shared state, especially in SSR, as it avoids cross-request data leakage.\n\n## üß™ Testing\n\n- Use **Vitest** for unit and integration testing.\n- Adjust `vite.config.js` to use browser entry points or alias backend libraries.\n- Include `.svelte` in test filenames for rune processing.\n- Wrap `$effects` in `$effect.root` during tests.\n- Use `flushSync` to run pending effects synchronously.\n- Use https://testing-library.com/docs/svelte-testing-library/intro.\n- Use **Playwright** for E2E testing.\n\n## üì¶ Packages\n\n- Explore new/popular packages at https://www.sveltesociety.dev/packages.\n\n## üîê Security\n\n- To prevent XSS attacks:\n  - Escape strings passed to `{@html ...}`.\n  - Ensure content is from trusted sources.\n  - The expression must be valid standalone HTML.\n\n## üß± Error Boundaries\n\n- Use `onerror` to integrate with error reporting services.\n- Wrap flaky components in `<svelte:boundary>` to isolate errors.\n- `<svelte:boundary>` requires a failed snippet or `onerror` function.\n- It does **not** catch errors outside rendering (e.g., event handlers, `setTimeout`, async work).\n\n\n# Svelte 5 $derived - LLM Context Guide\n\n**CRITICAL: $derived is built-in - NO imports needed. Importing causes parse errors.**\n\n## Syntax Rules\n- ‚úÖ `let x = $derived(expr)` - simple expressions  \n- ‚úÖ `let x = $derived.by(() => {...})` - complex logic\n- ‚úÖ `onclick={handler}` - NOT `on:click`\n- ‚úÖ `<svelte:options runes={true} />`\n- ‚ùå NEVER `import { $derived } from 'svelte/runes'`\n\n## Verified Working Template\n```svelte\n<svelte:options runes={true} />\n<script>\n\tlet count = $state(0);\n\tlet doubled = $derived(count * 2);\n\tconst increment = () => count++;\n</script>\n<div>\n\t<p data-testid=\"count-value\">Count: {count}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>\n```\n\n## $derived.by Example\n```svelte\n<script>\n\tlet items = $state([1, 2, 3]);\n\tlet sum = $derived.by(() => items.reduce((a, b) => a + b, 0));\n\t\n\t// ‚ùå INVALID - Cannot destructure $derived.by() return\n\t// const { wordCount, charCount } = $derived.by(() => ({ ... }));\n\t\n\t// ‚úÖ CORRECT - Store return value first\n\tlet stats = $derived.by(() => {\n\t\tconst words = text.split(' ').length;\n\t\tconst chars = text.length;\n\t\treturn { wordCount: words, charCount: chars, isLong: chars > 50 };\n\t});\n\t// Then access: stats.wordCount, stats.charCount, stats.isLong\n</script>\n```\n\n## Key Behaviors\n- Auto-updates when dependencies change\n- Pure expressions only (no mutations)\n- Push-pull: dependencies notify, values calculate on read\n- Can destructure: `let { a, b } = $derived(obj())` - ONLY simple $derived\n- **CRITICAL**: Cannot destructure `$derived.by()` - store return value first\n- Overridable since 5.25+\n\n# Svelte 5 Each Blocks\n\nIterate over arrays, array-like objects, or iterables (Map, Set) using `{#each}` blocks. Supports destructuring and optional keys for efficient DOM updates.\n\n## Basic Syntax\n\n```svelte\n{#each expression as name}...{/each}\n{#each expression as name, index}...{/each}\n```\n\n```svelte\n<ul>\n\t{#each items as item}\n\t\t<li>{item.name} x {item.qty}</li>\n\t{/each}\n</ul>\n```\n\n## Keyed Each Blocks\n\nUse unique keys to optimize DOM updates when data changes:\n\n```svelte\n{#each expression as name (key)}...{/each}\n```\n\n```svelte\n{#each items as item (item.id)}\n\t<li>{item.name} x {item.qty}</li>\n{/each}\n```\n\nKeys should be strings or numbers for identity persistence.\n\n## Destructuring\n\n```svelte\n{#each items as { id, name, qty }, i (id)}\n\t<li>{i + 1}: {name} x {qty}</li>\n{/each}\n```\n\n## Rendering N Times\n\n```svelte\n{#each { length: 8 }, index}\n\t<div>Item {index}</div>\n{/each}\n```\n\n## Else Clause\n\n```svelte\n{#each todos as todo}\n\t<p>{todo.text}</p>\n{:else}\n\t<p>No tasks today!</p>\n{/each}\n\n# Svelte 5 ‚Äî $effect (compressed)\n\nPurpose: browser-only rune for side effects after mount and after state updates. Do not use for derived state.\n\nCritical rules\n- Runes are built-in; DO NOT import `$state`, `$effect`, etc. (e.g. `import { $effect } from 'svelte/runes'` causes parse errors ‚Äî \"The $ prefix is reserved\").\n- Enable runes with `<svelte:options runes={true} />`.\n- Use `onclick={handler}` (Svelte 5), not `on:click={...}`.\n\nBehavior\n- Runs after component mount and in a microtask after state changes.\n- Dependencies: automatically tracked ‚Äî any `$state`, `$derived`, `$props` read synchronously inside the effect become dependencies.\n- Conditional reads are tracked only when executed (dependency set is recalculated each run).\n- Return a teardown function to cleanup; teardown runs before re-run and on destroy.\n\nSpecial variants\n- `$effect.pre(fn)`: runs before DOM update (useful for measuring DOM & scheduling `tick()`).\n- `$effect.root(fn)`: create a non-tracked scope that doesn't auto-cleanup; returns a `destroy()` to call manually.\n\nWhen to use\n- DOM manipulation (canvas), third-party libs, event listeners, timers, network requests.\n\nWhen NOT to use\n- State synchronization. Use `$derived(...)` for derived/computed state.\n\nCanonical minimal snippets (copy-paste safe)\n\nEnable runes:\n<svelte:options runes={true} />\n\nBasic effect (derived incorrectly shown only for demonstration ‚Äî prefer `$derived` in real code):\n```svelte\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n```\n\nCleanup (interval):\n```svelte\n<script>\n  let count = $state(0);\n  let milliseconds = $state(1000);\n\n  $effect(() => {\n    const interval = setInterval(() => count += 1, milliseconds);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\nPre-effect (before DOM update):\n```svelte\n<script>\n  import { tick } from 'svelte';\n  let div = $state();\n  let messages = $state([]);\n\n  $effect.pre(() => {\n    if (!div) return;\n    messages.length; // track\n    if (div.offsetHeight + div.scrollTop > div.scrollHeight - 20) {\n      tick().then(() => div.scrollTo(0, div.scrollHeight));\n    }\n  });\n</script>\n```\n\nroot scope:\n```js\nconst destroy = $effect.root(() => {\n  $effect(() => { /* setup */ });\n  return () => { /* cleanup */ };\n});\n// later: destroy();\n```\n\nEdge cases / pitfalls\n- Invalid imports break parsing ‚Äî never import `$` runes.\n- Mutating an object vs reassigning: read specific properties to track them (mutating top-level object may not retrigger effects that only read the object reference).\n- Conditional reads: a value read only inside an `if` is only a dependency when that branch executed.\n- Use `$effect.pre` when you must measure DOM before updates.\n- `$effect.root` requires manual cleanup (not auto-cleaned).\n\nTesting & best-practices\n- Include `data-testid` in examples for tests.\n- Prefer `$derived` for computed values; `$effect` only for side effects.\n\nOne-line summary: `$effect` = built-in Svelte 5 side-effect rune; no imports; auto-deps; return teardown for cleanup; use `$derived` for pure derived state.\n\n# Svelte 5 $inspect Rune - Dense Reference\n\n**Dev-only reactive debugger. Re-runs on reactive state changes. Template literals MUST use backticks (`)**\n\n## Core Implementation\n```svelte\n<svelte:options runes={true} />\n<script>\n\tlet text = $state(\"Hello world\");\n\t$inspect(text); // Basic usage\n\t$inspect(text).with((type, value) => { // Custom logging\n\t\tif (type === \"update\") console.log(`Text updated to: \"${value}\"`);\n\t});\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // MUST be first statement\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\t});\n</script>\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n</div>\n```\n\n## Basic Usage\n\nThe simplest form of `$inspect` logs values to the console whenever they change:\n\n```svelte\n<script>\n\tlet count = $state(0);\n\tlet message = $state('hello');\n\n\t$inspect(count, message); // will console.log when `count` or `message` change\n</script>\n\n<button onclick={() => count++}>Increment</button>\n<input bind:value={message} />\n```\n\n## Text Input Example with Quotes\n\nWhen working with text inputs, you often want to display the value with quotes to show empty strings clearly:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// Basic $inspect usage\n\t$inspect(text);\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n\t<p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>\n```\n\nNote: Always wrap text values in quotes when displaying them in UI to make empty strings visible.\n\n## $inspect(...).with\n\n`$inspect` returns a property `with`, which you can invoke with a callback, which will then be invoked instead of `console.log`. The first argument to the callback is either `\"init\"` or `\"update\"`; subsequent arguments are the values passed to `$inspect`.\n\n### Custom Console Logging\n\n**MANDATORY SYNTAX**: Template literals MUST use backticks (`), not quotes:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\n\t// Custom callback for tracking text changes\n\t$inspect(text).with((type, value) => {\n\t\tif (type === \"update\") {\n\t\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t\t}\n\t});\n</script>\n\n<input bind:value={text} />\n```\n\n**CRITICAL**: Always use backticks (`) for template literals:\n- ‚úÖ `console.log(\\`Text updated to: \"${value}\"\\`);`\n- ‚ùå `console.log(Text updated to: \"${value}\");` ‚Üê Missing backticks causes syntax error\n\nThe callback receives:\n- `type`: Either `\"init\"` (first call) or `\"update\"` (subsequent changes)  \n- `value`: The current value being inspected\n\n### Debugging Example\n\n```svelte\n<script>\n\tlet count = $state(0);\n\n\t$inspect(count).with((type, count) => {\n\t\tif (type === 'update') {\n\t\t\tdebugger; // or `console.trace`, or whatever you want\n\t\t}\n\t});\n</script>\n\n<button onclick={() => count++}>Increment</button>\n```\n\nA convenient way to find the origin of some change is to pass `console.trace` to `with`:\n\n```js\n$inspect(stuff).with(console.trace);\n```\n\n## $inspect.trace(...)\n\nThis rune, added in 5.14, causes the surrounding function to be _traced_ in development. Any time the function re-runs as part of an effect or a derived, information will be printed to the console about which pieces of reactive state caused the effect to fire.\n\n**üö® CRITICAL PLACEMENT WARNING**: `$inspect.trace` MUST be the first statement of a function body. Placing it anywhere else will cause a compile error.\n\n### ‚ùå WRONG - $inspect.trace not in first position\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t$effect(() => {\n\t\tconsole.log('[$effect] Input text changed to:', text); // ‚ùå Statement before $inspect.trace\n\t\t$inspect.trace(); // ‚ùå WRONG POSITION - will cause compile error\n\t});\n</script>\n```\n\n**Error**: `$inspect.trace(...)` must be the first statement of a function body\n\n### ‚úÖ CORRECT - $inspect.trace as first statement\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // ‚úÖ CORRECT - First statement\n\t\tconsole.log(`[$effect] Input text changed to: \"${text}\"`);\n\t});\n</script>\n```\n\n### Basic Usage in Effects\n\n**MANDATORY**: Always place `$inspect.trace` as the very first line inside function bodies:\n\n```svelte\n<script>\n\timport { doSomeWork } from './elsewhere';\n\n\t$effect(() => {\n\t\t$inspect.trace(); // ‚úÖ Must be first statement\n\t\tdoSomeWork();\n\t});\n</script>\n```\n\n### Text Input Tracking with Effects\n\nFor text input tracking, combine `$inspect.trace` with effects to monitor changes:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// ‚úÖ CORRECT - $inspect.trace as first statement\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // ‚úÖ Optional label, MUST be first\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\t});\n</script>\n\n<input bind:value={text} />\n```\n\n**CRITICAL SYNTAX RULES:**\n1. ‚úÖ `$inspect.trace()` MUST be the very first statement inside `$effect(() => {`  \n2. ‚ùå NEVER put any other code before `$inspect.trace()`\n3. ‚úÖ Use template literals with backticks: `` console.log(`text: \"${text}\"`) ``\n4. ‚ùå NEVER omit backticks: `console.log(text: \"${text}\")` ‚Üê SYNTAX ERROR\n\n`$inspect.trace` takes an optional first argument which will be used as the label.\n\n## Complete Working Example\n\nHere's a complete example that demonstrates all `$inspect` features with proper formatting:\n\n```svelte\n<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// 1. Basic $inspect usage\n\t$inspect(text);\n\t\n\t// 2. Using $inspect(...).with for custom logging\n\t$inspect(text).with((type, value) => {\n\t\tif (type === \"update\") {\n\t\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t\t}\n\t});\n\t\n\t// 3. MANDATORY: $effect with $inspect.trace AND console.log\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // MUST be first\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`); // REQUIRED\n\t});\n</script>\n\n<div>\n\t<label for=\"text-input\">Edit text:</label>\n\t<input \n\t\tdata-testid=\"text-input\" \n\t\tid=\"text-input\" \n\t\ttype=\"text\" \n\t\tbind:value={text} \n\t/>\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n\t<p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>\n```\n\n## MANDATORY Patterns for Tests\n\n**$effect with $inspect MUST include console.log:**\n```js\n$effect(() => {\n\t$inspect.trace(\"text-changes\"); // Always first statement\n\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`); // REQUIRED format\n});\n```\n\n**$inspect.with MUST check update type:**\n```js\n$inspect(text).with((type, value) => {\n\tif (type === \"update\") { // REQUIRED check\n\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t}\n});\n```\n\n## Key Points for Testing\n\n- Always wrap displayed text values in quotes to show empty strings clearly\n- Use specific console.log message formats for predictable testing\n- Include proper `data-testid` attributes for test targeting\n- The `$inspect(...).with` callback should check for `type === \"update\"` to avoid init logs\n- Console messages should include the exact format: `Text updated to: \"${value}\"`\n- Effect logging should follow the pattern: `The text is now: \"${text}\" (${text.length} characters)`\n\n### Critical Syntax Reminders\n\n**Template Literals**: Always use backticks (`) for template literals, not regular quotes:\n```javascript\n// ‚úÖ CORRECT\nconsole.log(`Text updated to: \"${value}\"`);\nconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\n// ‚ùå WRONG - missing backticks\nconsole.log(Text updated to: \"${value}\");\nconsole.log(The text is now: \"${text}\" (${text.length} characters));\n```\n\n**Input Element**: Always include all required attributes:\n```html\n<!-- ‚úÖ CORRECT -->\n<input \n    data-testid=\"text-input\" \n    id=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n/>\n\n<!-- ‚ùå WRONG - incomplete -->\n<input \n```\n\n# Svelte 5 Props Reference\n\n## Basic Props\n```svelte\n<!-- Parent -->\n<MyComponent adjective=\"cool\" />\n\n<!-- Child -->\n<script>\n  let { adjective } = $props(); // destructured (recommended)\n  let props = $props(); // or access via props.adjective\n</script>\n```\n\n## Fallbacks & Renaming\n```js\nlet { adjective = 'happy' } = $props(); // fallback value\nlet { super: trouper = 'default' } = $props(); // rename invalid identifier\nlet { a, b, ...others } = $props(); // rest props\n```\n\nCall $props() exactly once ‚Äî destructure all props in a single call or use a single props object to avoid the `props_duplicate` compile error.\n\nMinimal correct pattern:\n```svelte\n// correct ‚Äî single $props() call\nlet props = $props(); let { name = \"World\", count = 0, showDetails = false } = props;\n```\n\n## Prop Mutation Rules - CRITICAL\n\n**Props are READ-ONLY. Never assign to props directly:**\n\n‚ùå **FORBIDDEN - Will cause compilation errors:**\n```js\nlet { text } = $props();\ntext = \"new value\"; // ‚ùå COMPILE ERROR - props are read-only\n```\n\n‚úÖ **CORRECT - Use local state for modifications:**\n```js\nlet { text } = $props();\nlet localText = $state(text); // Copy to local state\n// Now modify localText: localText = \"new value\"; ‚úÖ\n```\n\n**Rules:**\n- ‚ùå Direct assignment: `prop = value` causes compilation errors\n- ‚ùå Direct mutation: `prop.property = value` (unless `$bindable`) \n- ‚úÖ Local state: `let local = $state(prop)` then modify `local`\n- ‚úÖ Temporary reassignment: only for local scope override\n- Regular objects: mutations have no effect\n- Reactive proxies: mutations work but trigger warnings\n- Fallback values: not reactive, mutations ignored\n\n## Type Safety\n```svelte\n<script lang=\"ts\">\n  interface Props { adjective: string; }\n  let { adjective }: Props = $props();\n  \n  // Or inline\n  let { adjective }: { adjective: string } = $props();\n  \n  // JSDoc\n  /** @type {{ adjective: string }} */\n  let { adjective } = $props();\n</script>\n```\n\n## Unique IDs\n```svelte\n<script>\n  const uid = $props.id(); // unique per component instance\n</script>\n<label for=\"{uid}-input\">Label</label>\n<input id=\"{uid}-input\" />\n```\n\n## Key Points\n- Props update reactively when parent changes\n- Use callbacks or `$bindable` for child-to-parent communication\n- Fallback values aren't reactive proxies\n- Type annotations recommended for discoverability\n- DOM element interfaces in `svelte/elements`\n\n# Svelte 5 Snippets\n```svelte\n<svelte:options runes={true} />\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n<style></style>\n```\n\n## CRITICAL SYNTAX RULES\n- ‚ùå NEVER use `return` keyword or JSX syntax `<span>`\n- ‚úÖ ALWAYS use pure Svelte template syntax: `{#snippet name(params)}...{/snippet}`\n- ‚ùå NOT: `const title = snippet((param) => { return <span>{param}</span>; })`\n- ‚úÖ CORRECT: `{#snippet title(param)}<span>{param}</span>{/snippet}`\n\n## Basic Syntax\n```svelte\n{#snippet name()}...{/snippet}\n{#snippet name(param1, param2)}...{/snippet}\n{@render name(args)}\n```\n\n## Working Example\n```svelte\n<svelte:options runes={true} />\n<script>\n\tconst items = [\"item1\", \"item2\"];\n</script>\n{#snippet title(text)}\n\t<span data-testid=\"title\">{text}</span>\n{/snippet}\n<ul>\n\t{#each items as item}\n\t\t<li>{@render title(item)}</li>\n\t{/each}\n</ul>\n```\n\n## Scope & Parameters\n- Snippets access lexical scope variables\n- Support default values & destructuring: `{#snippet name(param = default)}`\n- Can reference themselves (recursion) and siblings\n- No rest parameters support\n\n## Component Props\n**Explicit:** `<Table {header} {row} />`\n**Implicit:** Content inside component becomes props automatically\n**Children:** Non-snippet content becomes `children` snippet\n\n```svelte\n<!-- Implicit children -->\n<Button>click me</Button>\n\n<!-- Button.svelte -->\n<script>let { children } = $props();</script>\n<button>{@render children()}</button>\n\n<!-- Optional snippets -->\n{@render children?.()}\n{#if children}{@render children()}{:else}fallback{/if}\n```\n\n## TypeScript\n```svelte\n<script lang=\"ts\">\n\timport type { Snippet } from 'svelte';\n\tinterface Props {\n\t\tchildren: Snippet;\n\t\trow: Snippet<[DataType]>;\n\t}\n\tlet { children, row }: Props = $props();\n</script>\n```\n\n## Export (Svelte 5.5.0+)\n```svelte\n<script module>export { add };</script>\n{#snippet add(a, b)}{a} + {b} = {a + b}{/snippet}\n```\n\n## Key Facts\n- Replace Svelte 4 slots with more power/flexibility\n- Template constructs, not JS functions\n- Avoid props named `children` with implicit children\n- Use `createRawSnippet` API for advanced cases"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n<script>\n\tlet text = $state(\"\");\n\t\n\tlet stats = $derived.by(() => {\n\t\tconst words = text.trim() ? text.trim().split(/\\s+/).length : 0;\n\t\tconst chars = text.length;\n\t\tconst isLong = words > 15;\n\t\treturn { wordCount: words, charCount: chars, isLong };\n\t});\n\t\n\tconst clearText = () => {\n\t\ttext = \"\";\n\t};\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n\t<div>\n\t\t<p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n\t\t<p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n\t\t<p data-testid=\"length-indicator\">Status: {stats.isLong ? \"Long text\" : \"Short text\"}</p>\n\t</div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0
      }
    ]
  },
  {
    "testName": "each",
    "provider": "LMStudio",
    "modelId": "unsloth/Qwen3-Coder-30B-A3B-Instruct-GGUF",
    "numSamples": 1,
    "numCorrect": 1,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "# Svelte 5 Anti-Patterns\n\n## ‚ùå CRITICAL: Missing Content\n\n- **Do NOT generate empty components!** Always include the actual content requested\n- For \"Hello World\" tasks: MUST display \"Hello, World!\" text, not just structure\n- Template structure alone is insufficient - include the actual requirements\n\n## Event Handling\n\n- Do not use `on:click`, `on:submit`, or other Svelte 4-style event directives in Svelte 5. Use standard HTML event attributes like `onclick`, `onsubmit`, etc. instead.\n\n## Legacy Practices\n\n- Do not rely on implicit reactivity from Svelte 4 (`let` declarations, `$:` statements`).\n- Use modern Svelte 5 APIs instead of legacy APIs (e.g., prefer callback props over `createEventDispatcher`).\n\n## Build Tools\n\n- Use SvelteKit for new projects; do not opt for plain Vite, Rollup, or Webpack plugins.\n  - **Note:** SvelteKit is strongly recommended and centralizes best practices.\n\n## Runes Misuse\n\n### General\n\n- Do not use runes from Svelte 4 and prior (will cause compilation errors).\n- Do not import runes, they are part of the language\n\n### `$state`\n\n- Do not directly mutate `$state.raw` values (will not trigger reactive updates).\n- Do not directly export reassigned `$state` variables from `.svelte.js`/`.svelte.ts` modules (leads to non-reactive behavior for imports).\n- Do not mutate state you do not \"own\" (i.e., only mutate props marked `$bindable`).\n- For large collections, prefer using `$state.raw` for better performance, and always reassign the collection when making changes.\n- When updating state objects, avoid direct mutation of nested properties; instead, create new objects to ensure predictable state changes.\n\n### `$derived`\n\n- Do not change state (e.g., `count++`) directly within `$derived` expressions.\n- Avoid creating circular dependencies between derived values and state, as this can lead to infinite update loops.\n\n### State Management Patterns\n\n- Do not export state variables directly; instead, provide getter and setter functions to access and update state, preserving reactivity.\n- When exporting objects containing state, use getters and setters for stateful properties to maintain reactivity in consuming modules.\n\n### `$effect`\n\n- Do not update state directly within `$effect` functions (can lead to convoluted code and infinite loops).\n- Do not use `$effect` to synchronize state or derive new `$state` variables; use `$derived` for derivations.\n- Do not link mutually dependent input values using `$effect`; use `oninput` callbacks or function bindings instead.\n- Do not assume values read asynchronously (e.g., after `await` or in `setTimeout`) within an `$effect` are tracked as dependencies.\n- Do not expect an `$effect` to re-run when a property inside a mutated object changes if the object reference itself remains the same.\n\n## Component Communication\n\n- Do not directly mutate props unless they are explicitly declared as `$bindable()`.\n- Do not mutate a reactive state proxy passed as a prop in a child component (triggers `ownership_invalid_mutation` warning).\n- Do not mutate fallback values of non-bindable props (will not trigger updates).\n- Do not provide `undefined` to a `$bindable()` property that has a fallback value and is bound (results in a runtime error).\n\n### Common Props Mistakes (Svelte 5)\n\n- Always destructure needed props from `$props()` for reactivity; do not use the whole props object.\n- Always provide default values for optional props when destructuring.\n- Use `$bindable()` for two-way binding props.\n- Do not modify props directly; use callbacks to update parent state.\n- Use TypeScript types for complex props.\n\n## Debugging\n\n- Do not leave `$inspect` calls in production code (clutters code, even if they become no-ops).\n- Do not overuse `$inspect` (leads to overwhelming console output).\n- Do not use `$inspect` as a substitute for well-structured state management.\n\n## Reusable Reactive Logic\n\n- Do not export reassigned state directly from `.svelte.js`/`.svelte.ts` files (results in non-reactive behavior for external imports).\n\n## `bind:` Directive\n\n- Do not use reset buttons in forms too frequently (can lead to accidental data loss ‚Äî more of a UX warning).\n- Do not expect `DataTransfer` to be available for `bind:files` in server-side JavaScript runtimes (state should be left uninitialized for SSR).\n- Do not use dimension bindings (`bind:offsetWidth`, etc.) on elements with `display: inline` (their dimensions are not observable; change display style).\n- Do not expect dimension bindings to update if an element's size changes solely due to CSS transformations.\n- Do not use the `bind:group` directive across different components (only works for inputs within the same Svelte component).\n- Do not provide `undefined` to a bound `$bindable()` property that has a fallback value (results in a runtime error).\n\n## Asynchronous Operations (`{#await...}`)\n\n- Do not expect any branch other than the pending branch of an `{#await}` block to render during server-side rendering (SSR).\n\n## Keyed Blocks (`{#key...}`)\n\n- Do not use a constantly changing key value in `{#key}` blocks (leads to excessive DOM manipulation and potential performance degradation).\n\n## Attributes\n\n- Do not declare custom √üproperties or attributes that start with `on`.\n\n\n# Svelte 5 Best Practices\n\n## üöÄ Essential Setup & Syntax\n\n### Component Structure\n- **MANDATORY**: Always start with `<svelte:options runes={true} />` at the top\n- Use `<script>` for component-specific logic\n- Use `<style>` for scoped CSS\n- Maintain clear data flow and effective architecture for maintainability\n\n- When a task requires exact output (e.g., Hello-World) render the literal text `Hello, World!` inside an element with `data-testid=\"greeting\"` (no comments or computed empty strings).\n\n### Event Handling - CRITICAL CHANGE FROM SVELTE 4\n- ‚úÖ Use standard HTML attributes for event handling (`onclick`, `onsubmit`, etc.)\n- ‚ùå Do NOT use Svelte 4 syntax: `on:click`, `on:submit` will cause errors\n- For event modifiers, use wrapper functions instead of the pipe syntax from Svelte 4\n- For multiple handlers, combine them into a single function\n- Keep event handlers simple, moving complex logic to separate functions\n- Remember that event names are lowercase in HTML (`onclick`, not `onClick`)\n\n### Template Syntax Basics\n- Use `{#if expression}` for conditionals\n- Use `{#each expression as item}` for lists\n- Use `{#key value}` to force re-creation of content\n- Use `{#await promise}` for managing Promise states\n- Use `{variable}` for displaying values\n- Use snippets for reusable markup chunks\n\n## üß† Runes\n\n### `$state` - Reactive Variables\n\n- ‚úÖ Use `$state` for reactive UI state: `let count = $state(0)`\n- ‚úÖ Update `$state` variables directly (they behave like regular JavaScript variables)\n- ‚ùå NEVER import runes: `import { $state } from 'svelte'` causes parse errors\n- Use arrow functions for class methods relying on `this` with reactive state\n- Use `$state.raw` for large arrays/objects where deep reactivity isn't needed\n- Use `$state.snapshot` to get a non-reactive copy of state for external libraries\n- Pass getter functions (e.g., `() => a`) to functions needing the current reactive value of `$state` variables\n- When sharing `$state` from `.svelte.js`/`.svelte.ts` files:\n  - Export an object whose properties are mutated\n  - Or export getter functions\n\n### `$derived` - Computed Values\n\n- ‚úÖ Use `$derived` for computed values that are free of side effects: `let doubled = $derived(count * 2)`\n- ‚ùå NEVER import: `import { $derived } from 'svelte'` causes parse errors\n- Use `$derived.by` for complex derivation logic\n- Derived values can be temporarily reassigned for optimistic UI updates\n\n### `$effect` - Side Effects\n\n- ‚úÖ Use `$effect` for side effects and external interactions (e.g., third-party libraries, API calls, analytics, DOM manipulation)\n- ‚ùå NEVER import: `import { $effect } from 'svelte'` causes parse errors\n- Return a teardown function from `$effect` for cleanup (e.g., clearing intervals)\n- Use `$effect.pre` for logic that must run before DOM updates\n- Use `$effect.tracking` to check if code is running in a tracking context\n- Use `$effect.root` for creating non-tracked scopes with manual cleanup for nested effects\n- ‚ùå Do not update state inside effects - use `$derived` for derivations instead\n\n## üîÑ Component Communication & Props\n\n- **CRITICAL**: Props are READ-ONLY. Never assign directly to props\n- Destructure props directly from `$props()` for clarity: `let { name } = $props()`\n- Declare fallback values during destructuring: `let { name = \"default\" } = $props()`\n- Rename props during destructuring if they are invalid JavaScript identifiers\n- Use rest properties (`...others`) to capture remaining props\n- Add type safety using TypeScript interfaces or JSDoc\n- Use `$props.id()` (Svelte 5.20.0+) for unique, consistent component instance IDs\n- Use callback properties for child-to-parent communication (replaces `createEventDispatcher`)\n\n## üîó `bind:` Directive (Two-Way Data Binding)\n\n- Use `bind:` for two-way data flow from child to parent\n- Use shorthand `bind:property` when names match\n- Use function bindings (get/set) for validation or transformation (Svelte 5.9.0+)\n- For readonly bindings, set the get function to `null`\n- Access `bind:this` variables inside `$effect` or event handlers (they are undefined until mount)\n- Mark bindable properties with `$bindable()`\n- Provide fallback values for `$bindable()` properties\n\n## üêû Debugging (`$inspect`)\n\n- Use `$inspect` exclusively for development debugging; it tracks reactive state deeply.\n- Use `$inspect.with()` for custom debugging actions (e.g., `debugger`, `console.trace`).\n- Use `$inspect.trace()` (Svelte 5.14+) to trace function re-runs and identify causes.\n\n## ‚ôªÔ∏è Reusable Logic & State\n\n- Use `.svelte.js` and `.svelte.ts` files to create reusable reactive logic and share reactive state using runes.\n- Keep state logic separate from the wire components.\n\n## üß± Component Structure\n\n- Use `<script>` for component-specific logic.\n- Use `<style>` for scoped CSS.\n- Maintain clear data flow and effective architecture for maintainability.\n\n## üîó `bind:` Directive (Two-Way Data Binding)\n\n- Use `bind:` for two-way data flow from child to parent.\n- Use shorthand `bind:property` when names match.\n- Use function bindings (get/set) for validation or transformation (Svelte 5.9.0+).\n- For readonly bindings, set the get function to `null`.\n- Access `bind:this` variables inside `$effect` or event handlers (they are undefined until mount).\n- Mark bindable properties with `$bindable()`.\n- Provide fallback values for `$bindable()` properties.\n\n## üß© Template Syntax\n\n- Use `{#if expression}` for conditionals.\n- Use `{#each expression as item}` for lists.\n- Use `{#key value}` to force re-creation of content.\n- Use `{#await promise}` for managing Promise states.\n- Use snippets for reusable markup chunks.\n\n## üéâ Event Handling\n\n- Use standard HTML attributes for event handling (onclick, onsubmit, etc.)\n- For event modifiers, use wrapper functions instead of the pipe syntax from Svelte 4\n- For multiple handlers, combine them into a single function\n- Keep event handlers simple, moving complex logic to separate functions\n- Remember that event names are lowercase in HTML (onclick, not onClick)Event Handing\n\n## Component Events\n\n- Use callback props instead of event dispatching for component communication\n- Name callback props with an \"on\" prefix (e.g., onSubmit, onChange)\n- Pass data as an object to allow for future extensibility\n- For multiple events, use multiple callback props\n- Consider using TypeScript to type your callback props\n\n## Snippets\n\n- Use snippets to reduce duplication in your templates\n- Snippets can be passed as props to components\n- Snippets have lexical scoping rules - they are only visible in the same scope they are defined in\n- Use parameters to make snippets more flexible\n- Snippets can reference other snippets and even themselves (for recursion)\n\n## üè™ Store\n\n- Use stores only for:\n  - Interoperability with external libraries.\n  - Complex async data streams.\n  - Large apps.\n  - Scenarios needing explicit subscribe/unsubscribe behavior.\n\n## üß† Context\n\n- Store reactive state in context for child component access.\n- Wrap `setContext` and `getContext` in helper functions for type safety.\n- Context can and should be used for small to medium-sized applications to share state between components. It is also ideal for shared state, especially in SSR, as it avoids cross-request data leakage.\n\n## üß† Context\n\n- Store reactive state in context for child component access.\n- Wrap `setContext` and `getContext` in helper functions for type safety.\n- Context is ideal for shared state, especially in SSR, as it avoids cross-request data leakage.\n\n## üß™ Testing\n\n- Use **Vitest** for unit and integration testing.\n- Adjust `vite.config.js` to use browser entry points or alias backend libraries.\n- Include `.svelte` in test filenames for rune processing.\n- Wrap `$effects` in `$effect.root` during tests.\n- Use `flushSync` to run pending effects synchronously.\n- Use https://testing-library.com/docs/svelte-testing-library/intro.\n- Use **Playwright** for E2E testing.\n\n## üì¶ Packages\n\n- Explore new/popular packages at https://www.sveltesociety.dev/packages.\n\n## üîê Security\n\n- To prevent XSS attacks:\n  - Escape strings passed to `{@html ...}`.\n  - Ensure content is from trusted sources.\n  - The expression must be valid standalone HTML.\n\n## üß± Error Boundaries\n\n- Use `onerror` to integrate with error reporting services.\n- Wrap flaky components in `<svelte:boundary>` to isolate errors.\n- `<svelte:boundary>` requires a failed snippet or `onerror` function.\n- It does **not** catch errors outside rendering (e.g., event handlers, `setTimeout`, async work).\n\n\n# Svelte 5 $derived - LLM Context Guide\n\n**CRITICAL: $derived is built-in - NO imports needed. Importing causes parse errors.**\n\n## Syntax Rules\n- ‚úÖ `let x = $derived(expr)` - simple expressions  \n- ‚úÖ `let x = $derived.by(() => {...})` - complex logic\n- ‚úÖ `onclick={handler}` - NOT `on:click`\n- ‚úÖ `<svelte:options runes={true} />`\n- ‚ùå NEVER `import { $derived } from 'svelte/runes'`\n\n## Verified Working Template\n```svelte\n<svelte:options runes={true} />\n<script>\n\tlet count = $state(0);\n\tlet doubled = $derived(count * 2);\n\tconst increment = () => count++;\n</script>\n<div>\n\t<p data-testid=\"count-value\">Count: {count}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>\n```\n\n## $derived.by Example\n```svelte\n<script>\n\tlet items = $state([1, 2, 3]);\n\tlet sum = $derived.by(() => items.reduce((a, b) => a + b, 0));\n\t\n\t// ‚ùå INVALID - Cannot destructure $derived.by() return\n\t// const { wordCount, charCount } = $derived.by(() => ({ ... }));\n\t\n\t// ‚úÖ CORRECT - Store return value first\n\tlet stats = $derived.by(() => {\n\t\tconst words = text.split(' ').length;\n\t\tconst chars = text.length;\n\t\treturn { wordCount: words, charCount: chars, isLong: chars > 50 };\n\t});\n\t// Then access: stats.wordCount, stats.charCount, stats.isLong\n</script>\n```\n\n## Key Behaviors\n- Auto-updates when dependencies change\n- Pure expressions only (no mutations)\n- Push-pull: dependencies notify, values calculate on read\n- Can destructure: `let { a, b } = $derived(obj())` - ONLY simple $derived\n- **CRITICAL**: Cannot destructure `$derived.by()` - store return value first\n- Overridable since 5.25+\n\n# Svelte 5 Each Blocks\n\nIterate over arrays, array-like objects, or iterables (Map, Set) using `{#each}` blocks. Supports destructuring and optional keys for efficient DOM updates.\n\n## Basic Syntax\n\n```svelte\n{#each expression as name}...{/each}\n{#each expression as name, index}...{/each}\n```\n\n```svelte\n<ul>\n\t{#each items as item}\n\t\t<li>{item.name} x {item.qty}</li>\n\t{/each}\n</ul>\n```\n\n## Keyed Each Blocks\n\nUse unique keys to optimize DOM updates when data changes:\n\n```svelte\n{#each expression as name (key)}...{/each}\n```\n\n```svelte\n{#each items as item (item.id)}\n\t<li>{item.name} x {item.qty}</li>\n{/each}\n```\n\nKeys should be strings or numbers for identity persistence.\n\n## Destructuring\n\n```svelte\n{#each items as { id, name, qty }, i (id)}\n\t<li>{i + 1}: {name} x {qty}</li>\n{/each}\n```\n\n## Rendering N Times\n\n```svelte\n{#each { length: 8 }, index}\n\t<div>Item {index}</div>\n{/each}\n```\n\n## Else Clause\n\n```svelte\n{#each todos as todo}\n\t<p>{todo.text}</p>\n{:else}\n\t<p>No tasks today!</p>\n{/each}\n\n# Svelte 5 ‚Äî $effect (compressed)\n\nPurpose: browser-only rune for side effects after mount and after state updates. Do not use for derived state.\n\nCritical rules\n- Runes are built-in; DO NOT import `$state`, `$effect`, etc. (e.g. `import { $effect } from 'svelte/runes'` causes parse errors ‚Äî \"The $ prefix is reserved\").\n- Enable runes with `<svelte:options runes={true} />`.\n- Use `onclick={handler}` (Svelte 5), not `on:click={...}`.\n\nBehavior\n- Runs after component mount and in a microtask after state changes.\n- Dependencies: automatically tracked ‚Äî any `$state`, `$derived`, `$props` read synchronously inside the effect become dependencies.\n- Conditional reads are tracked only when executed (dependency set is recalculated each run).\n- Return a teardown function to cleanup; teardown runs before re-run and on destroy.\n\nSpecial variants\n- `$effect.pre(fn)`: runs before DOM update (useful for measuring DOM & scheduling `tick()`).\n- `$effect.root(fn)`: create a non-tracked scope that doesn't auto-cleanup; returns a `destroy()` to call manually.\n\nWhen to use\n- DOM manipulation (canvas), third-party libs, event listeners, timers, network requests.\n\nWhen NOT to use\n- State synchronization. Use `$derived(...)` for derived/computed state.\n\nCanonical minimal snippets (copy-paste safe)\n\nEnable runes:\n<svelte:options runes={true} />\n\nBasic effect (derived incorrectly shown only for demonstration ‚Äî prefer `$derived` in real code):\n```svelte\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n```\n\nCleanup (interval):\n```svelte\n<script>\n  let count = $state(0);\n  let milliseconds = $state(1000);\n\n  $effect(() => {\n    const interval = setInterval(() => count += 1, milliseconds);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\nPre-effect (before DOM update):\n```svelte\n<script>\n  import { tick } from 'svelte';\n  let div = $state();\n  let messages = $state([]);\n\n  $effect.pre(() => {\n    if (!div) return;\n    messages.length; // track\n    if (div.offsetHeight + div.scrollTop > div.scrollHeight - 20) {\n      tick().then(() => div.scrollTo(0, div.scrollHeight));\n    }\n  });\n</script>\n```\n\nroot scope:\n```js\nconst destroy = $effect.root(() => {\n  $effect(() => { /* setup */ });\n  return () => { /* cleanup */ };\n});\n// later: destroy();\n```\n\nEdge cases / pitfalls\n- Invalid imports break parsing ‚Äî never import `$` runes.\n- Mutating an object vs reassigning: read specific properties to track them (mutating top-level object may not retrigger effects that only read the object reference).\n- Conditional reads: a value read only inside an `if` is only a dependency when that branch executed.\n- Use `$effect.pre` when you must measure DOM before updates.\n- `$effect.root` requires manual cleanup (not auto-cleaned).\n\nTesting & best-practices\n- Include `data-testid` in examples for tests.\n- Prefer `$derived` for computed values; `$effect` only for side effects.\n\nOne-line summary: `$effect` = built-in Svelte 5 side-effect rune; no imports; auto-deps; return teardown for cleanup; use `$derived` for pure derived state.\n\n# Svelte 5 $inspect Rune - Dense Reference\n\n**Dev-only reactive debugger. Re-runs on reactive state changes. Template literals MUST use backticks (`)**\n\n## Core Implementation\n```svelte\n<svelte:options runes={true} />\n<script>\n\tlet text = $state(\"Hello world\");\n\t$inspect(text); // Basic usage\n\t$inspect(text).with((type, value) => { // Custom logging\n\t\tif (type === \"update\") console.log(`Text updated to: \"${value}\"`);\n\t});\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // MUST be first statement\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\t});\n</script>\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n</div>\n```\n\n## Basic Usage\n\nThe simplest form of `$inspect` logs values to the console whenever they change:\n\n```svelte\n<script>\n\tlet count = $state(0);\n\tlet message = $state('hello');\n\n\t$inspect(count, message); // will console.log when `count` or `message` change\n</script>\n\n<button onclick={() => count++}>Increment</button>\n<input bind:value={message} />\n```\n\n## Text Input Example with Quotes\n\nWhen working with text inputs, you often want to display the value with quotes to show empty strings clearly:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// Basic $inspect usage\n\t$inspect(text);\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n\t<p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>\n```\n\nNote: Always wrap text values in quotes when displaying them in UI to make empty strings visible.\n\n## $inspect(...).with\n\n`$inspect` returns a property `with`, which you can invoke with a callback, which will then be invoked instead of `console.log`. The first argument to the callback is either `\"init\"` or `\"update\"`; subsequent arguments are the values passed to `$inspect`.\n\n### Custom Console Logging\n\n**MANDATORY SYNTAX**: Template literals MUST use backticks (`), not quotes:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\n\t// Custom callback for tracking text changes\n\t$inspect(text).with((type, value) => {\n\t\tif (type === \"update\") {\n\t\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t\t}\n\t});\n</script>\n\n<input bind:value={text} />\n```\n\n**CRITICAL**: Always use backticks (`) for template literals:\n- ‚úÖ `console.log(\\`Text updated to: \"${value}\"\\`);`\n- ‚ùå `console.log(Text updated to: \"${value}\");` ‚Üê Missing backticks causes syntax error\n\nThe callback receives:\n- `type`: Either `\"init\"` (first call) or `\"update\"` (subsequent changes)  \n- `value`: The current value being inspected\n\n### Debugging Example\n\n```svelte\n<script>\n\tlet count = $state(0);\n\n\t$inspect(count).with((type, count) => {\n\t\tif (type === 'update') {\n\t\t\tdebugger; // or `console.trace`, or whatever you want\n\t\t}\n\t});\n</script>\n\n<button onclick={() => count++}>Increment</button>\n```\n\nA convenient way to find the origin of some change is to pass `console.trace` to `with`:\n\n```js\n$inspect(stuff).with(console.trace);\n```\n\n## $inspect.trace(...)\n\nThis rune, added in 5.14, causes the surrounding function to be _traced_ in development. Any time the function re-runs as part of an effect or a derived, information will be printed to the console about which pieces of reactive state caused the effect to fire.\n\n**üö® CRITICAL PLACEMENT WARNING**: `$inspect.trace` MUST be the first statement of a function body. Placing it anywhere else will cause a compile error.\n\n### ‚ùå WRONG - $inspect.trace not in first position\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t$effect(() => {\n\t\tconsole.log('[$effect] Input text changed to:', text); // ‚ùå Statement before $inspect.trace\n\t\t$inspect.trace(); // ‚ùå WRONG POSITION - will cause compile error\n\t});\n</script>\n```\n\n**Error**: `$inspect.trace(...)` must be the first statement of a function body\n\n### ‚úÖ CORRECT - $inspect.trace as first statement\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // ‚úÖ CORRECT - First statement\n\t\tconsole.log(`[$effect] Input text changed to: \"${text}\"`);\n\t});\n</script>\n```\n\n### Basic Usage in Effects\n\n**MANDATORY**: Always place `$inspect.trace` as the very first line inside function bodies:\n\n```svelte\n<script>\n\timport { doSomeWork } from './elsewhere';\n\n\t$effect(() => {\n\t\t$inspect.trace(); // ‚úÖ Must be first statement\n\t\tdoSomeWork();\n\t});\n</script>\n```\n\n### Text Input Tracking with Effects\n\nFor text input tracking, combine `$inspect.trace` with effects to monitor changes:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// ‚úÖ CORRECT - $inspect.trace as first statement\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // ‚úÖ Optional label, MUST be first\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\t});\n</script>\n\n<input bind:value={text} />\n```\n\n**CRITICAL SYNTAX RULES:**\n1. ‚úÖ `$inspect.trace()` MUST be the very first statement inside `$effect(() => {`  \n2. ‚ùå NEVER put any other code before `$inspect.trace()`\n3. ‚úÖ Use template literals with backticks: `` console.log(`text: \"${text}\"`) ``\n4. ‚ùå NEVER omit backticks: `console.log(text: \"${text}\")` ‚Üê SYNTAX ERROR\n\n`$inspect.trace` takes an optional first argument which will be used as the label.\n\n## Complete Working Example\n\nHere's a complete example that demonstrates all `$inspect` features with proper formatting:\n\n```svelte\n<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// 1. Basic $inspect usage\n\t$inspect(text);\n\t\n\t// 2. Using $inspect(...).with for custom logging\n\t$inspect(text).with((type, value) => {\n\t\tif (type === \"update\") {\n\t\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t\t}\n\t});\n\t\n\t// 3. MANDATORY: $effect with $inspect.trace AND console.log\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // MUST be first\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`); // REQUIRED\n\t});\n</script>\n\n<div>\n\t<label for=\"text-input\">Edit text:</label>\n\t<input \n\t\tdata-testid=\"text-input\" \n\t\tid=\"text-input\" \n\t\ttype=\"text\" \n\t\tbind:value={text} \n\t/>\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n\t<p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>\n```\n\n## MANDATORY Patterns for Tests\n\n**$effect with $inspect MUST include console.log:**\n```js\n$effect(() => {\n\t$inspect.trace(\"text-changes\"); // Always first statement\n\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`); // REQUIRED format\n});\n```\n\n**$inspect.with MUST check update type:**\n```js\n$inspect(text).with((type, value) => {\n\tif (type === \"update\") { // REQUIRED check\n\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t}\n});\n```\n\n## Key Points for Testing\n\n- Always wrap displayed text values in quotes to show empty strings clearly\n- Use specific console.log message formats for predictable testing\n- Include proper `data-testid` attributes for test targeting\n- The `$inspect(...).with` callback should check for `type === \"update\"` to avoid init logs\n- Console messages should include the exact format: `Text updated to: \"${value}\"`\n- Effect logging should follow the pattern: `The text is now: \"${text}\" (${text.length} characters)`\n\n### Critical Syntax Reminders\n\n**Template Literals**: Always use backticks (`) for template literals, not regular quotes:\n```javascript\n// ‚úÖ CORRECT\nconsole.log(`Text updated to: \"${value}\"`);\nconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\n// ‚ùå WRONG - missing backticks\nconsole.log(Text updated to: \"${value}\");\nconsole.log(The text is now: \"${text}\" (${text.length} characters));\n```\n\n**Input Element**: Always include all required attributes:\n```html\n<!-- ‚úÖ CORRECT -->\n<input \n    data-testid=\"text-input\" \n    id=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n/>\n\n<!-- ‚ùå WRONG - incomplete -->\n<input \n```\n\n# Svelte 5 Props Reference\n\n## Basic Props\n```svelte\n<!-- Parent -->\n<MyComponent adjective=\"cool\" />\n\n<!-- Child -->\n<script>\n  let { adjective } = $props(); // destructured (recommended)\n  let props = $props(); // or access via props.adjective\n</script>\n```\n\n## Fallbacks & Renaming\n```js\nlet { adjective = 'happy' } = $props(); // fallback value\nlet { super: trouper = 'default' } = $props(); // rename invalid identifier\nlet { a, b, ...others } = $props(); // rest props\n```\n\nCall $props() exactly once ‚Äî destructure all props in a single call or use a single props object to avoid the `props_duplicate` compile error.\n\nMinimal correct pattern:\n```svelte\n// correct ‚Äî single $props() call\nlet props = $props(); let { name = \"World\", count = 0, showDetails = false } = props;\n```\n\n## Prop Mutation Rules - CRITICAL\n\n**Props are READ-ONLY. Never assign to props directly:**\n\n‚ùå **FORBIDDEN - Will cause compilation errors:**\n```js\nlet { text } = $props();\ntext = \"new value\"; // ‚ùå COMPILE ERROR - props are read-only\n```\n\n‚úÖ **CORRECT - Use local state for modifications:**\n```js\nlet { text } = $props();\nlet localText = $state(text); // Copy to local state\n// Now modify localText: localText = \"new value\"; ‚úÖ\n```\n\n**Rules:**\n- ‚ùå Direct assignment: `prop = value` causes compilation errors\n- ‚ùå Direct mutation: `prop.property = value` (unless `$bindable`) \n- ‚úÖ Local state: `let local = $state(prop)` then modify `local`\n- ‚úÖ Temporary reassignment: only for local scope override\n- Regular objects: mutations have no effect\n- Reactive proxies: mutations work but trigger warnings\n- Fallback values: not reactive, mutations ignored\n\n## Type Safety\n```svelte\n<script lang=\"ts\">\n  interface Props { adjective: string; }\n  let { adjective }: Props = $props();\n  \n  // Or inline\n  let { adjective }: { adjective: string } = $props();\n  \n  // JSDoc\n  /** @type {{ adjective: string }} */\n  let { adjective } = $props();\n</script>\n```\n\n## Unique IDs\n```svelte\n<script>\n  const uid = $props.id(); // unique per component instance\n</script>\n<label for=\"{uid}-input\">Label</label>\n<input id=\"{uid}-input\" />\n```\n\n## Key Points\n- Props update reactively when parent changes\n- Use callbacks or `$bindable` for child-to-parent communication\n- Fallback values aren't reactive proxies\n- Type annotations recommended for discoverability\n- DOM element interfaces in `svelte/elements`\n\n# Svelte 5 Snippets\n```svelte\n<svelte:options runes={true} />\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n<style></style>\n```\n\n## CRITICAL SYNTAX RULES\n- ‚ùå NEVER use `return` keyword or JSX syntax `<span>`\n- ‚úÖ ALWAYS use pure Svelte template syntax: `{#snippet name(params)}...{/snippet}`\n- ‚ùå NOT: `const title = snippet((param) => { return <span>{param}</span>; })`\n- ‚úÖ CORRECT: `{#snippet title(param)}<span>{param}</span>{/snippet}`\n\n## Basic Syntax\n```svelte\n{#snippet name()}...{/snippet}\n{#snippet name(param1, param2)}...{/snippet}\n{@render name(args)}\n```\n\n## Working Example\n```svelte\n<svelte:options runes={true} />\n<script>\n\tconst items = [\"item1\", \"item2\"];\n</script>\n{#snippet title(text)}\n\t<span data-testid=\"title\">{text}</span>\n{/snippet}\n<ul>\n\t{#each items as item}\n\t\t<li>{@render title(item)}</li>\n\t{/each}\n</ul>\n```\n\n## Scope & Parameters\n- Snippets access lexical scope variables\n- Support default values & destructuring: `{#snippet name(param = default)}`\n- Can reference themselves (recursion) and siblings\n- No rest parameters support\n\n## Component Props\n**Explicit:** `<Table {header} {row} />`\n**Implicit:** Content inside component becomes props automatically\n**Children:** Non-snippet content becomes `children` snippet\n\n```svelte\n<!-- Implicit children -->\n<Button>click me</Button>\n\n<!-- Button.svelte -->\n<script>let { children } = $props();</script>\n<button>{@render children()}</button>\n\n<!-- Optional snippets -->\n{@render children?.()}\n{#if children}{@render children()}{:else}fallback{/if}\n```\n\n## TypeScript\n```svelte\n<script lang=\"ts\">\n\timport type { Snippet } from 'svelte';\n\tinterface Props {\n\t\tchildren: Snippet;\n\t\trow: Snippet<[DataType]>;\n\t}\n\tlet { children, row }: Props = $props();\n</script>\n```\n\n## Export (Svelte 5.5.0+)\n```svelte\n<script module>export { add };</script>\n{#snippet add(a, b)}{a} + {b} = {a + b}{/snippet}\n```\n\n## Key Facts\n- Replace Svelte 4 slots with more power/flexibility\n- Template constructs, not JS functions\n- Avoid props named `children` with implicit children\n- Use `createRawSnippet` API for advanced cases"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n<script>\n\tlet characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\tconst addGeorge = () => {\n\t\tcharacters = [...characters, \"George\"];\n\t};\n</script>\n<div>\n\t<ul data-testid=\"characters-list\">\n\t\t{#each characters as character}\n\t\t\t<li data-testid=\"character\">{character}</li>\n\t\t{/each}\n\t</ul>\n\t<button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0
      }
    ]
  },
  {
    "testName": "effect",
    "provider": "LMStudio",
    "modelId": "unsloth/Qwen3-Coder-30B-A3B-Instruct-GGUF",
    "numSamples": 1,
    "numCorrect": 1,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "# Svelte 5 Anti-Patterns\n\n## ‚ùå CRITICAL: Missing Content\n\n- **Do NOT generate empty components!** Always include the actual content requested\n- For \"Hello World\" tasks: MUST display \"Hello, World!\" text, not just structure\n- Template structure alone is insufficient - include the actual requirements\n\n## Event Handling\n\n- Do not use `on:click`, `on:submit`, or other Svelte 4-style event directives in Svelte 5. Use standard HTML event attributes like `onclick`, `onsubmit`, etc. instead.\n\n## Legacy Practices\n\n- Do not rely on implicit reactivity from Svelte 4 (`let` declarations, `$:` statements`).\n- Use modern Svelte 5 APIs instead of legacy APIs (e.g., prefer callback props over `createEventDispatcher`).\n\n## Build Tools\n\n- Use SvelteKit for new projects; do not opt for plain Vite, Rollup, or Webpack plugins.\n  - **Note:** SvelteKit is strongly recommended and centralizes best practices.\n\n## Runes Misuse\n\n### General\n\n- Do not use runes from Svelte 4 and prior (will cause compilation errors).\n- Do not import runes, they are part of the language\n\n### `$state`\n\n- Do not directly mutate `$state.raw` values (will not trigger reactive updates).\n- Do not directly export reassigned `$state` variables from `.svelte.js`/`.svelte.ts` modules (leads to non-reactive behavior for imports).\n- Do not mutate state you do not \"own\" (i.e., only mutate props marked `$bindable`).\n- For large collections, prefer using `$state.raw` for better performance, and always reassign the collection when making changes.\n- When updating state objects, avoid direct mutation of nested properties; instead, create new objects to ensure predictable state changes.\n\n### `$derived`\n\n- Do not change state (e.g., `count++`) directly within `$derived` expressions.\n- Avoid creating circular dependencies between derived values and state, as this can lead to infinite update loops.\n\n### State Management Patterns\n\n- Do not export state variables directly; instead, provide getter and setter functions to access and update state, preserving reactivity.\n- When exporting objects containing state, use getters and setters for stateful properties to maintain reactivity in consuming modules.\n\n### `$effect`\n\n- Do not update state directly within `$effect` functions (can lead to convoluted code and infinite loops).\n- Do not use `$effect` to synchronize state or derive new `$state` variables; use `$derived` for derivations.\n- Do not link mutually dependent input values using `$effect`; use `oninput` callbacks or function bindings instead.\n- Do not assume values read asynchronously (e.g., after `await` or in `setTimeout`) within an `$effect` are tracked as dependencies.\n- Do not expect an `$effect` to re-run when a property inside a mutated object changes if the object reference itself remains the same.\n\n## Component Communication\n\n- Do not directly mutate props unless they are explicitly declared as `$bindable()`.\n- Do not mutate a reactive state proxy passed as a prop in a child component (triggers `ownership_invalid_mutation` warning).\n- Do not mutate fallback values of non-bindable props (will not trigger updates).\n- Do not provide `undefined` to a `$bindable()` property that has a fallback value and is bound (results in a runtime error).\n\n### Common Props Mistakes (Svelte 5)\n\n- Always destructure needed props from `$props()` for reactivity; do not use the whole props object.\n- Always provide default values for optional props when destructuring.\n- Use `$bindable()` for two-way binding props.\n- Do not modify props directly; use callbacks to update parent state.\n- Use TypeScript types for complex props.\n\n## Debugging\n\n- Do not leave `$inspect` calls in production code (clutters code, even if they become no-ops).\n- Do not overuse `$inspect` (leads to overwhelming console output).\n- Do not use `$inspect` as a substitute for well-structured state management.\n\n## Reusable Reactive Logic\n\n- Do not export reassigned state directly from `.svelte.js`/`.svelte.ts` files (results in non-reactive behavior for external imports).\n\n## `bind:` Directive\n\n- Do not use reset buttons in forms too frequently (can lead to accidental data loss ‚Äî more of a UX warning).\n- Do not expect `DataTransfer` to be available for `bind:files` in server-side JavaScript runtimes (state should be left uninitialized for SSR).\n- Do not use dimension bindings (`bind:offsetWidth`, etc.) on elements with `display: inline` (their dimensions are not observable; change display style).\n- Do not expect dimension bindings to update if an element's size changes solely due to CSS transformations.\n- Do not use the `bind:group` directive across different components (only works for inputs within the same Svelte component).\n- Do not provide `undefined` to a bound `$bindable()` property that has a fallback value (results in a runtime error).\n\n## Asynchronous Operations (`{#await...}`)\n\n- Do not expect any branch other than the pending branch of an `{#await}` block to render during server-side rendering (SSR).\n\n## Keyed Blocks (`{#key...}`)\n\n- Do not use a constantly changing key value in `{#key}` blocks (leads to excessive DOM manipulation and potential performance degradation).\n\n## Attributes\n\n- Do not declare custom √üproperties or attributes that start with `on`.\n\n\n# Svelte 5 Best Practices\n\n## üöÄ Essential Setup & Syntax\n\n### Component Structure\n- **MANDATORY**: Always start with `<svelte:options runes={true} />` at the top\n- Use `<script>` for component-specific logic\n- Use `<style>` for scoped CSS\n- Maintain clear data flow and effective architecture for maintainability\n\n- When a task requires exact output (e.g., Hello-World) render the literal text `Hello, World!` inside an element with `data-testid=\"greeting\"` (no comments or computed empty strings).\n\n### Event Handling - CRITICAL CHANGE FROM SVELTE 4\n- ‚úÖ Use standard HTML attributes for event handling (`onclick`, `onsubmit`, etc.)\n- ‚ùå Do NOT use Svelte 4 syntax: `on:click`, `on:submit` will cause errors\n- For event modifiers, use wrapper functions instead of the pipe syntax from Svelte 4\n- For multiple handlers, combine them into a single function\n- Keep event handlers simple, moving complex logic to separate functions\n- Remember that event names are lowercase in HTML (`onclick`, not `onClick`)\n\n### Template Syntax Basics\n- Use `{#if expression}` for conditionals\n- Use `{#each expression as item}` for lists\n- Use `{#key value}` to force re-creation of content\n- Use `{#await promise}` for managing Promise states\n- Use `{variable}` for displaying values\n- Use snippets for reusable markup chunks\n\n## üß† Runes\n\n### `$state` - Reactive Variables\n\n- ‚úÖ Use `$state` for reactive UI state: `let count = $state(0)`\n- ‚úÖ Update `$state` variables directly (they behave like regular JavaScript variables)\n- ‚ùå NEVER import runes: `import { $state } from 'svelte'` causes parse errors\n- Use arrow functions for class methods relying on `this` with reactive state\n- Use `$state.raw` for large arrays/objects where deep reactivity isn't needed\n- Use `$state.snapshot` to get a non-reactive copy of state for external libraries\n- Pass getter functions (e.g., `() => a`) to functions needing the current reactive value of `$state` variables\n- When sharing `$state` from `.svelte.js`/`.svelte.ts` files:\n  - Export an object whose properties are mutated\n  - Or export getter functions\n\n### `$derived` - Computed Values\n\n- ‚úÖ Use `$derived` for computed values that are free of side effects: `let doubled = $derived(count * 2)`\n- ‚ùå NEVER import: `import { $derived } from 'svelte'` causes parse errors\n- Use `$derived.by` for complex derivation logic\n- Derived values can be temporarily reassigned for optimistic UI updates\n\n### `$effect` - Side Effects\n\n- ‚úÖ Use `$effect` for side effects and external interactions (e.g., third-party libraries, API calls, analytics, DOM manipulation)\n- ‚ùå NEVER import: `import { $effect } from 'svelte'` causes parse errors\n- Return a teardown function from `$effect` for cleanup (e.g., clearing intervals)\n- Use `$effect.pre` for logic that must run before DOM updates\n- Use `$effect.tracking` to check if code is running in a tracking context\n- Use `$effect.root` for creating non-tracked scopes with manual cleanup for nested effects\n- ‚ùå Do not update state inside effects - use `$derived` for derivations instead\n\n## üîÑ Component Communication & Props\n\n- **CRITICAL**: Props are READ-ONLY. Never assign directly to props\n- Destructure props directly from `$props()` for clarity: `let { name } = $props()`\n- Declare fallback values during destructuring: `let { name = \"default\" } = $props()`\n- Rename props during destructuring if they are invalid JavaScript identifiers\n- Use rest properties (`...others`) to capture remaining props\n- Add type safety using TypeScript interfaces or JSDoc\n- Use `$props.id()` (Svelte 5.20.0+) for unique, consistent component instance IDs\n- Use callback properties for child-to-parent communication (replaces `createEventDispatcher`)\n\n## üîó `bind:` Directive (Two-Way Data Binding)\n\n- Use `bind:` for two-way data flow from child to parent\n- Use shorthand `bind:property` when names match\n- Use function bindings (get/set) for validation or transformation (Svelte 5.9.0+)\n- For readonly bindings, set the get function to `null`\n- Access `bind:this` variables inside `$effect` or event handlers (they are undefined until mount)\n- Mark bindable properties with `$bindable()`\n- Provide fallback values for `$bindable()` properties\n\n## üêû Debugging (`$inspect`)\n\n- Use `$inspect` exclusively for development debugging; it tracks reactive state deeply.\n- Use `$inspect.with()` for custom debugging actions (e.g., `debugger`, `console.trace`).\n- Use `$inspect.trace()` (Svelte 5.14+) to trace function re-runs and identify causes.\n\n## ‚ôªÔ∏è Reusable Logic & State\n\n- Use `.svelte.js` and `.svelte.ts` files to create reusable reactive logic and share reactive state using runes.\n- Keep state logic separate from the wire components.\n\n## üß± Component Structure\n\n- Use `<script>` for component-specific logic.\n- Use `<style>` for scoped CSS.\n- Maintain clear data flow and effective architecture for maintainability.\n\n## üîó `bind:` Directive (Two-Way Data Binding)\n\n- Use `bind:` for two-way data flow from child to parent.\n- Use shorthand `bind:property` when names match.\n- Use function bindings (get/set) for validation or transformation (Svelte 5.9.0+).\n- For readonly bindings, set the get function to `null`.\n- Access `bind:this` variables inside `$effect` or event handlers (they are undefined until mount).\n- Mark bindable properties with `$bindable()`.\n- Provide fallback values for `$bindable()` properties.\n\n## üß© Template Syntax\n\n- Use `{#if expression}` for conditionals.\n- Use `{#each expression as item}` for lists.\n- Use `{#key value}` to force re-creation of content.\n- Use `{#await promise}` for managing Promise states.\n- Use snippets for reusable markup chunks.\n\n## üéâ Event Handling\n\n- Use standard HTML attributes for event handling (onclick, onsubmit, etc.)\n- For event modifiers, use wrapper functions instead of the pipe syntax from Svelte 4\n- For multiple handlers, combine them into a single function\n- Keep event handlers simple, moving complex logic to separate functions\n- Remember that event names are lowercase in HTML (onclick, not onClick)Event Handing\n\n## Component Events\n\n- Use callback props instead of event dispatching for component communication\n- Name callback props with an \"on\" prefix (e.g., onSubmit, onChange)\n- Pass data as an object to allow for future extensibility\n- For multiple events, use multiple callback props\n- Consider using TypeScript to type your callback props\n\n## Snippets\n\n- Use snippets to reduce duplication in your templates\n- Snippets can be passed as props to components\n- Snippets have lexical scoping rules - they are only visible in the same scope they are defined in\n- Use parameters to make snippets more flexible\n- Snippets can reference other snippets and even themselves (for recursion)\n\n## üè™ Store\n\n- Use stores only for:\n  - Interoperability with external libraries.\n  - Complex async data streams.\n  - Large apps.\n  - Scenarios needing explicit subscribe/unsubscribe behavior.\n\n## üß† Context\n\n- Store reactive state in context for child component access.\n- Wrap `setContext` and `getContext` in helper functions for type safety.\n- Context can and should be used for small to medium-sized applications to share state between components. It is also ideal for shared state, especially in SSR, as it avoids cross-request data leakage.\n\n## üß† Context\n\n- Store reactive state in context for child component access.\n- Wrap `setContext` and `getContext` in helper functions for type safety.\n- Context is ideal for shared state, especially in SSR, as it avoids cross-request data leakage.\n\n## üß™ Testing\n\n- Use **Vitest** for unit and integration testing.\n- Adjust `vite.config.js` to use browser entry points or alias backend libraries.\n- Include `.svelte` in test filenames for rune processing.\n- Wrap `$effects` in `$effect.root` during tests.\n- Use `flushSync` to run pending effects synchronously.\n- Use https://testing-library.com/docs/svelte-testing-library/intro.\n- Use **Playwright** for E2E testing.\n\n## üì¶ Packages\n\n- Explore new/popular packages at https://www.sveltesociety.dev/packages.\n\n## üîê Security\n\n- To prevent XSS attacks:\n  - Escape strings passed to `{@html ...}`.\n  - Ensure content is from trusted sources.\n  - The expression must be valid standalone HTML.\n\n## üß± Error Boundaries\n\n- Use `onerror` to integrate with error reporting services.\n- Wrap flaky components in `<svelte:boundary>` to isolate errors.\n- `<svelte:boundary>` requires a failed snippet or `onerror` function.\n- It does **not** catch errors outside rendering (e.g., event handlers, `setTimeout`, async work).\n\n\n# Svelte 5 $derived - LLM Context Guide\n\n**CRITICAL: $derived is built-in - NO imports needed. Importing causes parse errors.**\n\n## Syntax Rules\n- ‚úÖ `let x = $derived(expr)` - simple expressions  \n- ‚úÖ `let x = $derived.by(() => {...})` - complex logic\n- ‚úÖ `onclick={handler}` - NOT `on:click`\n- ‚úÖ `<svelte:options runes={true} />`\n- ‚ùå NEVER `import { $derived } from 'svelte/runes'`\n\n## Verified Working Template\n```svelte\n<svelte:options runes={true} />\n<script>\n\tlet count = $state(0);\n\tlet doubled = $derived(count * 2);\n\tconst increment = () => count++;\n</script>\n<div>\n\t<p data-testid=\"count-value\">Count: {count}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>\n```\n\n## $derived.by Example\n```svelte\n<script>\n\tlet items = $state([1, 2, 3]);\n\tlet sum = $derived.by(() => items.reduce((a, b) => a + b, 0));\n\t\n\t// ‚ùå INVALID - Cannot destructure $derived.by() return\n\t// const { wordCount, charCount } = $derived.by(() => ({ ... }));\n\t\n\t// ‚úÖ CORRECT - Store return value first\n\tlet stats = $derived.by(() => {\n\t\tconst words = text.split(' ').length;\n\t\tconst chars = text.length;\n\t\treturn { wordCount: words, charCount: chars, isLong: chars > 50 };\n\t});\n\t// Then access: stats.wordCount, stats.charCount, stats.isLong\n</script>\n```\n\n## Key Behaviors\n- Auto-updates when dependencies change\n- Pure expressions only (no mutations)\n- Push-pull: dependencies notify, values calculate on read\n- Can destructure: `let { a, b } = $derived(obj())` - ONLY simple $derived\n- **CRITICAL**: Cannot destructure `$derived.by()` - store return value first\n- Overridable since 5.25+\n\n# Svelte 5 Each Blocks\n\nIterate over arrays, array-like objects, or iterables (Map, Set) using `{#each}` blocks. Supports destructuring and optional keys for efficient DOM updates.\n\n## Basic Syntax\n\n```svelte\n{#each expression as name}...{/each}\n{#each expression as name, index}...{/each}\n```\n\n```svelte\n<ul>\n\t{#each items as item}\n\t\t<li>{item.name} x {item.qty}</li>\n\t{/each}\n</ul>\n```\n\n## Keyed Each Blocks\n\nUse unique keys to optimize DOM updates when data changes:\n\n```svelte\n{#each expression as name (key)}...{/each}\n```\n\n```svelte\n{#each items as item (item.id)}\n\t<li>{item.name} x {item.qty}</li>\n{/each}\n```\n\nKeys should be strings or numbers for identity persistence.\n\n## Destructuring\n\n```svelte\n{#each items as { id, name, qty }, i (id)}\n\t<li>{i + 1}: {name} x {qty}</li>\n{/each}\n```\n\n## Rendering N Times\n\n```svelte\n{#each { length: 8 }, index}\n\t<div>Item {index}</div>\n{/each}\n```\n\n## Else Clause\n\n```svelte\n{#each todos as todo}\n\t<p>{todo.text}</p>\n{:else}\n\t<p>No tasks today!</p>\n{/each}\n\n# Svelte 5 ‚Äî $effect (compressed)\n\nPurpose: browser-only rune for side effects after mount and after state updates. Do not use for derived state.\n\nCritical rules\n- Runes are built-in; DO NOT import `$state`, `$effect`, etc. (e.g. `import { $effect } from 'svelte/runes'` causes parse errors ‚Äî \"The $ prefix is reserved\").\n- Enable runes with `<svelte:options runes={true} />`.\n- Use `onclick={handler}` (Svelte 5), not `on:click={...}`.\n\nBehavior\n- Runs after component mount and in a microtask after state changes.\n- Dependencies: automatically tracked ‚Äî any `$state`, `$derived`, `$props` read synchronously inside the effect become dependencies.\n- Conditional reads are tracked only when executed (dependency set is recalculated each run).\n- Return a teardown function to cleanup; teardown runs before re-run and on destroy.\n\nSpecial variants\n- `$effect.pre(fn)`: runs before DOM update (useful for measuring DOM & scheduling `tick()`).\n- `$effect.root(fn)`: create a non-tracked scope that doesn't auto-cleanup; returns a `destroy()` to call manually.\n\nWhen to use\n- DOM manipulation (canvas), third-party libs, event listeners, timers, network requests.\n\nWhen NOT to use\n- State synchronization. Use `$derived(...)` for derived/computed state.\n\nCanonical minimal snippets (copy-paste safe)\n\nEnable runes:\n<svelte:options runes={true} />\n\nBasic effect (derived incorrectly shown only for demonstration ‚Äî prefer `$derived` in real code):\n```svelte\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n```\n\nCleanup (interval):\n```svelte\n<script>\n  let count = $state(0);\n  let milliseconds = $state(1000);\n\n  $effect(() => {\n    const interval = setInterval(() => count += 1, milliseconds);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\nPre-effect (before DOM update):\n```svelte\n<script>\n  import { tick } from 'svelte';\n  let div = $state();\n  let messages = $state([]);\n\n  $effect.pre(() => {\n    if (!div) return;\n    messages.length; // track\n    if (div.offsetHeight + div.scrollTop > div.scrollHeight - 20) {\n      tick().then(() => div.scrollTo(0, div.scrollHeight));\n    }\n  });\n</script>\n```\n\nroot scope:\n```js\nconst destroy = $effect.root(() => {\n  $effect(() => { /* setup */ });\n  return () => { /* cleanup */ };\n});\n// later: destroy();\n```\n\nEdge cases / pitfalls\n- Invalid imports break parsing ‚Äî never import `$` runes.\n- Mutating an object vs reassigning: read specific properties to track them (mutating top-level object may not retrigger effects that only read the object reference).\n- Conditional reads: a value read only inside an `if` is only a dependency when that branch executed.\n- Use `$effect.pre` when you must measure DOM before updates.\n- `$effect.root` requires manual cleanup (not auto-cleaned).\n\nTesting & best-practices\n- Include `data-testid` in examples for tests.\n- Prefer `$derived` for computed values; `$effect` only for side effects.\n\nOne-line summary: `$effect` = built-in Svelte 5 side-effect rune; no imports; auto-deps; return teardown for cleanup; use `$derived` for pure derived state.\n\n# Svelte 5 $inspect Rune - Dense Reference\n\n**Dev-only reactive debugger. Re-runs on reactive state changes. Template literals MUST use backticks (`)**\n\n## Core Implementation\n```svelte\n<svelte:options runes={true} />\n<script>\n\tlet text = $state(\"Hello world\");\n\t$inspect(text); // Basic usage\n\t$inspect(text).with((type, value) => { // Custom logging\n\t\tif (type === \"update\") console.log(`Text updated to: \"${value}\"`);\n\t});\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // MUST be first statement\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\t});\n</script>\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n</div>\n```\n\n## Basic Usage\n\nThe simplest form of `$inspect` logs values to the console whenever they change:\n\n```svelte\n<script>\n\tlet count = $state(0);\n\tlet message = $state('hello');\n\n\t$inspect(count, message); // will console.log when `count` or `message` change\n</script>\n\n<button onclick={() => count++}>Increment</button>\n<input bind:value={message} />\n```\n\n## Text Input Example with Quotes\n\nWhen working with text inputs, you often want to display the value with quotes to show empty strings clearly:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// Basic $inspect usage\n\t$inspect(text);\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n\t<p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>\n```\n\nNote: Always wrap text values in quotes when displaying them in UI to make empty strings visible.\n\n## $inspect(...).with\n\n`$inspect` returns a property `with`, which you can invoke with a callback, which will then be invoked instead of `console.log`. The first argument to the callback is either `\"init\"` or `\"update\"`; subsequent arguments are the values passed to `$inspect`.\n\n### Custom Console Logging\n\n**MANDATORY SYNTAX**: Template literals MUST use backticks (`), not quotes:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\n\t// Custom callback for tracking text changes\n\t$inspect(text).with((type, value) => {\n\t\tif (type === \"update\") {\n\t\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t\t}\n\t});\n</script>\n\n<input bind:value={text} />\n```\n\n**CRITICAL**: Always use backticks (`) for template literals:\n- ‚úÖ `console.log(\\`Text updated to: \"${value}\"\\`);`\n- ‚ùå `console.log(Text updated to: \"${value}\");` ‚Üê Missing backticks causes syntax error\n\nThe callback receives:\n- `type`: Either `\"init\"` (first call) or `\"update\"` (subsequent changes)  \n- `value`: The current value being inspected\n\n### Debugging Example\n\n```svelte\n<script>\n\tlet count = $state(0);\n\n\t$inspect(count).with((type, count) => {\n\t\tif (type === 'update') {\n\t\t\tdebugger; // or `console.trace`, or whatever you want\n\t\t}\n\t});\n</script>\n\n<button onclick={() => count++}>Increment</button>\n```\n\nA convenient way to find the origin of some change is to pass `console.trace` to `with`:\n\n```js\n$inspect(stuff).with(console.trace);\n```\n\n## $inspect.trace(...)\n\nThis rune, added in 5.14, causes the surrounding function to be _traced_ in development. Any time the function re-runs as part of an effect or a derived, information will be printed to the console about which pieces of reactive state caused the effect to fire.\n\n**üö® CRITICAL PLACEMENT WARNING**: `$inspect.trace` MUST be the first statement of a function body. Placing it anywhere else will cause a compile error.\n\n### ‚ùå WRONG - $inspect.trace not in first position\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t$effect(() => {\n\t\tconsole.log('[$effect] Input text changed to:', text); // ‚ùå Statement before $inspect.trace\n\t\t$inspect.trace(); // ‚ùå WRONG POSITION - will cause compile error\n\t});\n</script>\n```\n\n**Error**: `$inspect.trace(...)` must be the first statement of a function body\n\n### ‚úÖ CORRECT - $inspect.trace as first statement\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // ‚úÖ CORRECT - First statement\n\t\tconsole.log(`[$effect] Input text changed to: \"${text}\"`);\n\t});\n</script>\n```\n\n### Basic Usage in Effects\n\n**MANDATORY**: Always place `$inspect.trace` as the very first line inside function bodies:\n\n```svelte\n<script>\n\timport { doSomeWork } from './elsewhere';\n\n\t$effect(() => {\n\t\t$inspect.trace(); // ‚úÖ Must be first statement\n\t\tdoSomeWork();\n\t});\n</script>\n```\n\n### Text Input Tracking with Effects\n\nFor text input tracking, combine `$inspect.trace` with effects to monitor changes:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// ‚úÖ CORRECT - $inspect.trace as first statement\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // ‚úÖ Optional label, MUST be first\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\t});\n</script>\n\n<input bind:value={text} />\n```\n\n**CRITICAL SYNTAX RULES:**\n1. ‚úÖ `$inspect.trace()` MUST be the very first statement inside `$effect(() => {`  \n2. ‚ùå NEVER put any other code before `$inspect.trace()`\n3. ‚úÖ Use template literals with backticks: `` console.log(`text: \"${text}\"`) ``\n4. ‚ùå NEVER omit backticks: `console.log(text: \"${text}\")` ‚Üê SYNTAX ERROR\n\n`$inspect.trace` takes an optional first argument which will be used as the label.\n\n## Complete Working Example\n\nHere's a complete example that demonstrates all `$inspect` features with proper formatting:\n\n```svelte\n<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// 1. Basic $inspect usage\n\t$inspect(text);\n\t\n\t// 2. Using $inspect(...).with for custom logging\n\t$inspect(text).with((type, value) => {\n\t\tif (type === \"update\") {\n\t\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t\t}\n\t});\n\t\n\t// 3. MANDATORY: $effect with $inspect.trace AND console.log\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // MUST be first\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`); // REQUIRED\n\t});\n</script>\n\n<div>\n\t<label for=\"text-input\">Edit text:</label>\n\t<input \n\t\tdata-testid=\"text-input\" \n\t\tid=\"text-input\" \n\t\ttype=\"text\" \n\t\tbind:value={text} \n\t/>\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n\t<p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>\n```\n\n## MANDATORY Patterns for Tests\n\n**$effect with $inspect MUST include console.log:**\n```js\n$effect(() => {\n\t$inspect.trace(\"text-changes\"); // Always first statement\n\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`); // REQUIRED format\n});\n```\n\n**$inspect.with MUST check update type:**\n```js\n$inspect(text).with((type, value) => {\n\tif (type === \"update\") { // REQUIRED check\n\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t}\n});\n```\n\n## Key Points for Testing\n\n- Always wrap displayed text values in quotes to show empty strings clearly\n- Use specific console.log message formats for predictable testing\n- Include proper `data-testid` attributes for test targeting\n- The `$inspect(...).with` callback should check for `type === \"update\"` to avoid init logs\n- Console messages should include the exact format: `Text updated to: \"${value}\"`\n- Effect logging should follow the pattern: `The text is now: \"${text}\" (${text.length} characters)`\n\n### Critical Syntax Reminders\n\n**Template Literals**: Always use backticks (`) for template literals, not regular quotes:\n```javascript\n// ‚úÖ CORRECT\nconsole.log(`Text updated to: \"${value}\"`);\nconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\n// ‚ùå WRONG - missing backticks\nconsole.log(Text updated to: \"${value}\");\nconsole.log(The text is now: \"${text}\" (${text.length} characters));\n```\n\n**Input Element**: Always include all required attributes:\n```html\n<!-- ‚úÖ CORRECT -->\n<input \n    data-testid=\"text-input\" \n    id=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n/>\n\n<!-- ‚ùå WRONG - incomplete -->\n<input \n```\n\n# Svelte 5 Props Reference\n\n## Basic Props\n```svelte\n<!-- Parent -->\n<MyComponent adjective=\"cool\" />\n\n<!-- Child -->\n<script>\n  let { adjective } = $props(); // destructured (recommended)\n  let props = $props(); // or access via props.adjective\n</script>\n```\n\n## Fallbacks & Renaming\n```js\nlet { adjective = 'happy' } = $props(); // fallback value\nlet { super: trouper = 'default' } = $props(); // rename invalid identifier\nlet { a, b, ...others } = $props(); // rest props\n```\n\nCall $props() exactly once ‚Äî destructure all props in a single call or use a single props object to avoid the `props_duplicate` compile error.\n\nMinimal correct pattern:\n```svelte\n// correct ‚Äî single $props() call\nlet props = $props(); let { name = \"World\", count = 0, showDetails = false } = props;\n```\n\n## Prop Mutation Rules - CRITICAL\n\n**Props are READ-ONLY. Never assign to props directly:**\n\n‚ùå **FORBIDDEN - Will cause compilation errors:**\n```js\nlet { text } = $props();\ntext = \"new value\"; // ‚ùå COMPILE ERROR - props are read-only\n```\n\n‚úÖ **CORRECT - Use local state for modifications:**\n```js\nlet { text } = $props();\nlet localText = $state(text); // Copy to local state\n// Now modify localText: localText = \"new value\"; ‚úÖ\n```\n\n**Rules:**\n- ‚ùå Direct assignment: `prop = value` causes compilation errors\n- ‚ùå Direct mutation: `prop.property = value` (unless `$bindable`) \n- ‚úÖ Local state: `let local = $state(prop)` then modify `local`\n- ‚úÖ Temporary reassignment: only for local scope override\n- Regular objects: mutations have no effect\n- Reactive proxies: mutations work but trigger warnings\n- Fallback values: not reactive, mutations ignored\n\n## Type Safety\n```svelte\n<script lang=\"ts\">\n  interface Props { adjective: string; }\n  let { adjective }: Props = $props();\n  \n  // Or inline\n  let { adjective }: { adjective: string } = $props();\n  \n  // JSDoc\n  /** @type {{ adjective: string }} */\n  let { adjective } = $props();\n</script>\n```\n\n## Unique IDs\n```svelte\n<script>\n  const uid = $props.id(); // unique per component instance\n</script>\n<label for=\"{uid}-input\">Label</label>\n<input id=\"{uid}-input\" />\n```\n\n## Key Points\n- Props update reactively when parent changes\n- Use callbacks or `$bindable` for child-to-parent communication\n- Fallback values aren't reactive proxies\n- Type annotations recommended for discoverability\n- DOM element interfaces in `svelte/elements`\n\n# Svelte 5 Snippets\n```svelte\n<svelte:options runes={true} />\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n<style></style>\n```\n\n## CRITICAL SYNTAX RULES\n- ‚ùå NEVER use `return` keyword or JSX syntax `<span>`\n- ‚úÖ ALWAYS use pure Svelte template syntax: `{#snippet name(params)}...{/snippet}`\n- ‚ùå NOT: `const title = snippet((param) => { return <span>{param}</span>; })`\n- ‚úÖ CORRECT: `{#snippet title(param)}<span>{param}</span>{/snippet}`\n\n## Basic Syntax\n```svelte\n{#snippet name()}...{/snippet}\n{#snippet name(param1, param2)}...{/snippet}\n{@render name(args)}\n```\n\n## Working Example\n```svelte\n<svelte:options runes={true} />\n<script>\n\tconst items = [\"item1\", \"item2\"];\n</script>\n{#snippet title(text)}\n\t<span data-testid=\"title\">{text}</span>\n{/snippet}\n<ul>\n\t{#each items as item}\n\t\t<li>{@render title(item)}</li>\n\t{/each}\n</ul>\n```\n\n## Scope & Parameters\n- Snippets access lexical scope variables\n- Support default values & destructuring: `{#snippet name(param = default)}`\n- Can reference themselves (recursion) and siblings\n- No rest parameters support\n\n## Component Props\n**Explicit:** `<Table {header} {row} />`\n**Implicit:** Content inside component becomes props automatically\n**Children:** Non-snippet content becomes `children` snippet\n\n```svelte\n<!-- Implicit children -->\n<Button>click me</Button>\n\n<!-- Button.svelte -->\n<script>let { children } = $props();</script>\n<button>{@render children()}</button>\n\n<!-- Optional snippets -->\n{@render children?.()}\n{#if children}{@render children()}{:else}fallback{/if}\n```\n\n## TypeScript\n```svelte\n<script lang=\"ts\">\n\timport type { Snippet } from 'svelte';\n\tinterface Props {\n\t\tchildren: Snippet;\n\t\trow: Snippet<[DataType]>;\n\t}\n\tlet { children, row }: Props = $props();\n</script>\n```\n\n## Export (Svelte 5.5.0+)\n```svelte\n<script module>export { add };</script>\n{#snippet add(a, b)}{a} + {b} = {a + b}{/snippet}\n```\n\n## Key Facts\n- Replace Svelte 4 slots with more power/flexibility\n- Template constructs, not JS functions\n- Avoid props named `children` with implicit children\n- Use `createRawSnippet` API for advanced cases"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n<script>\n\tlet number = $state(5);\n\tlet doubled = $state(0);\n\n\t$effect(() => {\n\t\tdoubled = number * 2;\n\t});\n\t\n\tconst increment = () => number++;\n</script>\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0
      }
    ]
  },
  {
    "testName": "hello-world",
    "provider": "LMStudio",
    "modelId": "unsloth/Qwen3-Coder-30B-A3B-Instruct-GGUF",
    "numSamples": 1,
    "numCorrect": 1,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "# Svelte 5 Anti-Patterns\n\n## ‚ùå CRITICAL: Missing Content\n\n- **Do NOT generate empty components!** Always include the actual content requested\n- For \"Hello World\" tasks: MUST display \"Hello, World!\" text, not just structure\n- Template structure alone is insufficient - include the actual requirements\n\n## Event Handling\n\n- Do not use `on:click`, `on:submit`, or other Svelte 4-style event directives in Svelte 5. Use standard HTML event attributes like `onclick`, `onsubmit`, etc. instead.\n\n## Legacy Practices\n\n- Do not rely on implicit reactivity from Svelte 4 (`let` declarations, `$:` statements`).\n- Use modern Svelte 5 APIs instead of legacy APIs (e.g., prefer callback props over `createEventDispatcher`).\n\n## Build Tools\n\n- Use SvelteKit for new projects; do not opt for plain Vite, Rollup, or Webpack plugins.\n  - **Note:** SvelteKit is strongly recommended and centralizes best practices.\n\n## Runes Misuse\n\n### General\n\n- Do not use runes from Svelte 4 and prior (will cause compilation errors).\n- Do not import runes, they are part of the language\n\n### `$state`\n\n- Do not directly mutate `$state.raw` values (will not trigger reactive updates).\n- Do not directly export reassigned `$state` variables from `.svelte.js`/`.svelte.ts` modules (leads to non-reactive behavior for imports).\n- Do not mutate state you do not \"own\" (i.e., only mutate props marked `$bindable`).\n- For large collections, prefer using `$state.raw` for better performance, and always reassign the collection when making changes.\n- When updating state objects, avoid direct mutation of nested properties; instead, create new objects to ensure predictable state changes.\n\n### `$derived`\n\n- Do not change state (e.g., `count++`) directly within `$derived` expressions.\n- Avoid creating circular dependencies between derived values and state, as this can lead to infinite update loops.\n\n### State Management Patterns\n\n- Do not export state variables directly; instead, provide getter and setter functions to access and update state, preserving reactivity.\n- When exporting objects containing state, use getters and setters for stateful properties to maintain reactivity in consuming modules.\n\n### `$effect`\n\n- Do not update state directly within `$effect` functions (can lead to convoluted code and infinite loops).\n- Do not use `$effect` to synchronize state or derive new `$state` variables; use `$derived` for derivations.\n- Do not link mutually dependent input values using `$effect`; use `oninput` callbacks or function bindings instead.\n- Do not assume values read asynchronously (e.g., after `await` or in `setTimeout`) within an `$effect` are tracked as dependencies.\n- Do not expect an `$effect` to re-run when a property inside a mutated object changes if the object reference itself remains the same.\n\n## Component Communication\n\n- Do not directly mutate props unless they are explicitly declared as `$bindable()`.\n- Do not mutate a reactive state proxy passed as a prop in a child component (triggers `ownership_invalid_mutation` warning).\n- Do not mutate fallback values of non-bindable props (will not trigger updates).\n- Do not provide `undefined` to a `$bindable()` property that has a fallback value and is bound (results in a runtime error).\n\n### Common Props Mistakes (Svelte 5)\n\n- Always destructure needed props from `$props()` for reactivity; do not use the whole props object.\n- Always provide default values for optional props when destructuring.\n- Use `$bindable()` for two-way binding props.\n- Do not modify props directly; use callbacks to update parent state.\n- Use TypeScript types for complex props.\n\n## Debugging\n\n- Do not leave `$inspect` calls in production code (clutters code, even if they become no-ops).\n- Do not overuse `$inspect` (leads to overwhelming console output).\n- Do not use `$inspect` as a substitute for well-structured state management.\n\n## Reusable Reactive Logic\n\n- Do not export reassigned state directly from `.svelte.js`/`.svelte.ts` files (results in non-reactive behavior for external imports).\n\n## `bind:` Directive\n\n- Do not use reset buttons in forms too frequently (can lead to accidental data loss ‚Äî more of a UX warning).\n- Do not expect `DataTransfer` to be available for `bind:files` in server-side JavaScript runtimes (state should be left uninitialized for SSR).\n- Do not use dimension bindings (`bind:offsetWidth`, etc.) on elements with `display: inline` (their dimensions are not observable; change display style).\n- Do not expect dimension bindings to update if an element's size changes solely due to CSS transformations.\n- Do not use the `bind:group` directive across different components (only works for inputs within the same Svelte component).\n- Do not provide `undefined` to a bound `$bindable()` property that has a fallback value (results in a runtime error).\n\n## Asynchronous Operations (`{#await...}`)\n\n- Do not expect any branch other than the pending branch of an `{#await}` block to render during server-side rendering (SSR).\n\n## Keyed Blocks (`{#key...}`)\n\n- Do not use a constantly changing key value in `{#key}` blocks (leads to excessive DOM manipulation and potential performance degradation).\n\n## Attributes\n\n- Do not declare custom √üproperties or attributes that start with `on`.\n\n\n# Svelte 5 Best Practices\n\n## üöÄ Essential Setup & Syntax\n\n### Component Structure\n- **MANDATORY**: Always start with `<svelte:options runes={true} />` at the top\n- Use `<script>` for component-specific logic\n- Use `<style>` for scoped CSS\n- Maintain clear data flow and effective architecture for maintainability\n\n- When a task requires exact output (e.g., Hello-World) render the literal text `Hello, World!` inside an element with `data-testid=\"greeting\"` (no comments or computed empty strings).\n\n### Event Handling - CRITICAL CHANGE FROM SVELTE 4\n- ‚úÖ Use standard HTML attributes for event handling (`onclick`, `onsubmit`, etc.)\n- ‚ùå Do NOT use Svelte 4 syntax: `on:click`, `on:submit` will cause errors\n- For event modifiers, use wrapper functions instead of the pipe syntax from Svelte 4\n- For multiple handlers, combine them into a single function\n- Keep event handlers simple, moving complex logic to separate functions\n- Remember that event names are lowercase in HTML (`onclick`, not `onClick`)\n\n### Template Syntax Basics\n- Use `{#if expression}` for conditionals\n- Use `{#each expression as item}` for lists\n- Use `{#key value}` to force re-creation of content\n- Use `{#await promise}` for managing Promise states\n- Use `{variable}` for displaying values\n- Use snippets for reusable markup chunks\n\n## üß† Runes\n\n### `$state` - Reactive Variables\n\n- ‚úÖ Use `$state` for reactive UI state: `let count = $state(0)`\n- ‚úÖ Update `$state` variables directly (they behave like regular JavaScript variables)\n- ‚ùå NEVER import runes: `import { $state } from 'svelte'` causes parse errors\n- Use arrow functions for class methods relying on `this` with reactive state\n- Use `$state.raw` for large arrays/objects where deep reactivity isn't needed\n- Use `$state.snapshot` to get a non-reactive copy of state for external libraries\n- Pass getter functions (e.g., `() => a`) to functions needing the current reactive value of `$state` variables\n- When sharing `$state` from `.svelte.js`/`.svelte.ts` files:\n  - Export an object whose properties are mutated\n  - Or export getter functions\n\n### `$derived` - Computed Values\n\n- ‚úÖ Use `$derived` for computed values that are free of side effects: `let doubled = $derived(count * 2)`\n- ‚ùå NEVER import: `import { $derived } from 'svelte'` causes parse errors\n- Use `$derived.by` for complex derivation logic\n- Derived values can be temporarily reassigned for optimistic UI updates\n\n### `$effect` - Side Effects\n\n- ‚úÖ Use `$effect` for side effects and external interactions (e.g., third-party libraries, API calls, analytics, DOM manipulation)\n- ‚ùå NEVER import: `import { $effect } from 'svelte'` causes parse errors\n- Return a teardown function from `$effect` for cleanup (e.g., clearing intervals)\n- Use `$effect.pre` for logic that must run before DOM updates\n- Use `$effect.tracking` to check if code is running in a tracking context\n- Use `$effect.root` for creating non-tracked scopes with manual cleanup for nested effects\n- ‚ùå Do not update state inside effects - use `$derived` for derivations instead\n\n## üîÑ Component Communication & Props\n\n- **CRITICAL**: Props are READ-ONLY. Never assign directly to props\n- Destructure props directly from `$props()` for clarity: `let { name } = $props()`\n- Declare fallback values during destructuring: `let { name = \"default\" } = $props()`\n- Rename props during destructuring if they are invalid JavaScript identifiers\n- Use rest properties (`...others`) to capture remaining props\n- Add type safety using TypeScript interfaces or JSDoc\n- Use `$props.id()` (Svelte 5.20.0+) for unique, consistent component instance IDs\n- Use callback properties for child-to-parent communication (replaces `createEventDispatcher`)\n\n## üîó `bind:` Directive (Two-Way Data Binding)\n\n- Use `bind:` for two-way data flow from child to parent\n- Use shorthand `bind:property` when names match\n- Use function bindings (get/set) for validation or transformation (Svelte 5.9.0+)\n- For readonly bindings, set the get function to `null`\n- Access `bind:this` variables inside `$effect` or event handlers (they are undefined until mount)\n- Mark bindable properties with `$bindable()`\n- Provide fallback values for `$bindable()` properties\n\n## üêû Debugging (`$inspect`)\n\n- Use `$inspect` exclusively for development debugging; it tracks reactive state deeply.\n- Use `$inspect.with()` for custom debugging actions (e.g., `debugger`, `console.trace`).\n- Use `$inspect.trace()` (Svelte 5.14+) to trace function re-runs and identify causes.\n\n## ‚ôªÔ∏è Reusable Logic & State\n\n- Use `.svelte.js` and `.svelte.ts` files to create reusable reactive logic and share reactive state using runes.\n- Keep state logic separate from the wire components.\n\n## üß± Component Structure\n\n- Use `<script>` for component-specific logic.\n- Use `<style>` for scoped CSS.\n- Maintain clear data flow and effective architecture for maintainability.\n\n## üîó `bind:` Directive (Two-Way Data Binding)\n\n- Use `bind:` for two-way data flow from child to parent.\n- Use shorthand `bind:property` when names match.\n- Use function bindings (get/set) for validation or transformation (Svelte 5.9.0+).\n- For readonly bindings, set the get function to `null`.\n- Access `bind:this` variables inside `$effect` or event handlers (they are undefined until mount).\n- Mark bindable properties with `$bindable()`.\n- Provide fallback values for `$bindable()` properties.\n\n## üß© Template Syntax\n\n- Use `{#if expression}` for conditionals.\n- Use `{#each expression as item}` for lists.\n- Use `{#key value}` to force re-creation of content.\n- Use `{#await promise}` for managing Promise states.\n- Use snippets for reusable markup chunks.\n\n## üéâ Event Handling\n\n- Use standard HTML attributes for event handling (onclick, onsubmit, etc.)\n- For event modifiers, use wrapper functions instead of the pipe syntax from Svelte 4\n- For multiple handlers, combine them into a single function\n- Keep event handlers simple, moving complex logic to separate functions\n- Remember that event names are lowercase in HTML (onclick, not onClick)Event Handing\n\n## Component Events\n\n- Use callback props instead of event dispatching for component communication\n- Name callback props with an \"on\" prefix (e.g., onSubmit, onChange)\n- Pass data as an object to allow for future extensibility\n- For multiple events, use multiple callback props\n- Consider using TypeScript to type your callback props\n\n## Snippets\n\n- Use snippets to reduce duplication in your templates\n- Snippets can be passed as props to components\n- Snippets have lexical scoping rules - they are only visible in the same scope they are defined in\n- Use parameters to make snippets more flexible\n- Snippets can reference other snippets and even themselves (for recursion)\n\n## üè™ Store\n\n- Use stores only for:\n  - Interoperability with external libraries.\n  - Complex async data streams.\n  - Large apps.\n  - Scenarios needing explicit subscribe/unsubscribe behavior.\n\n## üß† Context\n\n- Store reactive state in context for child component access.\n- Wrap `setContext` and `getContext` in helper functions for type safety.\n- Context can and should be used for small to medium-sized applications to share state between components. It is also ideal for shared state, especially in SSR, as it avoids cross-request data leakage.\n\n## üß† Context\n\n- Store reactive state in context for child component access.\n- Wrap `setContext` and `getContext` in helper functions for type safety.\n- Context is ideal for shared state, especially in SSR, as it avoids cross-request data leakage.\n\n## üß™ Testing\n\n- Use **Vitest** for unit and integration testing.\n- Adjust `vite.config.js` to use browser entry points or alias backend libraries.\n- Include `.svelte` in test filenames for rune processing.\n- Wrap `$effects` in `$effect.root` during tests.\n- Use `flushSync` to run pending effects synchronously.\n- Use https://testing-library.com/docs/svelte-testing-library/intro.\n- Use **Playwright** for E2E testing.\n\n## üì¶ Packages\n\n- Explore new/popular packages at https://www.sveltesociety.dev/packages.\n\n## üîê Security\n\n- To prevent XSS attacks:\n  - Escape strings passed to `{@html ...}`.\n  - Ensure content is from trusted sources.\n  - The expression must be valid standalone HTML.\n\n## üß± Error Boundaries\n\n- Use `onerror` to integrate with error reporting services.\n- Wrap flaky components in `<svelte:boundary>` to isolate errors.\n- `<svelte:boundary>` requires a failed snippet or `onerror` function.\n- It does **not** catch errors outside rendering (e.g., event handlers, `setTimeout`, async work).\n\n\n# Svelte 5 $derived - LLM Context Guide\n\n**CRITICAL: $derived is built-in - NO imports needed. Importing causes parse errors.**\n\n## Syntax Rules\n- ‚úÖ `let x = $derived(expr)` - simple expressions  \n- ‚úÖ `let x = $derived.by(() => {...})` - complex logic\n- ‚úÖ `onclick={handler}` - NOT `on:click`\n- ‚úÖ `<svelte:options runes={true} />`\n- ‚ùå NEVER `import { $derived } from 'svelte/runes'`\n\n## Verified Working Template\n```svelte\n<svelte:options runes={true} />\n<script>\n\tlet count = $state(0);\n\tlet doubled = $derived(count * 2);\n\tconst increment = () => count++;\n</script>\n<div>\n\t<p data-testid=\"count-value\">Count: {count}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>\n```\n\n## $derived.by Example\n```svelte\n<script>\n\tlet items = $state([1, 2, 3]);\n\tlet sum = $derived.by(() => items.reduce((a, b) => a + b, 0));\n\t\n\t// ‚ùå INVALID - Cannot destructure $derived.by() return\n\t// const { wordCount, charCount } = $derived.by(() => ({ ... }));\n\t\n\t// ‚úÖ CORRECT - Store return value first\n\tlet stats = $derived.by(() => {\n\t\tconst words = text.split(' ').length;\n\t\tconst chars = text.length;\n\t\treturn { wordCount: words, charCount: chars, isLong: chars > 50 };\n\t});\n\t// Then access: stats.wordCount, stats.charCount, stats.isLong\n</script>\n```\n\n## Key Behaviors\n- Auto-updates when dependencies change\n- Pure expressions only (no mutations)\n- Push-pull: dependencies notify, values calculate on read\n- Can destructure: `let { a, b } = $derived(obj())` - ONLY simple $derived\n- **CRITICAL**: Cannot destructure `$derived.by()` - store return value first\n- Overridable since 5.25+\n\n# Svelte 5 Each Blocks\n\nIterate over arrays, array-like objects, or iterables (Map, Set) using `{#each}` blocks. Supports destructuring and optional keys for efficient DOM updates.\n\n## Basic Syntax\n\n```svelte\n{#each expression as name}...{/each}\n{#each expression as name, index}...{/each}\n```\n\n```svelte\n<ul>\n\t{#each items as item}\n\t\t<li>{item.name} x {item.qty}</li>\n\t{/each}\n</ul>\n```\n\n## Keyed Each Blocks\n\nUse unique keys to optimize DOM updates when data changes:\n\n```svelte\n{#each expression as name (key)}...{/each}\n```\n\n```svelte\n{#each items as item (item.id)}\n\t<li>{item.name} x {item.qty}</li>\n{/each}\n```\n\nKeys should be strings or numbers for identity persistence.\n\n## Destructuring\n\n```svelte\n{#each items as { id, name, qty }, i (id)}\n\t<li>{i + 1}: {name} x {qty}</li>\n{/each}\n```\n\n## Rendering N Times\n\n```svelte\n{#each { length: 8 }, index}\n\t<div>Item {index}</div>\n{/each}\n```\n\n## Else Clause\n\n```svelte\n{#each todos as todo}\n\t<p>{todo.text}</p>\n{:else}\n\t<p>No tasks today!</p>\n{/each}\n\n# Svelte 5 ‚Äî $effect (compressed)\n\nPurpose: browser-only rune for side effects after mount and after state updates. Do not use for derived state.\n\nCritical rules\n- Runes are built-in; DO NOT import `$state`, `$effect`, etc. (e.g. `import { $effect } from 'svelte/runes'` causes parse errors ‚Äî \"The $ prefix is reserved\").\n- Enable runes with `<svelte:options runes={true} />`.\n- Use `onclick={handler}` (Svelte 5), not `on:click={...}`.\n\nBehavior\n- Runs after component mount and in a microtask after state changes.\n- Dependencies: automatically tracked ‚Äî any `$state`, `$derived`, `$props` read synchronously inside the effect become dependencies.\n- Conditional reads are tracked only when executed (dependency set is recalculated each run).\n- Return a teardown function to cleanup; teardown runs before re-run and on destroy.\n\nSpecial variants\n- `$effect.pre(fn)`: runs before DOM update (useful for measuring DOM & scheduling `tick()`).\n- `$effect.root(fn)`: create a non-tracked scope that doesn't auto-cleanup; returns a `destroy()` to call manually.\n\nWhen to use\n- DOM manipulation (canvas), third-party libs, event listeners, timers, network requests.\n\nWhen NOT to use\n- State synchronization. Use `$derived(...)` for derived/computed state.\n\nCanonical minimal snippets (copy-paste safe)\n\nEnable runes:\n<svelte:options runes={true} />\n\nBasic effect (derived incorrectly shown only for demonstration ‚Äî prefer `$derived` in real code):\n```svelte\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n```\n\nCleanup (interval):\n```svelte\n<script>\n  let count = $state(0);\n  let milliseconds = $state(1000);\n\n  $effect(() => {\n    const interval = setInterval(() => count += 1, milliseconds);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\nPre-effect (before DOM update):\n```svelte\n<script>\n  import { tick } from 'svelte';\n  let div = $state();\n  let messages = $state([]);\n\n  $effect.pre(() => {\n    if (!div) return;\n    messages.length; // track\n    if (div.offsetHeight + div.scrollTop > div.scrollHeight - 20) {\n      tick().then(() => div.scrollTo(0, div.scrollHeight));\n    }\n  });\n</script>\n```\n\nroot scope:\n```js\nconst destroy = $effect.root(() => {\n  $effect(() => { /* setup */ });\n  return () => { /* cleanup */ };\n});\n// later: destroy();\n```\n\nEdge cases / pitfalls\n- Invalid imports break parsing ‚Äî never import `$` runes.\n- Mutating an object vs reassigning: read specific properties to track them (mutating top-level object may not retrigger effects that only read the object reference).\n- Conditional reads: a value read only inside an `if` is only a dependency when that branch executed.\n- Use `$effect.pre` when you must measure DOM before updates.\n- `$effect.root` requires manual cleanup (not auto-cleaned).\n\nTesting & best-practices\n- Include `data-testid` in examples for tests.\n- Prefer `$derived` for computed values; `$effect` only for side effects.\n\nOne-line summary: `$effect` = built-in Svelte 5 side-effect rune; no imports; auto-deps; return teardown for cleanup; use `$derived` for pure derived state.\n\n# Svelte 5 $inspect Rune - Dense Reference\n\n**Dev-only reactive debugger. Re-runs on reactive state changes. Template literals MUST use backticks (`)**\n\n## Core Implementation\n```svelte\n<svelte:options runes={true} />\n<script>\n\tlet text = $state(\"Hello world\");\n\t$inspect(text); // Basic usage\n\t$inspect(text).with((type, value) => { // Custom logging\n\t\tif (type === \"update\") console.log(`Text updated to: \"${value}\"`);\n\t});\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // MUST be first statement\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\t});\n</script>\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n</div>\n```\n\n## Basic Usage\n\nThe simplest form of `$inspect` logs values to the console whenever they change:\n\n```svelte\n<script>\n\tlet count = $state(0);\n\tlet message = $state('hello');\n\n\t$inspect(count, message); // will console.log when `count` or `message` change\n</script>\n\n<button onclick={() => count++}>Increment</button>\n<input bind:value={message} />\n```\n\n## Text Input Example with Quotes\n\nWhen working with text inputs, you often want to display the value with quotes to show empty strings clearly:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// Basic $inspect usage\n\t$inspect(text);\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n\t<p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>\n```\n\nNote: Always wrap text values in quotes when displaying them in UI to make empty strings visible.\n\n## $inspect(...).with\n\n`$inspect` returns a property `with`, which you can invoke with a callback, which will then be invoked instead of `console.log`. The first argument to the callback is either `\"init\"` or `\"update\"`; subsequent arguments are the values passed to `$inspect`.\n\n### Custom Console Logging\n\n**MANDATORY SYNTAX**: Template literals MUST use backticks (`), not quotes:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\n\t// Custom callback for tracking text changes\n\t$inspect(text).with((type, value) => {\n\t\tif (type === \"update\") {\n\t\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t\t}\n\t});\n</script>\n\n<input bind:value={text} />\n```\n\n**CRITICAL**: Always use backticks (`) for template literals:\n- ‚úÖ `console.log(\\`Text updated to: \"${value}\"\\`);`\n- ‚ùå `console.log(Text updated to: \"${value}\");` ‚Üê Missing backticks causes syntax error\n\nThe callback receives:\n- `type`: Either `\"init\"` (first call) or `\"update\"` (subsequent changes)  \n- `value`: The current value being inspected\n\n### Debugging Example\n\n```svelte\n<script>\n\tlet count = $state(0);\n\n\t$inspect(count).with((type, count) => {\n\t\tif (type === 'update') {\n\t\t\tdebugger; // or `console.trace`, or whatever you want\n\t\t}\n\t});\n</script>\n\n<button onclick={() => count++}>Increment</button>\n```\n\nA convenient way to find the origin of some change is to pass `console.trace` to `with`:\n\n```js\n$inspect(stuff).with(console.trace);\n```\n\n## $inspect.trace(...)\n\nThis rune, added in 5.14, causes the surrounding function to be _traced_ in development. Any time the function re-runs as part of an effect or a derived, information will be printed to the console about which pieces of reactive state caused the effect to fire.\n\n**üö® CRITICAL PLACEMENT WARNING**: `$inspect.trace` MUST be the first statement of a function body. Placing it anywhere else will cause a compile error.\n\n### ‚ùå WRONG - $inspect.trace not in first position\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t$effect(() => {\n\t\tconsole.log('[$effect] Input text changed to:', text); // ‚ùå Statement before $inspect.trace\n\t\t$inspect.trace(); // ‚ùå WRONG POSITION - will cause compile error\n\t});\n</script>\n```\n\n**Error**: `$inspect.trace(...)` must be the first statement of a function body\n\n### ‚úÖ CORRECT - $inspect.trace as first statement\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // ‚úÖ CORRECT - First statement\n\t\tconsole.log(`[$effect] Input text changed to: \"${text}\"`);\n\t});\n</script>\n```\n\n### Basic Usage in Effects\n\n**MANDATORY**: Always place `$inspect.trace` as the very first line inside function bodies:\n\n```svelte\n<script>\n\timport { doSomeWork } from './elsewhere';\n\n\t$effect(() => {\n\t\t$inspect.trace(); // ‚úÖ Must be first statement\n\t\tdoSomeWork();\n\t});\n</script>\n```\n\n### Text Input Tracking with Effects\n\nFor text input tracking, combine `$inspect.trace` with effects to monitor changes:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// ‚úÖ CORRECT - $inspect.trace as first statement\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // ‚úÖ Optional label, MUST be first\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\t});\n</script>\n\n<input bind:value={text} />\n```\n\n**CRITICAL SYNTAX RULES:**\n1. ‚úÖ `$inspect.trace()` MUST be the very first statement inside `$effect(() => {`  \n2. ‚ùå NEVER put any other code before `$inspect.trace()`\n3. ‚úÖ Use template literals with backticks: `` console.log(`text: \"${text}\"`) ``\n4. ‚ùå NEVER omit backticks: `console.log(text: \"${text}\")` ‚Üê SYNTAX ERROR\n\n`$inspect.trace` takes an optional first argument which will be used as the label.\n\n## Complete Working Example\n\nHere's a complete example that demonstrates all `$inspect` features with proper formatting:\n\n```svelte\n<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// 1. Basic $inspect usage\n\t$inspect(text);\n\t\n\t// 2. Using $inspect(...).with for custom logging\n\t$inspect(text).with((type, value) => {\n\t\tif (type === \"update\") {\n\t\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t\t}\n\t});\n\t\n\t// 3. MANDATORY: $effect with $inspect.trace AND console.log\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // MUST be first\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`); // REQUIRED\n\t});\n</script>\n\n<div>\n\t<label for=\"text-input\">Edit text:</label>\n\t<input \n\t\tdata-testid=\"text-input\" \n\t\tid=\"text-input\" \n\t\ttype=\"text\" \n\t\tbind:value={text} \n\t/>\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n\t<p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>\n```\n\n## MANDATORY Patterns for Tests\n\n**$effect with $inspect MUST include console.log:**\n```js\n$effect(() => {\n\t$inspect.trace(\"text-changes\"); // Always first statement\n\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`); // REQUIRED format\n});\n```\n\n**$inspect.with MUST check update type:**\n```js\n$inspect(text).with((type, value) => {\n\tif (type === \"update\") { // REQUIRED check\n\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t}\n});\n```\n\n## Key Points for Testing\n\n- Always wrap displayed text values in quotes to show empty strings clearly\n- Use specific console.log message formats for predictable testing\n- Include proper `data-testid` attributes for test targeting\n- The `$inspect(...).with` callback should check for `type === \"update\"` to avoid init logs\n- Console messages should include the exact format: `Text updated to: \"${value}\"`\n- Effect logging should follow the pattern: `The text is now: \"${text}\" (${text.length} characters)`\n\n### Critical Syntax Reminders\n\n**Template Literals**: Always use backticks (`) for template literals, not regular quotes:\n```javascript\n// ‚úÖ CORRECT\nconsole.log(`Text updated to: \"${value}\"`);\nconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\n// ‚ùå WRONG - missing backticks\nconsole.log(Text updated to: \"${value}\");\nconsole.log(The text is now: \"${text}\" (${text.length} characters));\n```\n\n**Input Element**: Always include all required attributes:\n```html\n<!-- ‚úÖ CORRECT -->\n<input \n    data-testid=\"text-input\" \n    id=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n/>\n\n<!-- ‚ùå WRONG - incomplete -->\n<input \n```\n\n# Svelte 5 Props Reference\n\n## Basic Props\n```svelte\n<!-- Parent -->\n<MyComponent adjective=\"cool\" />\n\n<!-- Child -->\n<script>\n  let { adjective } = $props(); // destructured (recommended)\n  let props = $props(); // or access via props.adjective\n</script>\n```\n\n## Fallbacks & Renaming\n```js\nlet { adjective = 'happy' } = $props(); // fallback value\nlet { super: trouper = 'default' } = $props(); // rename invalid identifier\nlet { a, b, ...others } = $props(); // rest props\n```\n\nCall $props() exactly once ‚Äî destructure all props in a single call or use a single props object to avoid the `props_duplicate` compile error.\n\nMinimal correct pattern:\n```svelte\n// correct ‚Äî single $props() call\nlet props = $props(); let { name = \"World\", count = 0, showDetails = false } = props;\n```\n\n## Prop Mutation Rules - CRITICAL\n\n**Props are READ-ONLY. Never assign to props directly:**\n\n‚ùå **FORBIDDEN - Will cause compilation errors:**\n```js\nlet { text } = $props();\ntext = \"new value\"; // ‚ùå COMPILE ERROR - props are read-only\n```\n\n‚úÖ **CORRECT - Use local state for modifications:**\n```js\nlet { text } = $props();\nlet localText = $state(text); // Copy to local state\n// Now modify localText: localText = \"new value\"; ‚úÖ\n```\n\n**Rules:**\n- ‚ùå Direct assignment: `prop = value` causes compilation errors\n- ‚ùå Direct mutation: `prop.property = value` (unless `$bindable`) \n- ‚úÖ Local state: `let local = $state(prop)` then modify `local`\n- ‚úÖ Temporary reassignment: only for local scope override\n- Regular objects: mutations have no effect\n- Reactive proxies: mutations work but trigger warnings\n- Fallback values: not reactive, mutations ignored\n\n## Type Safety\n```svelte\n<script lang=\"ts\">\n  interface Props { adjective: string; }\n  let { adjective }: Props = $props();\n  \n  // Or inline\n  let { adjective }: { adjective: string } = $props();\n  \n  // JSDoc\n  /** @type {{ adjective: string }} */\n  let { adjective } = $props();\n</script>\n```\n\n## Unique IDs\n```svelte\n<script>\n  const uid = $props.id(); // unique per component instance\n</script>\n<label for=\"{uid}-input\">Label</label>\n<input id=\"{uid}-input\" />\n```\n\n## Key Points\n- Props update reactively when parent changes\n- Use callbacks or `$bindable` for child-to-parent communication\n- Fallback values aren't reactive proxies\n- Type annotations recommended for discoverability\n- DOM element interfaces in `svelte/elements`\n\n# Svelte 5 Snippets\n```svelte\n<svelte:options runes={true} />\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n<style></style>\n```\n\n## CRITICAL SYNTAX RULES\n- ‚ùå NEVER use `return` keyword or JSX syntax `<span>`\n- ‚úÖ ALWAYS use pure Svelte template syntax: `{#snippet name(params)}...{/snippet}`\n- ‚ùå NOT: `const title = snippet((param) => { return <span>{param}</span>; })`\n- ‚úÖ CORRECT: `{#snippet title(param)}<span>{param}</span>{/snippet}`\n\n## Basic Syntax\n```svelte\n{#snippet name()}...{/snippet}\n{#snippet name(param1, param2)}...{/snippet}\n{@render name(args)}\n```\n\n## Working Example\n```svelte\n<svelte:options runes={true} />\n<script>\n\tconst items = [\"item1\", \"item2\"];\n</script>\n{#snippet title(text)}\n\t<span data-testid=\"title\">{text}</span>\n{/snippet}\n<ul>\n\t{#each items as item}\n\t\t<li>{@render title(item)}</li>\n\t{/each}\n</ul>\n```\n\n## Scope & Parameters\n- Snippets access lexical scope variables\n- Support default values & destructuring: `{#snippet name(param = default)}`\n- Can reference themselves (recursion) and siblings\n- No rest parameters support\n\n## Component Props\n**Explicit:** `<Table {header} {row} />`\n**Implicit:** Content inside component becomes props automatically\n**Children:** Non-snippet content becomes `children` snippet\n\n```svelte\n<!-- Implicit children -->\n<Button>click me</Button>\n\n<!-- Button.svelte -->\n<script>let { children } = $props();</script>\n<button>{@render children()}</button>\n\n<!-- Optional snippets -->\n{@render children?.()}\n{#if children}{@render children()}{:else}fallback{/if}\n```\n\n## TypeScript\n```svelte\n<script lang=\"ts\">\n\timport type { Snippet } from 'svelte';\n\tinterface Props {\n\t\tchildren: Snippet;\n\t\trow: Snippet<[DataType]>;\n\t}\n\tlet { children, row }: Props = $props();\n</script>\n```\n\n## Export (Svelte 5.5.0+)\n```svelte\n<script module>export { add };</script>\n{#snippet add(a, b)}{a} + {b} = {a + b}{/snippet}\n```\n\n## Key Facts\n- Replace Svelte 4 slots with more power/flexibility\n- Template constructs, not JS functions\n- Avoid props named `children` with implicit children\n- Use `createRawSnippet` API for advanced cases"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n<script>\n\tlet greeting = \"Hello, World!\";\n</script>\n<div data-testid=\"greeting\" class=\"greeting\">{greeting}</div>\n<style>\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0
      }
    ]
  },
  {
    "testName": "inspect",
    "provider": "LMStudio",
    "modelId": "unsloth/Qwen3-Coder-30B-A3B-Instruct-GGUF",
    "numSamples": 1,
    "numCorrect": 1,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "# Svelte 5 Anti-Patterns\n\n## ‚ùå CRITICAL: Missing Content\n\n- **Do NOT generate empty components!** Always include the actual content requested\n- For \"Hello World\" tasks: MUST display \"Hello, World!\" text, not just structure\n- Template structure alone is insufficient - include the actual requirements\n\n## Event Handling\n\n- Do not use `on:click`, `on:submit`, or other Svelte 4-style event directives in Svelte 5. Use standard HTML event attributes like `onclick`, `onsubmit`, etc. instead.\n\n## Legacy Practices\n\n- Do not rely on implicit reactivity from Svelte 4 (`let` declarations, `$:` statements`).\n- Use modern Svelte 5 APIs instead of legacy APIs (e.g., prefer callback props over `createEventDispatcher`).\n\n## Build Tools\n\n- Use SvelteKit for new projects; do not opt for plain Vite, Rollup, or Webpack plugins.\n  - **Note:** SvelteKit is strongly recommended and centralizes best practices.\n\n## Runes Misuse\n\n### General\n\n- Do not use runes from Svelte 4 and prior (will cause compilation errors).\n- Do not import runes, they are part of the language\n\n### `$state`\n\n- Do not directly mutate `$state.raw` values (will not trigger reactive updates).\n- Do not directly export reassigned `$state` variables from `.svelte.js`/`.svelte.ts` modules (leads to non-reactive behavior for imports).\n- Do not mutate state you do not \"own\" (i.e., only mutate props marked `$bindable`).\n- For large collections, prefer using `$state.raw` for better performance, and always reassign the collection when making changes.\n- When updating state objects, avoid direct mutation of nested properties; instead, create new objects to ensure predictable state changes.\n\n### `$derived`\n\n- Do not change state (e.g., `count++`) directly within `$derived` expressions.\n- Avoid creating circular dependencies between derived values and state, as this can lead to infinite update loops.\n\n### State Management Patterns\n\n- Do not export state variables directly; instead, provide getter and setter functions to access and update state, preserving reactivity.\n- When exporting objects containing state, use getters and setters for stateful properties to maintain reactivity in consuming modules.\n\n### `$effect`\n\n- Do not update state directly within `$effect` functions (can lead to convoluted code and infinite loops).\n- Do not use `$effect` to synchronize state or derive new `$state` variables; use `$derived` for derivations.\n- Do not link mutually dependent input values using `$effect`; use `oninput` callbacks or function bindings instead.\n- Do not assume values read asynchronously (e.g., after `await` or in `setTimeout`) within an `$effect` are tracked as dependencies.\n- Do not expect an `$effect` to re-run when a property inside a mutated object changes if the object reference itself remains the same.\n\n## Component Communication\n\n- Do not directly mutate props unless they are explicitly declared as `$bindable()`.\n- Do not mutate a reactive state proxy passed as a prop in a child component (triggers `ownership_invalid_mutation` warning).\n- Do not mutate fallback values of non-bindable props (will not trigger updates).\n- Do not provide `undefined` to a `$bindable()` property that has a fallback value and is bound (results in a runtime error).\n\n### Common Props Mistakes (Svelte 5)\n\n- Always destructure needed props from `$props()` for reactivity; do not use the whole props object.\n- Always provide default values for optional props when destructuring.\n- Use `$bindable()` for two-way binding props.\n- Do not modify props directly; use callbacks to update parent state.\n- Use TypeScript types for complex props.\n\n## Debugging\n\n- Do not leave `$inspect` calls in production code (clutters code, even if they become no-ops).\n- Do not overuse `$inspect` (leads to overwhelming console output).\n- Do not use `$inspect` as a substitute for well-structured state management.\n\n## Reusable Reactive Logic\n\n- Do not export reassigned state directly from `.svelte.js`/`.svelte.ts` files (results in non-reactive behavior for external imports).\n\n## `bind:` Directive\n\n- Do not use reset buttons in forms too frequently (can lead to accidental data loss ‚Äî more of a UX warning).\n- Do not expect `DataTransfer` to be available for `bind:files` in server-side JavaScript runtimes (state should be left uninitialized for SSR).\n- Do not use dimension bindings (`bind:offsetWidth`, etc.) on elements with `display: inline` (their dimensions are not observable; change display style).\n- Do not expect dimension bindings to update if an element's size changes solely due to CSS transformations.\n- Do not use the `bind:group` directive across different components (only works for inputs within the same Svelte component).\n- Do not provide `undefined` to a bound `$bindable()` property that has a fallback value (results in a runtime error).\n\n## Asynchronous Operations (`{#await...}`)\n\n- Do not expect any branch other than the pending branch of an `{#await}` block to render during server-side rendering (SSR).\n\n## Keyed Blocks (`{#key...}`)\n\n- Do not use a constantly changing key value in `{#key}` blocks (leads to excessive DOM manipulation and potential performance degradation).\n\n## Attributes\n\n- Do not declare custom √üproperties or attributes that start with `on`.\n\n\n# Svelte 5 Best Practices\n\n## üöÄ Essential Setup & Syntax\n\n### Component Structure\n- **MANDATORY**: Always start with `<svelte:options runes={true} />` at the top\n- Use `<script>` for component-specific logic\n- Use `<style>` for scoped CSS\n- Maintain clear data flow and effective architecture for maintainability\n\n- When a task requires exact output (e.g., Hello-World) render the literal text `Hello, World!` inside an element with `data-testid=\"greeting\"` (no comments or computed empty strings).\n\n### Event Handling - CRITICAL CHANGE FROM SVELTE 4\n- ‚úÖ Use standard HTML attributes for event handling (`onclick`, `onsubmit`, etc.)\n- ‚ùå Do NOT use Svelte 4 syntax: `on:click`, `on:submit` will cause errors\n- For event modifiers, use wrapper functions instead of the pipe syntax from Svelte 4\n- For multiple handlers, combine them into a single function\n- Keep event handlers simple, moving complex logic to separate functions\n- Remember that event names are lowercase in HTML (`onclick`, not `onClick`)\n\n### Template Syntax Basics\n- Use `{#if expression}` for conditionals\n- Use `{#each expression as item}` for lists\n- Use `{#key value}` to force re-creation of content\n- Use `{#await promise}` for managing Promise states\n- Use `{variable}` for displaying values\n- Use snippets for reusable markup chunks\n\n## üß† Runes\n\n### `$state` - Reactive Variables\n\n- ‚úÖ Use `$state` for reactive UI state: `let count = $state(0)`\n- ‚úÖ Update `$state` variables directly (they behave like regular JavaScript variables)\n- ‚ùå NEVER import runes: `import { $state } from 'svelte'` causes parse errors\n- Use arrow functions for class methods relying on `this` with reactive state\n- Use `$state.raw` for large arrays/objects where deep reactivity isn't needed\n- Use `$state.snapshot` to get a non-reactive copy of state for external libraries\n- Pass getter functions (e.g., `() => a`) to functions needing the current reactive value of `$state` variables\n- When sharing `$state` from `.svelte.js`/`.svelte.ts` files:\n  - Export an object whose properties are mutated\n  - Or export getter functions\n\n### `$derived` - Computed Values\n\n- ‚úÖ Use `$derived` for computed values that are free of side effects: `let doubled = $derived(count * 2)`\n- ‚ùå NEVER import: `import { $derived } from 'svelte'` causes parse errors\n- Use `$derived.by` for complex derivation logic\n- Derived values can be temporarily reassigned for optimistic UI updates\n\n### `$effect` - Side Effects\n\n- ‚úÖ Use `$effect` for side effects and external interactions (e.g., third-party libraries, API calls, analytics, DOM manipulation)\n- ‚ùå NEVER import: `import { $effect } from 'svelte'` causes parse errors\n- Return a teardown function from `$effect` for cleanup (e.g., clearing intervals)\n- Use `$effect.pre` for logic that must run before DOM updates\n- Use `$effect.tracking` to check if code is running in a tracking context\n- Use `$effect.root` for creating non-tracked scopes with manual cleanup for nested effects\n- ‚ùå Do not update state inside effects - use `$derived` for derivations instead\n\n## üîÑ Component Communication & Props\n\n- **CRITICAL**: Props are READ-ONLY. Never assign directly to props\n- Destructure props directly from `$props()` for clarity: `let { name } = $props()`\n- Declare fallback values during destructuring: `let { name = \"default\" } = $props()`\n- Rename props during destructuring if they are invalid JavaScript identifiers\n- Use rest properties (`...others`) to capture remaining props\n- Add type safety using TypeScript interfaces or JSDoc\n- Use `$props.id()` (Svelte 5.20.0+) for unique, consistent component instance IDs\n- Use callback properties for child-to-parent communication (replaces `createEventDispatcher`)\n\n## üîó `bind:` Directive (Two-Way Data Binding)\n\n- Use `bind:` for two-way data flow from child to parent\n- Use shorthand `bind:property` when names match\n- Use function bindings (get/set) for validation or transformation (Svelte 5.9.0+)\n- For readonly bindings, set the get function to `null`\n- Access `bind:this` variables inside `$effect` or event handlers (they are undefined until mount)\n- Mark bindable properties with `$bindable()`\n- Provide fallback values for `$bindable()` properties\n\n## üêû Debugging (`$inspect`)\n\n- Use `$inspect` exclusively for development debugging; it tracks reactive state deeply.\n- Use `$inspect.with()` for custom debugging actions (e.g., `debugger`, `console.trace`).\n- Use `$inspect.trace()` (Svelte 5.14+) to trace function re-runs and identify causes.\n\n## ‚ôªÔ∏è Reusable Logic & State\n\n- Use `.svelte.js` and `.svelte.ts` files to create reusable reactive logic and share reactive state using runes.\n- Keep state logic separate from the wire components.\n\n## üß± Component Structure\n\n- Use `<script>` for component-specific logic.\n- Use `<style>` for scoped CSS.\n- Maintain clear data flow and effective architecture for maintainability.\n\n## üîó `bind:` Directive (Two-Way Data Binding)\n\n- Use `bind:` for two-way data flow from child to parent.\n- Use shorthand `bind:property` when names match.\n- Use function bindings (get/set) for validation or transformation (Svelte 5.9.0+).\n- For readonly bindings, set the get function to `null`.\n- Access `bind:this` variables inside `$effect` or event handlers (they are undefined until mount).\n- Mark bindable properties with `$bindable()`.\n- Provide fallback values for `$bindable()` properties.\n\n## üß© Template Syntax\n\n- Use `{#if expression}` for conditionals.\n- Use `{#each expression as item}` for lists.\n- Use `{#key value}` to force re-creation of content.\n- Use `{#await promise}` for managing Promise states.\n- Use snippets for reusable markup chunks.\n\n## üéâ Event Handling\n\n- Use standard HTML attributes for event handling (onclick, onsubmit, etc.)\n- For event modifiers, use wrapper functions instead of the pipe syntax from Svelte 4\n- For multiple handlers, combine them into a single function\n- Keep event handlers simple, moving complex logic to separate functions\n- Remember that event names are lowercase in HTML (onclick, not onClick)Event Handing\n\n## Component Events\n\n- Use callback props instead of event dispatching for component communication\n- Name callback props with an \"on\" prefix (e.g., onSubmit, onChange)\n- Pass data as an object to allow for future extensibility\n- For multiple events, use multiple callback props\n- Consider using TypeScript to type your callback props\n\n## Snippets\n\n- Use snippets to reduce duplication in your templates\n- Snippets can be passed as props to components\n- Snippets have lexical scoping rules - they are only visible in the same scope they are defined in\n- Use parameters to make snippets more flexible\n- Snippets can reference other snippets and even themselves (for recursion)\n\n## üè™ Store\n\n- Use stores only for:\n  - Interoperability with external libraries.\n  - Complex async data streams.\n  - Large apps.\n  - Scenarios needing explicit subscribe/unsubscribe behavior.\n\n## üß† Context\n\n- Store reactive state in context for child component access.\n- Wrap `setContext` and `getContext` in helper functions for type safety.\n- Context can and should be used for small to medium-sized applications to share state between components. It is also ideal for shared state, especially in SSR, as it avoids cross-request data leakage.\n\n## üß† Context\n\n- Store reactive state in context for child component access.\n- Wrap `setContext` and `getContext` in helper functions for type safety.\n- Context is ideal for shared state, especially in SSR, as it avoids cross-request data leakage.\n\n## üß™ Testing\n\n- Use **Vitest** for unit and integration testing.\n- Adjust `vite.config.js` to use browser entry points or alias backend libraries.\n- Include `.svelte` in test filenames for rune processing.\n- Wrap `$effects` in `$effect.root` during tests.\n- Use `flushSync` to run pending effects synchronously.\n- Use https://testing-library.com/docs/svelte-testing-library/intro.\n- Use **Playwright** for E2E testing.\n\n## üì¶ Packages\n\n- Explore new/popular packages at https://www.sveltesociety.dev/packages.\n\n## üîê Security\n\n- To prevent XSS attacks:\n  - Escape strings passed to `{@html ...}`.\n  - Ensure content is from trusted sources.\n  - The expression must be valid standalone HTML.\n\n## üß± Error Boundaries\n\n- Use `onerror` to integrate with error reporting services.\n- Wrap flaky components in `<svelte:boundary>` to isolate errors.\n- `<svelte:boundary>` requires a failed snippet or `onerror` function.\n- It does **not** catch errors outside rendering (e.g., event handlers, `setTimeout`, async work).\n\n\n# Svelte 5 $derived - LLM Context Guide\n\n**CRITICAL: $derived is built-in - NO imports needed. Importing causes parse errors.**\n\n## Syntax Rules\n- ‚úÖ `let x = $derived(expr)` - simple expressions  \n- ‚úÖ `let x = $derived.by(() => {...})` - complex logic\n- ‚úÖ `onclick={handler}` - NOT `on:click`\n- ‚úÖ `<svelte:options runes={true} />`\n- ‚ùå NEVER `import { $derived } from 'svelte/runes'`\n\n## Verified Working Template\n```svelte\n<svelte:options runes={true} />\n<script>\n\tlet count = $state(0);\n\tlet doubled = $derived(count * 2);\n\tconst increment = () => count++;\n</script>\n<div>\n\t<p data-testid=\"count-value\">Count: {count}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>\n```\n\n## $derived.by Example\n```svelte\n<script>\n\tlet items = $state([1, 2, 3]);\n\tlet sum = $derived.by(() => items.reduce((a, b) => a + b, 0));\n\t\n\t// ‚ùå INVALID - Cannot destructure $derived.by() return\n\t// const { wordCount, charCount } = $derived.by(() => ({ ... }));\n\t\n\t// ‚úÖ CORRECT - Store return value first\n\tlet stats = $derived.by(() => {\n\t\tconst words = text.split(' ').length;\n\t\tconst chars = text.length;\n\t\treturn { wordCount: words, charCount: chars, isLong: chars > 50 };\n\t});\n\t// Then access: stats.wordCount, stats.charCount, stats.isLong\n</script>\n```\n\n## Key Behaviors\n- Auto-updates when dependencies change\n- Pure expressions only (no mutations)\n- Push-pull: dependencies notify, values calculate on read\n- Can destructure: `let { a, b } = $derived(obj())` - ONLY simple $derived\n- **CRITICAL**: Cannot destructure `$derived.by()` - store return value first\n- Overridable since 5.25+\n\n# Svelte 5 Each Blocks\n\nIterate over arrays, array-like objects, or iterables (Map, Set) using `{#each}` blocks. Supports destructuring and optional keys for efficient DOM updates.\n\n## Basic Syntax\n\n```svelte\n{#each expression as name}...{/each}\n{#each expression as name, index}...{/each}\n```\n\n```svelte\n<ul>\n\t{#each items as item}\n\t\t<li>{item.name} x {item.qty}</li>\n\t{/each}\n</ul>\n```\n\n## Keyed Each Blocks\n\nUse unique keys to optimize DOM updates when data changes:\n\n```svelte\n{#each expression as name (key)}...{/each}\n```\n\n```svelte\n{#each items as item (item.id)}\n\t<li>{item.name} x {item.qty}</li>\n{/each}\n```\n\nKeys should be strings or numbers for identity persistence.\n\n## Destructuring\n\n```svelte\n{#each items as { id, name, qty }, i (id)}\n\t<li>{i + 1}: {name} x {qty}</li>\n{/each}\n```\n\n## Rendering N Times\n\n```svelte\n{#each { length: 8 }, index}\n\t<div>Item {index}</div>\n{/each}\n```\n\n## Else Clause\n\n```svelte\n{#each todos as todo}\n\t<p>{todo.text}</p>\n{:else}\n\t<p>No tasks today!</p>\n{/each}\n\n# Svelte 5 ‚Äî $effect (compressed)\n\nPurpose: browser-only rune for side effects after mount and after state updates. Do not use for derived state.\n\nCritical rules\n- Runes are built-in; DO NOT import `$state`, `$effect`, etc. (e.g. `import { $effect } from 'svelte/runes'` causes parse errors ‚Äî \"The $ prefix is reserved\").\n- Enable runes with `<svelte:options runes={true} />`.\n- Use `onclick={handler}` (Svelte 5), not `on:click={...}`.\n\nBehavior\n- Runs after component mount and in a microtask after state changes.\n- Dependencies: automatically tracked ‚Äî any `$state`, `$derived`, `$props` read synchronously inside the effect become dependencies.\n- Conditional reads are tracked only when executed (dependency set is recalculated each run).\n- Return a teardown function to cleanup; teardown runs before re-run and on destroy.\n\nSpecial variants\n- `$effect.pre(fn)`: runs before DOM update (useful for measuring DOM & scheduling `tick()`).\n- `$effect.root(fn)`: create a non-tracked scope that doesn't auto-cleanup; returns a `destroy()` to call manually.\n\nWhen to use\n- DOM manipulation (canvas), third-party libs, event listeners, timers, network requests.\n\nWhen NOT to use\n- State synchronization. Use `$derived(...)` for derived/computed state.\n\nCanonical minimal snippets (copy-paste safe)\n\nEnable runes:\n<svelte:options runes={true} />\n\nBasic effect (derived incorrectly shown only for demonstration ‚Äî prefer `$derived` in real code):\n```svelte\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n```\n\nCleanup (interval):\n```svelte\n<script>\n  let count = $state(0);\n  let milliseconds = $state(1000);\n\n  $effect(() => {\n    const interval = setInterval(() => count += 1, milliseconds);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\nPre-effect (before DOM update):\n```svelte\n<script>\n  import { tick } from 'svelte';\n  let div = $state();\n  let messages = $state([]);\n\n  $effect.pre(() => {\n    if (!div) return;\n    messages.length; // track\n    if (div.offsetHeight + div.scrollTop > div.scrollHeight - 20) {\n      tick().then(() => div.scrollTo(0, div.scrollHeight));\n    }\n  });\n</script>\n```\n\nroot scope:\n```js\nconst destroy = $effect.root(() => {\n  $effect(() => { /* setup */ });\n  return () => { /* cleanup */ };\n});\n// later: destroy();\n```\n\nEdge cases / pitfalls\n- Invalid imports break parsing ‚Äî never import `$` runes.\n- Mutating an object vs reassigning: read specific properties to track them (mutating top-level object may not retrigger effects that only read the object reference).\n- Conditional reads: a value read only inside an `if` is only a dependency when that branch executed.\n- Use `$effect.pre` when you must measure DOM before updates.\n- `$effect.root` requires manual cleanup (not auto-cleaned).\n\nTesting & best-practices\n- Include `data-testid` in examples for tests.\n- Prefer `$derived` for computed values; `$effect` only for side effects.\n\nOne-line summary: `$effect` = built-in Svelte 5 side-effect rune; no imports; auto-deps; return teardown for cleanup; use `$derived` for pure derived state.\n\n# Svelte 5 $inspect Rune - Dense Reference\n\n**Dev-only reactive debugger. Re-runs on reactive state changes. Template literals MUST use backticks (`)**\n\n## Core Implementation\n```svelte\n<svelte:options runes={true} />\n<script>\n\tlet text = $state(\"Hello world\");\n\t$inspect(text); // Basic usage\n\t$inspect(text).with((type, value) => { // Custom logging\n\t\tif (type === \"update\") console.log(`Text updated to: \"${value}\"`);\n\t});\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // MUST be first statement\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\t});\n</script>\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n</div>\n```\n\n## Basic Usage\n\nThe simplest form of `$inspect` logs values to the console whenever they change:\n\n```svelte\n<script>\n\tlet count = $state(0);\n\tlet message = $state('hello');\n\n\t$inspect(count, message); // will console.log when `count` or `message` change\n</script>\n\n<button onclick={() => count++}>Increment</button>\n<input bind:value={message} />\n```\n\n## Text Input Example with Quotes\n\nWhen working with text inputs, you often want to display the value with quotes to show empty strings clearly:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// Basic $inspect usage\n\t$inspect(text);\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n\t<p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>\n```\n\nNote: Always wrap text values in quotes when displaying them in UI to make empty strings visible.\n\n## $inspect(...).with\n\n`$inspect` returns a property `with`, which you can invoke with a callback, which will then be invoked instead of `console.log`. The first argument to the callback is either `\"init\"` or `\"update\"`; subsequent arguments are the values passed to `$inspect`.\n\n### Custom Console Logging\n\n**MANDATORY SYNTAX**: Template literals MUST use backticks (`), not quotes:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\n\t// Custom callback for tracking text changes\n\t$inspect(text).with((type, value) => {\n\t\tif (type === \"update\") {\n\t\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t\t}\n\t});\n</script>\n\n<input bind:value={text} />\n```\n\n**CRITICAL**: Always use backticks (`) for template literals:\n- ‚úÖ `console.log(\\`Text updated to: \"${value}\"\\`);`\n- ‚ùå `console.log(Text updated to: \"${value}\");` ‚Üê Missing backticks causes syntax error\n\nThe callback receives:\n- `type`: Either `\"init\"` (first call) or `\"update\"` (subsequent changes)  \n- `value`: The current value being inspected\n\n### Debugging Example\n\n```svelte\n<script>\n\tlet count = $state(0);\n\n\t$inspect(count).with((type, count) => {\n\t\tif (type === 'update') {\n\t\t\tdebugger; // or `console.trace`, or whatever you want\n\t\t}\n\t});\n</script>\n\n<button onclick={() => count++}>Increment</button>\n```\n\nA convenient way to find the origin of some change is to pass `console.trace` to `with`:\n\n```js\n$inspect(stuff).with(console.trace);\n```\n\n## $inspect.trace(...)\n\nThis rune, added in 5.14, causes the surrounding function to be _traced_ in development. Any time the function re-runs as part of an effect or a derived, information will be printed to the console about which pieces of reactive state caused the effect to fire.\n\n**üö® CRITICAL PLACEMENT WARNING**: `$inspect.trace` MUST be the first statement of a function body. Placing it anywhere else will cause a compile error.\n\n### ‚ùå WRONG - $inspect.trace not in first position\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t$effect(() => {\n\t\tconsole.log('[$effect] Input text changed to:', text); // ‚ùå Statement before $inspect.trace\n\t\t$inspect.trace(); // ‚ùå WRONG POSITION - will cause compile error\n\t});\n</script>\n```\n\n**Error**: `$inspect.trace(...)` must be the first statement of a function body\n\n### ‚úÖ CORRECT - $inspect.trace as first statement\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // ‚úÖ CORRECT - First statement\n\t\tconsole.log(`[$effect] Input text changed to: \"${text}\"`);\n\t});\n</script>\n```\n\n### Basic Usage in Effects\n\n**MANDATORY**: Always place `$inspect.trace` as the very first line inside function bodies:\n\n```svelte\n<script>\n\timport { doSomeWork } from './elsewhere';\n\n\t$effect(() => {\n\t\t$inspect.trace(); // ‚úÖ Must be first statement\n\t\tdoSomeWork();\n\t});\n</script>\n```\n\n### Text Input Tracking with Effects\n\nFor text input tracking, combine `$inspect.trace` with effects to monitor changes:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// ‚úÖ CORRECT - $inspect.trace as first statement\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // ‚úÖ Optional label, MUST be first\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\t});\n</script>\n\n<input bind:value={text} />\n```\n\n**CRITICAL SYNTAX RULES:**\n1. ‚úÖ `$inspect.trace()` MUST be the very first statement inside `$effect(() => {`  \n2. ‚ùå NEVER put any other code before `$inspect.trace()`\n3. ‚úÖ Use template literals with backticks: `` console.log(`text: \"${text}\"`) ``\n4. ‚ùå NEVER omit backticks: `console.log(text: \"${text}\")` ‚Üê SYNTAX ERROR\n\n`$inspect.trace` takes an optional first argument which will be used as the label.\n\n## Complete Working Example\n\nHere's a complete example that demonstrates all `$inspect` features with proper formatting:\n\n```svelte\n<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// 1. Basic $inspect usage\n\t$inspect(text);\n\t\n\t// 2. Using $inspect(...).with for custom logging\n\t$inspect(text).with((type, value) => {\n\t\tif (type === \"update\") {\n\t\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t\t}\n\t});\n\t\n\t// 3. MANDATORY: $effect with $inspect.trace AND console.log\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // MUST be first\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`); // REQUIRED\n\t});\n</script>\n\n<div>\n\t<label for=\"text-input\">Edit text:</label>\n\t<input \n\t\tdata-testid=\"text-input\" \n\t\tid=\"text-input\" \n\t\ttype=\"text\" \n\t\tbind:value={text} \n\t/>\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n\t<p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>\n```\n\n## MANDATORY Patterns for Tests\n\n**$effect with $inspect MUST include console.log:**\n```js\n$effect(() => {\n\t$inspect.trace(\"text-changes\"); // Always first statement\n\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`); // REQUIRED format\n});\n```\n\n**$inspect.with MUST check update type:**\n```js\n$inspect(text).with((type, value) => {\n\tif (type === \"update\") { // REQUIRED check\n\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t}\n});\n```\n\n## Key Points for Testing\n\n- Always wrap displayed text values in quotes to show empty strings clearly\n- Use specific console.log message formats for predictable testing\n- Include proper `data-testid` attributes for test targeting\n- The `$inspect(...).with` callback should check for `type === \"update\"` to avoid init logs\n- Console messages should include the exact format: `Text updated to: \"${value}\"`\n- Effect logging should follow the pattern: `The text is now: \"${text}\" (${text.length} characters)`\n\n### Critical Syntax Reminders\n\n**Template Literals**: Always use backticks (`) for template literals, not regular quotes:\n```javascript\n// ‚úÖ CORRECT\nconsole.log(`Text updated to: \"${value}\"`);\nconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\n// ‚ùå WRONG - missing backticks\nconsole.log(Text updated to: \"${value}\");\nconsole.log(The text is now: \"${text}\" (${text.length} characters));\n```\n\n**Input Element**: Always include all required attributes:\n```html\n<!-- ‚úÖ CORRECT -->\n<input \n    data-testid=\"text-input\" \n    id=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n/>\n\n<!-- ‚ùå WRONG - incomplete -->\n<input \n```\n\n# Svelte 5 Props Reference\n\n## Basic Props\n```svelte\n<!-- Parent -->\n<MyComponent adjective=\"cool\" />\n\n<!-- Child -->\n<script>\n  let { adjective } = $props(); // destructured (recommended)\n  let props = $props(); // or access via props.adjective\n</script>\n```\n\n## Fallbacks & Renaming\n```js\nlet { adjective = 'happy' } = $props(); // fallback value\nlet { super: trouper = 'default' } = $props(); // rename invalid identifier\nlet { a, b, ...others } = $props(); // rest props\n```\n\nCall $props() exactly once ‚Äî destructure all props in a single call or use a single props object to avoid the `props_duplicate` compile error.\n\nMinimal correct pattern:\n```svelte\n// correct ‚Äî single $props() call\nlet props = $props(); let { name = \"World\", count = 0, showDetails = false } = props;\n```\n\n## Prop Mutation Rules - CRITICAL\n\n**Props are READ-ONLY. Never assign to props directly:**\n\n‚ùå **FORBIDDEN - Will cause compilation errors:**\n```js\nlet { text } = $props();\ntext = \"new value\"; // ‚ùå COMPILE ERROR - props are read-only\n```\n\n‚úÖ **CORRECT - Use local state for modifications:**\n```js\nlet { text } = $props();\nlet localText = $state(text); // Copy to local state\n// Now modify localText: localText = \"new value\"; ‚úÖ\n```\n\n**Rules:**\n- ‚ùå Direct assignment: `prop = value` causes compilation errors\n- ‚ùå Direct mutation: `prop.property = value` (unless `$bindable`) \n- ‚úÖ Local state: `let local = $state(prop)` then modify `local`\n- ‚úÖ Temporary reassignment: only for local scope override\n- Regular objects: mutations have no effect\n- Reactive proxies: mutations work but trigger warnings\n- Fallback values: not reactive, mutations ignored\n\n## Type Safety\n```svelte\n<script lang=\"ts\">\n  interface Props { adjective: string; }\n  let { adjective }: Props = $props();\n  \n  // Or inline\n  let { adjective }: { adjective: string } = $props();\n  \n  // JSDoc\n  /** @type {{ adjective: string }} */\n  let { adjective } = $props();\n</script>\n```\n\n## Unique IDs\n```svelte\n<script>\n  const uid = $props.id(); // unique per component instance\n</script>\n<label for=\"{uid}-input\">Label</label>\n<input id=\"{uid}-input\" />\n```\n\n## Key Points\n- Props update reactively when parent changes\n- Use callbacks or `$bindable` for child-to-parent communication\n- Fallback values aren't reactive proxies\n- Type annotations recommended for discoverability\n- DOM element interfaces in `svelte/elements`\n\n# Svelte 5 Snippets\n```svelte\n<svelte:options runes={true} />\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n<style></style>\n```\n\n## CRITICAL SYNTAX RULES\n- ‚ùå NEVER use `return` keyword or JSX syntax `<span>`\n- ‚úÖ ALWAYS use pure Svelte template syntax: `{#snippet name(params)}...{/snippet}`\n- ‚ùå NOT: `const title = snippet((param) => { return <span>{param}</span>; })`\n- ‚úÖ CORRECT: `{#snippet title(param)}<span>{param}</span>{/snippet}`\n\n## Basic Syntax\n```svelte\n{#snippet name()}...{/snippet}\n{#snippet name(param1, param2)}...{/snippet}\n{@render name(args)}\n```\n\n## Working Example\n```svelte\n<svelte:options runes={true} />\n<script>\n\tconst items = [\"item1\", \"item2\"];\n</script>\n{#snippet title(text)}\n\t<span data-testid=\"title\">{text}</span>\n{/snippet}\n<ul>\n\t{#each items as item}\n\t\t<li>{@render title(item)}</li>\n\t{/each}\n</ul>\n```\n\n## Scope & Parameters\n- Snippets access lexical scope variables\n- Support default values & destructuring: `{#snippet name(param = default)}`\n- Can reference themselves (recursion) and siblings\n- No rest parameters support\n\n## Component Props\n**Explicit:** `<Table {header} {row} />`\n**Implicit:** Content inside component becomes props automatically\n**Children:** Non-snippet content becomes `children` snippet\n\n```svelte\n<!-- Implicit children -->\n<Button>click me</Button>\n\n<!-- Button.svelte -->\n<script>let { children } = $props();</script>\n<button>{@render children()}</button>\n\n<!-- Optional snippets -->\n{@render children?.()}\n{#if children}{@render children()}{:else}fallback{/if}\n```\n\n## TypeScript\n```svelte\n<script lang=\"ts\">\n\timport type { Snippet } from 'svelte';\n\tinterface Props {\n\t\tchildren: Snippet;\n\t\trow: Snippet<[DataType]>;\n\t}\n\tlet { children, row }: Props = $props();\n</script>\n```\n\n## Export (Svelte 5.5.0+)\n```svelte\n<script module>export { add };</script>\n{#snippet add(a, b)}{a} + {b} = {a + b}{/snippet}\n```\n\n## Key Facts\n- Replace Svelte 4 slots with more power/flexibility\n- Template constructs, not JS functions\n- Avoid props named `children` with implicit children\n- Use `createRawSnippet` API for advanced cases"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// Basic $inspect usage\n\t$inspect(text);\n\t\n\t// Using $inspect(...).with for custom logging\n\t$inspect(text).with((type, value) => {\n\t\tif (type === \"update\") {\n\t\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t\t}\n\t});\n\t\n\t// $inspect.trace inside effect\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\");\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\t});\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n\t<p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0
      }
    ]
  },
  {
    "testName": "props",
    "provider": "LMStudio",
    "modelId": "unsloth/Qwen3-Coder-30B-A3B-Instruct-GGUF",
    "numSamples": 1,
    "numCorrect": 1,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "# Svelte 5 Anti-Patterns\n\n## ‚ùå CRITICAL: Missing Content\n\n- **Do NOT generate empty components!** Always include the actual content requested\n- For \"Hello World\" tasks: MUST display \"Hello, World!\" text, not just structure\n- Template structure alone is insufficient - include the actual requirements\n\n## Event Handling\n\n- Do not use `on:click`, `on:submit`, or other Svelte 4-style event directives in Svelte 5. Use standard HTML event attributes like `onclick`, `onsubmit`, etc. instead.\n\n## Legacy Practices\n\n- Do not rely on implicit reactivity from Svelte 4 (`let` declarations, `$:` statements`).\n- Use modern Svelte 5 APIs instead of legacy APIs (e.g., prefer callback props over `createEventDispatcher`).\n\n## Build Tools\n\n- Use SvelteKit for new projects; do not opt for plain Vite, Rollup, or Webpack plugins.\n  - **Note:** SvelteKit is strongly recommended and centralizes best practices.\n\n## Runes Misuse\n\n### General\n\n- Do not use runes from Svelte 4 and prior (will cause compilation errors).\n- Do not import runes, they are part of the language\n\n### `$state`\n\n- Do not directly mutate `$state.raw` values (will not trigger reactive updates).\n- Do not directly export reassigned `$state` variables from `.svelte.js`/`.svelte.ts` modules (leads to non-reactive behavior for imports).\n- Do not mutate state you do not \"own\" (i.e., only mutate props marked `$bindable`).\n- For large collections, prefer using `$state.raw` for better performance, and always reassign the collection when making changes.\n- When updating state objects, avoid direct mutation of nested properties; instead, create new objects to ensure predictable state changes.\n\n### `$derived`\n\n- Do not change state (e.g., `count++`) directly within `$derived` expressions.\n- Avoid creating circular dependencies between derived values and state, as this can lead to infinite update loops.\n\n### State Management Patterns\n\n- Do not export state variables directly; instead, provide getter and setter functions to access and update state, preserving reactivity.\n- When exporting objects containing state, use getters and setters for stateful properties to maintain reactivity in consuming modules.\n\n### `$effect`\n\n- Do not update state directly within `$effect` functions (can lead to convoluted code and infinite loops).\n- Do not use `$effect` to synchronize state or derive new `$state` variables; use `$derived` for derivations.\n- Do not link mutually dependent input values using `$effect`; use `oninput` callbacks or function bindings instead.\n- Do not assume values read asynchronously (e.g., after `await` or in `setTimeout`) within an `$effect` are tracked as dependencies.\n- Do not expect an `$effect` to re-run when a property inside a mutated object changes if the object reference itself remains the same.\n\n## Component Communication\n\n- Do not directly mutate props unless they are explicitly declared as `$bindable()`.\n- Do not mutate a reactive state proxy passed as a prop in a child component (triggers `ownership_invalid_mutation` warning).\n- Do not mutate fallback values of non-bindable props (will not trigger updates).\n- Do not provide `undefined` to a `$bindable()` property that has a fallback value and is bound (results in a runtime error).\n\n### Common Props Mistakes (Svelte 5)\n\n- Always destructure needed props from `$props()` for reactivity; do not use the whole props object.\n- Always provide default values for optional props when destructuring.\n- Use `$bindable()` for two-way binding props.\n- Do not modify props directly; use callbacks to update parent state.\n- Use TypeScript types for complex props.\n\n## Debugging\n\n- Do not leave `$inspect` calls in production code (clutters code, even if they become no-ops).\n- Do not overuse `$inspect` (leads to overwhelming console output).\n- Do not use `$inspect` as a substitute for well-structured state management.\n\n## Reusable Reactive Logic\n\n- Do not export reassigned state directly from `.svelte.js`/`.svelte.ts` files (results in non-reactive behavior for external imports).\n\n## `bind:` Directive\n\n- Do not use reset buttons in forms too frequently (can lead to accidental data loss ‚Äî more of a UX warning).\n- Do not expect `DataTransfer` to be available for `bind:files` in server-side JavaScript runtimes (state should be left uninitialized for SSR).\n- Do not use dimension bindings (`bind:offsetWidth`, etc.) on elements with `display: inline` (their dimensions are not observable; change display style).\n- Do not expect dimension bindings to update if an element's size changes solely due to CSS transformations.\n- Do not use the `bind:group` directive across different components (only works for inputs within the same Svelte component).\n- Do not provide `undefined` to a bound `$bindable()` property that has a fallback value (results in a runtime error).\n\n## Asynchronous Operations (`{#await...}`)\n\n- Do not expect any branch other than the pending branch of an `{#await}` block to render during server-side rendering (SSR).\n\n## Keyed Blocks (`{#key...}`)\n\n- Do not use a constantly changing key value in `{#key}` blocks (leads to excessive DOM manipulation and potential performance degradation).\n\n## Attributes\n\n- Do not declare custom √üproperties or attributes that start with `on`.\n\n\n# Svelte 5 Best Practices\n\n## üöÄ Essential Setup & Syntax\n\n### Component Structure\n- **MANDATORY**: Always start with `<svelte:options runes={true} />` at the top\n- Use `<script>` for component-specific logic\n- Use `<style>` for scoped CSS\n- Maintain clear data flow and effective architecture for maintainability\n\n- When a task requires exact output (e.g., Hello-World) render the literal text `Hello, World!` inside an element with `data-testid=\"greeting\"` (no comments or computed empty strings).\n\n### Event Handling - CRITICAL CHANGE FROM SVELTE 4\n- ‚úÖ Use standard HTML attributes for event handling (`onclick`, `onsubmit`, etc.)\n- ‚ùå Do NOT use Svelte 4 syntax: `on:click`, `on:submit` will cause errors\n- For event modifiers, use wrapper functions instead of the pipe syntax from Svelte 4\n- For multiple handlers, combine them into a single function\n- Keep event handlers simple, moving complex logic to separate functions\n- Remember that event names are lowercase in HTML (`onclick`, not `onClick`)\n\n### Template Syntax Basics\n- Use `{#if expression}` for conditionals\n- Use `{#each expression as item}` for lists\n- Use `{#key value}` to force re-creation of content\n- Use `{#await promise}` for managing Promise states\n- Use `{variable}` for displaying values\n- Use snippets for reusable markup chunks\n\n## üß† Runes\n\n### `$state` - Reactive Variables\n\n- ‚úÖ Use `$state` for reactive UI state: `let count = $state(0)`\n- ‚úÖ Update `$state` variables directly (they behave like regular JavaScript variables)\n- ‚ùå NEVER import runes: `import { $state } from 'svelte'` causes parse errors\n- Use arrow functions for class methods relying on `this` with reactive state\n- Use `$state.raw` for large arrays/objects where deep reactivity isn't needed\n- Use `$state.snapshot` to get a non-reactive copy of state for external libraries\n- Pass getter functions (e.g., `() => a`) to functions needing the current reactive value of `$state` variables\n- When sharing `$state` from `.svelte.js`/`.svelte.ts` files:\n  - Export an object whose properties are mutated\n  - Or export getter functions\n\n### `$derived` - Computed Values\n\n- ‚úÖ Use `$derived` for computed values that are free of side effects: `let doubled = $derived(count * 2)`\n- ‚ùå NEVER import: `import { $derived } from 'svelte'` causes parse errors\n- Use `$derived.by` for complex derivation logic\n- Derived values can be temporarily reassigned for optimistic UI updates\n\n### `$effect` - Side Effects\n\n- ‚úÖ Use `$effect` for side effects and external interactions (e.g., third-party libraries, API calls, analytics, DOM manipulation)\n- ‚ùå NEVER import: `import { $effect } from 'svelte'` causes parse errors\n- Return a teardown function from `$effect` for cleanup (e.g., clearing intervals)\n- Use `$effect.pre` for logic that must run before DOM updates\n- Use `$effect.tracking` to check if code is running in a tracking context\n- Use `$effect.root` for creating non-tracked scopes with manual cleanup for nested effects\n- ‚ùå Do not update state inside effects - use `$derived` for derivations instead\n\n## üîÑ Component Communication & Props\n\n- **CRITICAL**: Props are READ-ONLY. Never assign directly to props\n- Destructure props directly from `$props()` for clarity: `let { name } = $props()`\n- Declare fallback values during destructuring: `let { name = \"default\" } = $props()`\n- Rename props during destructuring if they are invalid JavaScript identifiers\n- Use rest properties (`...others`) to capture remaining props\n- Add type safety using TypeScript interfaces or JSDoc\n- Use `$props.id()` (Svelte 5.20.0+) for unique, consistent component instance IDs\n- Use callback properties for child-to-parent communication (replaces `createEventDispatcher`)\n\n## üîó `bind:` Directive (Two-Way Data Binding)\n\n- Use `bind:` for two-way data flow from child to parent\n- Use shorthand `bind:property` when names match\n- Use function bindings (get/set) for validation or transformation (Svelte 5.9.0+)\n- For readonly bindings, set the get function to `null`\n- Access `bind:this` variables inside `$effect` or event handlers (they are undefined until mount)\n- Mark bindable properties with `$bindable()`\n- Provide fallback values for `$bindable()` properties\n\n## üêû Debugging (`$inspect`)\n\n- Use `$inspect` exclusively for development debugging; it tracks reactive state deeply.\n- Use `$inspect.with()` for custom debugging actions (e.g., `debugger`, `console.trace`).\n- Use `$inspect.trace()` (Svelte 5.14+) to trace function re-runs and identify causes.\n\n## ‚ôªÔ∏è Reusable Logic & State\n\n- Use `.svelte.js` and `.svelte.ts` files to create reusable reactive logic and share reactive state using runes.\n- Keep state logic separate from the wire components.\n\n## üß± Component Structure\n\n- Use `<script>` for component-specific logic.\n- Use `<style>` for scoped CSS.\n- Maintain clear data flow and effective architecture for maintainability.\n\n## üîó `bind:` Directive (Two-Way Data Binding)\n\n- Use `bind:` for two-way data flow from child to parent.\n- Use shorthand `bind:property` when names match.\n- Use function bindings (get/set) for validation or transformation (Svelte 5.9.0+).\n- For readonly bindings, set the get function to `null`.\n- Access `bind:this` variables inside `$effect` or event handlers (they are undefined until mount).\n- Mark bindable properties with `$bindable()`.\n- Provide fallback values for `$bindable()` properties.\n\n## üß© Template Syntax\n\n- Use `{#if expression}` for conditionals.\n- Use `{#each expression as item}` for lists.\n- Use `{#key value}` to force re-creation of content.\n- Use `{#await promise}` for managing Promise states.\n- Use snippets for reusable markup chunks.\n\n## üéâ Event Handling\n\n- Use standard HTML attributes for event handling (onclick, onsubmit, etc.)\n- For event modifiers, use wrapper functions instead of the pipe syntax from Svelte 4\n- For multiple handlers, combine them into a single function\n- Keep event handlers simple, moving complex logic to separate functions\n- Remember that event names are lowercase in HTML (onclick, not onClick)Event Handing\n\n## Component Events\n\n- Use callback props instead of event dispatching for component communication\n- Name callback props with an \"on\" prefix (e.g., onSubmit, onChange)\n- Pass data as an object to allow for future extensibility\n- For multiple events, use multiple callback props\n- Consider using TypeScript to type your callback props\n\n## Snippets\n\n- Use snippets to reduce duplication in your templates\n- Snippets can be passed as props to components\n- Snippets have lexical scoping rules - they are only visible in the same scope they are defined in\n- Use parameters to make snippets more flexible\n- Snippets can reference other snippets and even themselves (for recursion)\n\n## üè™ Store\n\n- Use stores only for:\n  - Interoperability with external libraries.\n  - Complex async data streams.\n  - Large apps.\n  - Scenarios needing explicit subscribe/unsubscribe behavior.\n\n## üß† Context\n\n- Store reactive state in context for child component access.\n- Wrap `setContext` and `getContext` in helper functions for type safety.\n- Context can and should be used for small to medium-sized applications to share state between components. It is also ideal for shared state, especially in SSR, as it avoids cross-request data leakage.\n\n## üß† Context\n\n- Store reactive state in context for child component access.\n- Wrap `setContext` and `getContext` in helper functions for type safety.\n- Context is ideal for shared state, especially in SSR, as it avoids cross-request data leakage.\n\n## üß™ Testing\n\n- Use **Vitest** for unit and integration testing.\n- Adjust `vite.config.js` to use browser entry points or alias backend libraries.\n- Include `.svelte` in test filenames for rune processing.\n- Wrap `$effects` in `$effect.root` during tests.\n- Use `flushSync` to run pending effects synchronously.\n- Use https://testing-library.com/docs/svelte-testing-library/intro.\n- Use **Playwright** for E2E testing.\n\n## üì¶ Packages\n\n- Explore new/popular packages at https://www.sveltesociety.dev/packages.\n\n## üîê Security\n\n- To prevent XSS attacks:\n  - Escape strings passed to `{@html ...}`.\n  - Ensure content is from trusted sources.\n  - The expression must be valid standalone HTML.\n\n## üß± Error Boundaries\n\n- Use `onerror` to integrate with error reporting services.\n- Wrap flaky components in `<svelte:boundary>` to isolate errors.\n- `<svelte:boundary>` requires a failed snippet or `onerror` function.\n- It does **not** catch errors outside rendering (e.g., event handlers, `setTimeout`, async work).\n\n\n# Svelte 5 $derived - LLM Context Guide\n\n**CRITICAL: $derived is built-in - NO imports needed. Importing causes parse errors.**\n\n## Syntax Rules\n- ‚úÖ `let x = $derived(expr)` - simple expressions  \n- ‚úÖ `let x = $derived.by(() => {...})` - complex logic\n- ‚úÖ `onclick={handler}` - NOT `on:click`\n- ‚úÖ `<svelte:options runes={true} />`\n- ‚ùå NEVER `import { $derived } from 'svelte/runes'`\n\n## Verified Working Template\n```svelte\n<svelte:options runes={true} />\n<script>\n\tlet count = $state(0);\n\tlet doubled = $derived(count * 2);\n\tconst increment = () => count++;\n</script>\n<div>\n\t<p data-testid=\"count-value\">Count: {count}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>\n```\n\n## $derived.by Example\n```svelte\n<script>\n\tlet items = $state([1, 2, 3]);\n\tlet sum = $derived.by(() => items.reduce((a, b) => a + b, 0));\n\t\n\t// ‚ùå INVALID - Cannot destructure $derived.by() return\n\t// const { wordCount, charCount } = $derived.by(() => ({ ... }));\n\t\n\t// ‚úÖ CORRECT - Store return value first\n\tlet stats = $derived.by(() => {\n\t\tconst words = text.split(' ').length;\n\t\tconst chars = text.length;\n\t\treturn { wordCount: words, charCount: chars, isLong: chars > 50 };\n\t});\n\t// Then access: stats.wordCount, stats.charCount, stats.isLong\n</script>\n```\n\n## Key Behaviors\n- Auto-updates when dependencies change\n- Pure expressions only (no mutations)\n- Push-pull: dependencies notify, values calculate on read\n- Can destructure: `let { a, b } = $derived(obj())` - ONLY simple $derived\n- **CRITICAL**: Cannot destructure `$derived.by()` - store return value first\n- Overridable since 5.25+\n\n# Svelte 5 Each Blocks\n\nIterate over arrays, array-like objects, or iterables (Map, Set) using `{#each}` blocks. Supports destructuring and optional keys for efficient DOM updates.\n\n## Basic Syntax\n\n```svelte\n{#each expression as name}...{/each}\n{#each expression as name, index}...{/each}\n```\n\n```svelte\n<ul>\n\t{#each items as item}\n\t\t<li>{item.name} x {item.qty}</li>\n\t{/each}\n</ul>\n```\n\n## Keyed Each Blocks\n\nUse unique keys to optimize DOM updates when data changes:\n\n```svelte\n{#each expression as name (key)}...{/each}\n```\n\n```svelte\n{#each items as item (item.id)}\n\t<li>{item.name} x {item.qty}</li>\n{/each}\n```\n\nKeys should be strings or numbers for identity persistence.\n\n## Destructuring\n\n```svelte\n{#each items as { id, name, qty }, i (id)}\n\t<li>{i + 1}: {name} x {qty}</li>\n{/each}\n```\n\n## Rendering N Times\n\n```svelte\n{#each { length: 8 }, index}\n\t<div>Item {index}</div>\n{/each}\n```\n\n## Else Clause\n\n```svelte\n{#each todos as todo}\n\t<p>{todo.text}</p>\n{:else}\n\t<p>No tasks today!</p>\n{/each}\n\n# Svelte 5 ‚Äî $effect (compressed)\n\nPurpose: browser-only rune for side effects after mount and after state updates. Do not use for derived state.\n\nCritical rules\n- Runes are built-in; DO NOT import `$state`, `$effect`, etc. (e.g. `import { $effect } from 'svelte/runes'` causes parse errors ‚Äî \"The $ prefix is reserved\").\n- Enable runes with `<svelte:options runes={true} />`.\n- Use `onclick={handler}` (Svelte 5), not `on:click={...}`.\n\nBehavior\n- Runs after component mount and in a microtask after state changes.\n- Dependencies: automatically tracked ‚Äî any `$state`, `$derived`, `$props` read synchronously inside the effect become dependencies.\n- Conditional reads are tracked only when executed (dependency set is recalculated each run).\n- Return a teardown function to cleanup; teardown runs before re-run and on destroy.\n\nSpecial variants\n- `$effect.pre(fn)`: runs before DOM update (useful for measuring DOM & scheduling `tick()`).\n- `$effect.root(fn)`: create a non-tracked scope that doesn't auto-cleanup; returns a `destroy()` to call manually.\n\nWhen to use\n- DOM manipulation (canvas), third-party libs, event listeners, timers, network requests.\n\nWhen NOT to use\n- State synchronization. Use `$derived(...)` for derived/computed state.\n\nCanonical minimal snippets (copy-paste safe)\n\nEnable runes:\n<svelte:options runes={true} />\n\nBasic effect (derived incorrectly shown only for demonstration ‚Äî prefer `$derived` in real code):\n```svelte\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n```\n\nCleanup (interval):\n```svelte\n<script>\n  let count = $state(0);\n  let milliseconds = $state(1000);\n\n  $effect(() => {\n    const interval = setInterval(() => count += 1, milliseconds);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\nPre-effect (before DOM update):\n```svelte\n<script>\n  import { tick } from 'svelte';\n  let div = $state();\n  let messages = $state([]);\n\n  $effect.pre(() => {\n    if (!div) return;\n    messages.length; // track\n    if (div.offsetHeight + div.scrollTop > div.scrollHeight - 20) {\n      tick().then(() => div.scrollTo(0, div.scrollHeight));\n    }\n  });\n</script>\n```\n\nroot scope:\n```js\nconst destroy = $effect.root(() => {\n  $effect(() => { /* setup */ });\n  return () => { /* cleanup */ };\n});\n// later: destroy();\n```\n\nEdge cases / pitfalls\n- Invalid imports break parsing ‚Äî never import `$` runes.\n- Mutating an object vs reassigning: read specific properties to track them (mutating top-level object may not retrigger effects that only read the object reference).\n- Conditional reads: a value read only inside an `if` is only a dependency when that branch executed.\n- Use `$effect.pre` when you must measure DOM before updates.\n- `$effect.root` requires manual cleanup (not auto-cleaned).\n\nTesting & best-practices\n- Include `data-testid` in examples for tests.\n- Prefer `$derived` for computed values; `$effect` only for side effects.\n\nOne-line summary: `$effect` = built-in Svelte 5 side-effect rune; no imports; auto-deps; return teardown for cleanup; use `$derived` for pure derived state.\n\n# Svelte 5 $inspect Rune - Dense Reference\n\n**Dev-only reactive debugger. Re-runs on reactive state changes. Template literals MUST use backticks (`)**\n\n## Core Implementation\n```svelte\n<svelte:options runes={true} />\n<script>\n\tlet text = $state(\"Hello world\");\n\t$inspect(text); // Basic usage\n\t$inspect(text).with((type, value) => { // Custom logging\n\t\tif (type === \"update\") console.log(`Text updated to: \"${value}\"`);\n\t});\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // MUST be first statement\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\t});\n</script>\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n</div>\n```\n\n## Basic Usage\n\nThe simplest form of `$inspect` logs values to the console whenever they change:\n\n```svelte\n<script>\n\tlet count = $state(0);\n\tlet message = $state('hello');\n\n\t$inspect(count, message); // will console.log when `count` or `message` change\n</script>\n\n<button onclick={() => count++}>Increment</button>\n<input bind:value={message} />\n```\n\n## Text Input Example with Quotes\n\nWhen working with text inputs, you often want to display the value with quotes to show empty strings clearly:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// Basic $inspect usage\n\t$inspect(text);\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n\t<p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>\n```\n\nNote: Always wrap text values in quotes when displaying them in UI to make empty strings visible.\n\n## $inspect(...).with\n\n`$inspect` returns a property `with`, which you can invoke with a callback, which will then be invoked instead of `console.log`. The first argument to the callback is either `\"init\"` or `\"update\"`; subsequent arguments are the values passed to `$inspect`.\n\n### Custom Console Logging\n\n**MANDATORY SYNTAX**: Template literals MUST use backticks (`), not quotes:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\n\t// Custom callback for tracking text changes\n\t$inspect(text).with((type, value) => {\n\t\tif (type === \"update\") {\n\t\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t\t}\n\t});\n</script>\n\n<input bind:value={text} />\n```\n\n**CRITICAL**: Always use backticks (`) for template literals:\n- ‚úÖ `console.log(\\`Text updated to: \"${value}\"\\`);`\n- ‚ùå `console.log(Text updated to: \"${value}\");` ‚Üê Missing backticks causes syntax error\n\nThe callback receives:\n- `type`: Either `\"init\"` (first call) or `\"update\"` (subsequent changes)  \n- `value`: The current value being inspected\n\n### Debugging Example\n\n```svelte\n<script>\n\tlet count = $state(0);\n\n\t$inspect(count).with((type, count) => {\n\t\tif (type === 'update') {\n\t\t\tdebugger; // or `console.trace`, or whatever you want\n\t\t}\n\t});\n</script>\n\n<button onclick={() => count++}>Increment</button>\n```\n\nA convenient way to find the origin of some change is to pass `console.trace` to `with`:\n\n```js\n$inspect(stuff).with(console.trace);\n```\n\n## $inspect.trace(...)\n\nThis rune, added in 5.14, causes the surrounding function to be _traced_ in development. Any time the function re-runs as part of an effect or a derived, information will be printed to the console about which pieces of reactive state caused the effect to fire.\n\n**üö® CRITICAL PLACEMENT WARNING**: `$inspect.trace` MUST be the first statement of a function body. Placing it anywhere else will cause a compile error.\n\n### ‚ùå WRONG - $inspect.trace not in first position\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t$effect(() => {\n\t\tconsole.log('[$effect] Input text changed to:', text); // ‚ùå Statement before $inspect.trace\n\t\t$inspect.trace(); // ‚ùå WRONG POSITION - will cause compile error\n\t});\n</script>\n```\n\n**Error**: `$inspect.trace(...)` must be the first statement of a function body\n\n### ‚úÖ CORRECT - $inspect.trace as first statement\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // ‚úÖ CORRECT - First statement\n\t\tconsole.log(`[$effect] Input text changed to: \"${text}\"`);\n\t});\n</script>\n```\n\n### Basic Usage in Effects\n\n**MANDATORY**: Always place `$inspect.trace` as the very first line inside function bodies:\n\n```svelte\n<script>\n\timport { doSomeWork } from './elsewhere';\n\n\t$effect(() => {\n\t\t$inspect.trace(); // ‚úÖ Must be first statement\n\t\tdoSomeWork();\n\t});\n</script>\n```\n\n### Text Input Tracking with Effects\n\nFor text input tracking, combine `$inspect.trace` with effects to monitor changes:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// ‚úÖ CORRECT - $inspect.trace as first statement\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // ‚úÖ Optional label, MUST be first\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\t});\n</script>\n\n<input bind:value={text} />\n```\n\n**CRITICAL SYNTAX RULES:**\n1. ‚úÖ `$inspect.trace()` MUST be the very first statement inside `$effect(() => {`  \n2. ‚ùå NEVER put any other code before `$inspect.trace()`\n3. ‚úÖ Use template literals with backticks: `` console.log(`text: \"${text}\"`) ``\n4. ‚ùå NEVER omit backticks: `console.log(text: \"${text}\")` ‚Üê SYNTAX ERROR\n\n`$inspect.trace` takes an optional first argument which will be used as the label.\n\n## Complete Working Example\n\nHere's a complete example that demonstrates all `$inspect` features with proper formatting:\n\n```svelte\n<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// 1. Basic $inspect usage\n\t$inspect(text);\n\t\n\t// 2. Using $inspect(...).with for custom logging\n\t$inspect(text).with((type, value) => {\n\t\tif (type === \"update\") {\n\t\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t\t}\n\t});\n\t\n\t// 3. MANDATORY: $effect with $inspect.trace AND console.log\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // MUST be first\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`); // REQUIRED\n\t});\n</script>\n\n<div>\n\t<label for=\"text-input\">Edit text:</label>\n\t<input \n\t\tdata-testid=\"text-input\" \n\t\tid=\"text-input\" \n\t\ttype=\"text\" \n\t\tbind:value={text} \n\t/>\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n\t<p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>\n```\n\n## MANDATORY Patterns for Tests\n\n**$effect with $inspect MUST include console.log:**\n```js\n$effect(() => {\n\t$inspect.trace(\"text-changes\"); // Always first statement\n\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`); // REQUIRED format\n});\n```\n\n**$inspect.with MUST check update type:**\n```js\n$inspect(text).with((type, value) => {\n\tif (type === \"update\") { // REQUIRED check\n\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t}\n});\n```\n\n## Key Points for Testing\n\n- Always wrap displayed text values in quotes to show empty strings clearly\n- Use specific console.log message formats for predictable testing\n- Include proper `data-testid` attributes for test targeting\n- The `$inspect(...).with` callback should check for `type === \"update\"` to avoid init logs\n- Console messages should include the exact format: `Text updated to: \"${value}\"`\n- Effect logging should follow the pattern: `The text is now: \"${text}\" (${text.length} characters)`\n\n### Critical Syntax Reminders\n\n**Template Literals**: Always use backticks (`) for template literals, not regular quotes:\n```javascript\n// ‚úÖ CORRECT\nconsole.log(`Text updated to: \"${value}\"`);\nconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\n// ‚ùå WRONG - missing backticks\nconsole.log(Text updated to: \"${value}\");\nconsole.log(The text is now: \"${text}\" (${text.length} characters));\n```\n\n**Input Element**: Always include all required attributes:\n```html\n<!-- ‚úÖ CORRECT -->\n<input \n    data-testid=\"text-input\" \n    id=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n/>\n\n<!-- ‚ùå WRONG - incomplete -->\n<input \n```\n\n# Svelte 5 Props Reference\n\n## Basic Props\n```svelte\n<!-- Parent -->\n<MyComponent adjective=\"cool\" />\n\n<!-- Child -->\n<script>\n  let { adjective } = $props(); // destructured (recommended)\n  let props = $props(); // or access via props.adjective\n</script>\n```\n\n## Fallbacks & Renaming\n```js\nlet { adjective = 'happy' } = $props(); // fallback value\nlet { super: trouper = 'default' } = $props(); // rename invalid identifier\nlet { a, b, ...others } = $props(); // rest props\n```\n\nCall $props() exactly once ‚Äî destructure all props in a single call or use a single props object to avoid the `props_duplicate` compile error.\n\nMinimal correct pattern:\n```svelte\n// correct ‚Äî single $props() call\nlet props = $props(); let { name = \"World\", count = 0, showDetails = false } = props;\n```\n\n## Prop Mutation Rules - CRITICAL\n\n**Props are READ-ONLY. Never assign to props directly:**\n\n‚ùå **FORBIDDEN - Will cause compilation errors:**\n```js\nlet { text } = $props();\ntext = \"new value\"; // ‚ùå COMPILE ERROR - props are read-only\n```\n\n‚úÖ **CORRECT - Use local state for modifications:**\n```js\nlet { text } = $props();\nlet localText = $state(text); // Copy to local state\n// Now modify localText: localText = \"new value\"; ‚úÖ\n```\n\n**Rules:**\n- ‚ùå Direct assignment: `prop = value` causes compilation errors\n- ‚ùå Direct mutation: `prop.property = value` (unless `$bindable`) \n- ‚úÖ Local state: `let local = $state(prop)` then modify `local`\n- ‚úÖ Temporary reassignment: only for local scope override\n- Regular objects: mutations have no effect\n- Reactive proxies: mutations work but trigger warnings\n- Fallback values: not reactive, mutations ignored\n\n## Type Safety\n```svelte\n<script lang=\"ts\">\n  interface Props { adjective: string; }\n  let { adjective }: Props = $props();\n  \n  // Or inline\n  let { adjective }: { adjective: string } = $props();\n  \n  // JSDoc\n  /** @type {{ adjective: string }} */\n  let { adjective } = $props();\n</script>\n```\n\n## Unique IDs\n```svelte\n<script>\n  const uid = $props.id(); // unique per component instance\n</script>\n<label for=\"{uid}-input\">Label</label>\n<input id=\"{uid}-input\" />\n```\n\n## Key Points\n- Props update reactively when parent changes\n- Use callbacks or `$bindable` for child-to-parent communication\n- Fallback values aren't reactive proxies\n- Type annotations recommended for discoverability\n- DOM element interfaces in `svelte/elements`\n\n# Svelte 5 Snippets\n```svelte\n<svelte:options runes={true} />\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n<style></style>\n```\n\n## CRITICAL SYNTAX RULES\n- ‚ùå NEVER use `return` keyword or JSX syntax `<span>`\n- ‚úÖ ALWAYS use pure Svelte template syntax: `{#snippet name(params)}...{/snippet}`\n- ‚ùå NOT: `const title = snippet((param) => { return <span>{param}</span>; })`\n- ‚úÖ CORRECT: `{#snippet title(param)}<span>{param}</span>{/snippet}`\n\n## Basic Syntax\n```svelte\n{#snippet name()}...{/snippet}\n{#snippet name(param1, param2)}...{/snippet}\n{@render name(args)}\n```\n\n## Working Example\n```svelte\n<svelte:options runes={true} />\n<script>\n\tconst items = [\"item1\", \"item2\"];\n</script>\n{#snippet title(text)}\n\t<span data-testid=\"title\">{text}</span>\n{/snippet}\n<ul>\n\t{#each items as item}\n\t\t<li>{@render title(item)}</li>\n\t{/each}\n</ul>\n```\n\n## Scope & Parameters\n- Snippets access lexical scope variables\n- Support default values & destructuring: `{#snippet name(param = default)}`\n- Can reference themselves (recursion) and siblings\n- No rest parameters support\n\n## Component Props\n**Explicit:** `<Table {header} {row} />`\n**Implicit:** Content inside component becomes props automatically\n**Children:** Non-snippet content becomes `children` snippet\n\n```svelte\n<!-- Implicit children -->\n<Button>click me</Button>\n\n<!-- Button.svelte -->\n<script>let { children } = $props();</script>\n<button>{@render children()}</button>\n\n<!-- Optional snippets -->\n{@render children?.()}\n{#if children}{@render children()}{:else}fallback{/if}\n```\n\n## TypeScript\n```svelte\n<script lang=\"ts\">\n\timport type { Snippet } from 'svelte';\n\tinterface Props {\n\t\tchildren: Snippet;\n\t\trow: Snippet<[DataType]>;\n\t}\n\tlet { children, row }: Props = $props();\n</script>\n```\n\n## Export (Svelte 5.5.0+)\n```svelte\n<script module>export { add };</script>\n{#snippet add(a, b)}{a} + {b} = {a + b}{/snippet}\n```\n\n## Key Facts\n- Replace Svelte 4 slots with more power/flexibility\n- Template constructs, not JS functions\n- Avoid props named `children` with implicit children\n- Use `createRawSnippet` API for advanced cases"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n<script>\n\tlet { name = \"World\", count = 0, showDetails = false } = $props();\n\tlet localCount = $state(count);\n\t\n\tconst increment = () => {\n\t\tlocalCount++;\n\t};\n</script>\n\n<div>\n\t<h1 data-testid=\"name-display\">Hello, {name}!</h1>\n\t<p data-testid=\"count-display\">Count: {localCount}</p>\n\t<button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n\t\n\t{#if showDetails}\n\t\t<div data-testid=\"details\">\n\t\t\t<p>Name is {name}</p>\n\t\t\t<p>Count is {localCount}</p>\n\t\t\t<p>ShowDetails is {showDetails.toString()}</p>\n\t\t</div>\n\t{/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0
      }
    ]
  },
  {
    "testName": "snippets",
    "provider": "LMStudio",
    "modelId": "unsloth/Qwen3-Coder-30B-A3B-Instruct-GGUF",
    "numSamples": 1,
    "numCorrect": 1,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "# Svelte 5 Anti-Patterns\n\n## ‚ùå CRITICAL: Missing Content\n\n- **Do NOT generate empty components!** Always include the actual content requested\n- For \"Hello World\" tasks: MUST display \"Hello, World!\" text, not just structure\n- Template structure alone is insufficient - include the actual requirements\n\n## Event Handling\n\n- Do not use `on:click`, `on:submit`, or other Svelte 4-style event directives in Svelte 5. Use standard HTML event attributes like `onclick`, `onsubmit`, etc. instead.\n\n## Legacy Practices\n\n- Do not rely on implicit reactivity from Svelte 4 (`let` declarations, `$:` statements`).\n- Use modern Svelte 5 APIs instead of legacy APIs (e.g., prefer callback props over `createEventDispatcher`).\n\n## Build Tools\n\n- Use SvelteKit for new projects; do not opt for plain Vite, Rollup, or Webpack plugins.\n  - **Note:** SvelteKit is strongly recommended and centralizes best practices.\n\n## Runes Misuse\n\n### General\n\n- Do not use runes from Svelte 4 and prior (will cause compilation errors).\n- Do not import runes, they are part of the language\n\n### `$state`\n\n- Do not directly mutate `$state.raw` values (will not trigger reactive updates).\n- Do not directly export reassigned `$state` variables from `.svelte.js`/`.svelte.ts` modules (leads to non-reactive behavior for imports).\n- Do not mutate state you do not \"own\" (i.e., only mutate props marked `$bindable`).\n- For large collections, prefer using `$state.raw` for better performance, and always reassign the collection when making changes.\n- When updating state objects, avoid direct mutation of nested properties; instead, create new objects to ensure predictable state changes.\n\n### `$derived`\n\n- Do not change state (e.g., `count++`) directly within `$derived` expressions.\n- Avoid creating circular dependencies between derived values and state, as this can lead to infinite update loops.\n\n### State Management Patterns\n\n- Do not export state variables directly; instead, provide getter and setter functions to access and update state, preserving reactivity.\n- When exporting objects containing state, use getters and setters for stateful properties to maintain reactivity in consuming modules.\n\n### `$effect`\n\n- Do not update state directly within `$effect` functions (can lead to convoluted code and infinite loops).\n- Do not use `$effect` to synchronize state or derive new `$state` variables; use `$derived` for derivations.\n- Do not link mutually dependent input values using `$effect`; use `oninput` callbacks or function bindings instead.\n- Do not assume values read asynchronously (e.g., after `await` or in `setTimeout`) within an `$effect` are tracked as dependencies.\n- Do not expect an `$effect` to re-run when a property inside a mutated object changes if the object reference itself remains the same.\n\n## Component Communication\n\n- Do not directly mutate props unless they are explicitly declared as `$bindable()`.\n- Do not mutate a reactive state proxy passed as a prop in a child component (triggers `ownership_invalid_mutation` warning).\n- Do not mutate fallback values of non-bindable props (will not trigger updates).\n- Do not provide `undefined` to a `$bindable()` property that has a fallback value and is bound (results in a runtime error).\n\n### Common Props Mistakes (Svelte 5)\n\n- Always destructure needed props from `$props()` for reactivity; do not use the whole props object.\n- Always provide default values for optional props when destructuring.\n- Use `$bindable()` for two-way binding props.\n- Do not modify props directly; use callbacks to update parent state.\n- Use TypeScript types for complex props.\n\n## Debugging\n\n- Do not leave `$inspect` calls in production code (clutters code, even if they become no-ops).\n- Do not overuse `$inspect` (leads to overwhelming console output).\n- Do not use `$inspect` as a substitute for well-structured state management.\n\n## Reusable Reactive Logic\n\n- Do not export reassigned state directly from `.svelte.js`/`.svelte.ts` files (results in non-reactive behavior for external imports).\n\n## `bind:` Directive\n\n- Do not use reset buttons in forms too frequently (can lead to accidental data loss ‚Äî more of a UX warning).\n- Do not expect `DataTransfer` to be available for `bind:files` in server-side JavaScript runtimes (state should be left uninitialized for SSR).\n- Do not use dimension bindings (`bind:offsetWidth`, etc.) on elements with `display: inline` (their dimensions are not observable; change display style).\n- Do not expect dimension bindings to update if an element's size changes solely due to CSS transformations.\n- Do not use the `bind:group` directive across different components (only works for inputs within the same Svelte component).\n- Do not provide `undefined` to a bound `$bindable()` property that has a fallback value (results in a runtime error).\n\n## Asynchronous Operations (`{#await...}`)\n\n- Do not expect any branch other than the pending branch of an `{#await}` block to render during server-side rendering (SSR).\n\n## Keyed Blocks (`{#key...}`)\n\n- Do not use a constantly changing key value in `{#key}` blocks (leads to excessive DOM manipulation and potential performance degradation).\n\n## Attributes\n\n- Do not declare custom √üproperties or attributes that start with `on`.\n\n\n# Svelte 5 Best Practices\n\n## üöÄ Essential Setup & Syntax\n\n### Component Structure\n- **MANDATORY**: Always start with `<svelte:options runes={true} />` at the top\n- Use `<script>` for component-specific logic\n- Use `<style>` for scoped CSS\n- Maintain clear data flow and effective architecture for maintainability\n\n- When a task requires exact output (e.g., Hello-World) render the literal text `Hello, World!` inside an element with `data-testid=\"greeting\"` (no comments or computed empty strings).\n\n### Event Handling - CRITICAL CHANGE FROM SVELTE 4\n- ‚úÖ Use standard HTML attributes for event handling (`onclick`, `onsubmit`, etc.)\n- ‚ùå Do NOT use Svelte 4 syntax: `on:click`, `on:submit` will cause errors\n- For event modifiers, use wrapper functions instead of the pipe syntax from Svelte 4\n- For multiple handlers, combine them into a single function\n- Keep event handlers simple, moving complex logic to separate functions\n- Remember that event names are lowercase in HTML (`onclick`, not `onClick`)\n\n### Template Syntax Basics\n- Use `{#if expression}` for conditionals\n- Use `{#each expression as item}` for lists\n- Use `{#key value}` to force re-creation of content\n- Use `{#await promise}` for managing Promise states\n- Use `{variable}` for displaying values\n- Use snippets for reusable markup chunks\n\n## üß† Runes\n\n### `$state` - Reactive Variables\n\n- ‚úÖ Use `$state` for reactive UI state: `let count = $state(0)`\n- ‚úÖ Update `$state` variables directly (they behave like regular JavaScript variables)\n- ‚ùå NEVER import runes: `import { $state } from 'svelte'` causes parse errors\n- Use arrow functions for class methods relying on `this` with reactive state\n- Use `$state.raw` for large arrays/objects where deep reactivity isn't needed\n- Use `$state.snapshot` to get a non-reactive copy of state for external libraries\n- Pass getter functions (e.g., `() => a`) to functions needing the current reactive value of `$state` variables\n- When sharing `$state` from `.svelte.js`/`.svelte.ts` files:\n  - Export an object whose properties are mutated\n  - Or export getter functions\n\n### `$derived` - Computed Values\n\n- ‚úÖ Use `$derived` for computed values that are free of side effects: `let doubled = $derived(count * 2)`\n- ‚ùå NEVER import: `import { $derived } from 'svelte'` causes parse errors\n- Use `$derived.by` for complex derivation logic\n- Derived values can be temporarily reassigned for optimistic UI updates\n\n### `$effect` - Side Effects\n\n- ‚úÖ Use `$effect` for side effects and external interactions (e.g., third-party libraries, API calls, analytics, DOM manipulation)\n- ‚ùå NEVER import: `import { $effect } from 'svelte'` causes parse errors\n- Return a teardown function from `$effect` for cleanup (e.g., clearing intervals)\n- Use `$effect.pre` for logic that must run before DOM updates\n- Use `$effect.tracking` to check if code is running in a tracking context\n- Use `$effect.root` for creating non-tracked scopes with manual cleanup for nested effects\n- ‚ùå Do not update state inside effects - use `$derived` for derivations instead\n\n## üîÑ Component Communication & Props\n\n- **CRITICAL**: Props are READ-ONLY. Never assign directly to props\n- Destructure props directly from `$props()` for clarity: `let { name } = $props()`\n- Declare fallback values during destructuring: `let { name = \"default\" } = $props()`\n- Rename props during destructuring if they are invalid JavaScript identifiers\n- Use rest properties (`...others`) to capture remaining props\n- Add type safety using TypeScript interfaces or JSDoc\n- Use `$props.id()` (Svelte 5.20.0+) for unique, consistent component instance IDs\n- Use callback properties for child-to-parent communication (replaces `createEventDispatcher`)\n\n## üîó `bind:` Directive (Two-Way Data Binding)\n\n- Use `bind:` for two-way data flow from child to parent\n- Use shorthand `bind:property` when names match\n- Use function bindings (get/set) for validation or transformation (Svelte 5.9.0+)\n- For readonly bindings, set the get function to `null`\n- Access `bind:this` variables inside `$effect` or event handlers (they are undefined until mount)\n- Mark bindable properties with `$bindable()`\n- Provide fallback values for `$bindable()` properties\n\n## üêû Debugging (`$inspect`)\n\n- Use `$inspect` exclusively for development debugging; it tracks reactive state deeply.\n- Use `$inspect.with()` for custom debugging actions (e.g., `debugger`, `console.trace`).\n- Use `$inspect.trace()` (Svelte 5.14+) to trace function re-runs and identify causes.\n\n## ‚ôªÔ∏è Reusable Logic & State\n\n- Use `.svelte.js` and `.svelte.ts` files to create reusable reactive logic and share reactive state using runes.\n- Keep state logic separate from the wire components.\n\n## üß± Component Structure\n\n- Use `<script>` for component-specific logic.\n- Use `<style>` for scoped CSS.\n- Maintain clear data flow and effective architecture for maintainability.\n\n## üîó `bind:` Directive (Two-Way Data Binding)\n\n- Use `bind:` for two-way data flow from child to parent.\n- Use shorthand `bind:property` when names match.\n- Use function bindings (get/set) for validation or transformation (Svelte 5.9.0+).\n- For readonly bindings, set the get function to `null`.\n- Access `bind:this` variables inside `$effect` or event handlers (they are undefined until mount).\n- Mark bindable properties with `$bindable()`.\n- Provide fallback values for `$bindable()` properties.\n\n## üß© Template Syntax\n\n- Use `{#if expression}` for conditionals.\n- Use `{#each expression as item}` for lists.\n- Use `{#key value}` to force re-creation of content.\n- Use `{#await promise}` for managing Promise states.\n- Use snippets for reusable markup chunks.\n\n## üéâ Event Handling\n\n- Use standard HTML attributes for event handling (onclick, onsubmit, etc.)\n- For event modifiers, use wrapper functions instead of the pipe syntax from Svelte 4\n- For multiple handlers, combine them into a single function\n- Keep event handlers simple, moving complex logic to separate functions\n- Remember that event names are lowercase in HTML (onclick, not onClick)Event Handing\n\n## Component Events\n\n- Use callback props instead of event dispatching for component communication\n- Name callback props with an \"on\" prefix (e.g., onSubmit, onChange)\n- Pass data as an object to allow for future extensibility\n- For multiple events, use multiple callback props\n- Consider using TypeScript to type your callback props\n\n## Snippets\n\n- Use snippets to reduce duplication in your templates\n- Snippets can be passed as props to components\n- Snippets have lexical scoping rules - they are only visible in the same scope they are defined in\n- Use parameters to make snippets more flexible\n- Snippets can reference other snippets and even themselves (for recursion)\n\n## üè™ Store\n\n- Use stores only for:\n  - Interoperability with external libraries.\n  - Complex async data streams.\n  - Large apps.\n  - Scenarios needing explicit subscribe/unsubscribe behavior.\n\n## üß† Context\n\n- Store reactive state in context for child component access.\n- Wrap `setContext` and `getContext` in helper functions for type safety.\n- Context can and should be used for small to medium-sized applications to share state between components. It is also ideal for shared state, especially in SSR, as it avoids cross-request data leakage.\n\n## üß† Context\n\n- Store reactive state in context for child component access.\n- Wrap `setContext` and `getContext` in helper functions for type safety.\n- Context is ideal for shared state, especially in SSR, as it avoids cross-request data leakage.\n\n## üß™ Testing\n\n- Use **Vitest** for unit and integration testing.\n- Adjust `vite.config.js` to use browser entry points or alias backend libraries.\n- Include `.svelte` in test filenames for rune processing.\n- Wrap `$effects` in `$effect.root` during tests.\n- Use `flushSync` to run pending effects synchronously.\n- Use https://testing-library.com/docs/svelte-testing-library/intro.\n- Use **Playwright** for E2E testing.\n\n## üì¶ Packages\n\n- Explore new/popular packages at https://www.sveltesociety.dev/packages.\n\n## üîê Security\n\n- To prevent XSS attacks:\n  - Escape strings passed to `{@html ...}`.\n  - Ensure content is from trusted sources.\n  - The expression must be valid standalone HTML.\n\n## üß± Error Boundaries\n\n- Use `onerror` to integrate with error reporting services.\n- Wrap flaky components in `<svelte:boundary>` to isolate errors.\n- `<svelte:boundary>` requires a failed snippet or `onerror` function.\n- It does **not** catch errors outside rendering (e.g., event handlers, `setTimeout`, async work).\n\n\n# Svelte 5 $derived - LLM Context Guide\n\n**CRITICAL: $derived is built-in - NO imports needed. Importing causes parse errors.**\n\n## Syntax Rules\n- ‚úÖ `let x = $derived(expr)` - simple expressions  \n- ‚úÖ `let x = $derived.by(() => {...})` - complex logic\n- ‚úÖ `onclick={handler}` - NOT `on:click`\n- ‚úÖ `<svelte:options runes={true} />`\n- ‚ùå NEVER `import { $derived } from 'svelte/runes'`\n\n## Verified Working Template\n```svelte\n<svelte:options runes={true} />\n<script>\n\tlet count = $state(0);\n\tlet doubled = $derived(count * 2);\n\tconst increment = () => count++;\n</script>\n<div>\n\t<p data-testid=\"count-value\">Count: {count}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>\n```\n\n## $derived.by Example\n```svelte\n<script>\n\tlet items = $state([1, 2, 3]);\n\tlet sum = $derived.by(() => items.reduce((a, b) => a + b, 0));\n\t\n\t// ‚ùå INVALID - Cannot destructure $derived.by() return\n\t// const { wordCount, charCount } = $derived.by(() => ({ ... }));\n\t\n\t// ‚úÖ CORRECT - Store return value first\n\tlet stats = $derived.by(() => {\n\t\tconst words = text.split(' ').length;\n\t\tconst chars = text.length;\n\t\treturn { wordCount: words, charCount: chars, isLong: chars > 50 };\n\t});\n\t// Then access: stats.wordCount, stats.charCount, stats.isLong\n</script>\n```\n\n## Key Behaviors\n- Auto-updates when dependencies change\n- Pure expressions only (no mutations)\n- Push-pull: dependencies notify, values calculate on read\n- Can destructure: `let { a, b } = $derived(obj())` - ONLY simple $derived\n- **CRITICAL**: Cannot destructure `$derived.by()` - store return value first\n- Overridable since 5.25+\n\n# Svelte 5 Each Blocks\n\nIterate over arrays, array-like objects, or iterables (Map, Set) using `{#each}` blocks. Supports destructuring and optional keys for efficient DOM updates.\n\n## Basic Syntax\n\n```svelte\n{#each expression as name}...{/each}\n{#each expression as name, index}...{/each}\n```\n\n```svelte\n<ul>\n\t{#each items as item}\n\t\t<li>{item.name} x {item.qty}</li>\n\t{/each}\n</ul>\n```\n\n## Keyed Each Blocks\n\nUse unique keys to optimize DOM updates when data changes:\n\n```svelte\n{#each expression as name (key)}...{/each}\n```\n\n```svelte\n{#each items as item (item.id)}\n\t<li>{item.name} x {item.qty}</li>\n{/each}\n```\n\nKeys should be strings or numbers for identity persistence.\n\n## Destructuring\n\n```svelte\n{#each items as { id, name, qty }, i (id)}\n\t<li>{i + 1}: {name} x {qty}</li>\n{/each}\n```\n\n## Rendering N Times\n\n```svelte\n{#each { length: 8 }, index}\n\t<div>Item {index}</div>\n{/each}\n```\n\n## Else Clause\n\n```svelte\n{#each todos as todo}\n\t<p>{todo.text}</p>\n{:else}\n\t<p>No tasks today!</p>\n{/each}\n\n# Svelte 5 ‚Äî $effect (compressed)\n\nPurpose: browser-only rune for side effects after mount and after state updates. Do not use for derived state.\n\nCritical rules\n- Runes are built-in; DO NOT import `$state`, `$effect`, etc. (e.g. `import { $effect } from 'svelte/runes'` causes parse errors ‚Äî \"The $ prefix is reserved\").\n- Enable runes with `<svelte:options runes={true} />`.\n- Use `onclick={handler}` (Svelte 5), not `on:click={...}`.\n\nBehavior\n- Runs after component mount and in a microtask after state changes.\n- Dependencies: automatically tracked ‚Äî any `$state`, `$derived`, `$props` read synchronously inside the effect become dependencies.\n- Conditional reads are tracked only when executed (dependency set is recalculated each run).\n- Return a teardown function to cleanup; teardown runs before re-run and on destroy.\n\nSpecial variants\n- `$effect.pre(fn)`: runs before DOM update (useful for measuring DOM & scheduling `tick()`).\n- `$effect.root(fn)`: create a non-tracked scope that doesn't auto-cleanup; returns a `destroy()` to call manually.\n\nWhen to use\n- DOM manipulation (canvas), third-party libs, event listeners, timers, network requests.\n\nWhen NOT to use\n- State synchronization. Use `$derived(...)` for derived/computed state.\n\nCanonical minimal snippets (copy-paste safe)\n\nEnable runes:\n<svelte:options runes={true} />\n\nBasic effect (derived incorrectly shown only for demonstration ‚Äî prefer `$derived` in real code):\n```svelte\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n```\n\nCleanup (interval):\n```svelte\n<script>\n  let count = $state(0);\n  let milliseconds = $state(1000);\n\n  $effect(() => {\n    const interval = setInterval(() => count += 1, milliseconds);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\nPre-effect (before DOM update):\n```svelte\n<script>\n  import { tick } from 'svelte';\n  let div = $state();\n  let messages = $state([]);\n\n  $effect.pre(() => {\n    if (!div) return;\n    messages.length; // track\n    if (div.offsetHeight + div.scrollTop > div.scrollHeight - 20) {\n      tick().then(() => div.scrollTo(0, div.scrollHeight));\n    }\n  });\n</script>\n```\n\nroot scope:\n```js\nconst destroy = $effect.root(() => {\n  $effect(() => { /* setup */ });\n  return () => { /* cleanup */ };\n});\n// later: destroy();\n```\n\nEdge cases / pitfalls\n- Invalid imports break parsing ‚Äî never import `$` runes.\n- Mutating an object vs reassigning: read specific properties to track them (mutating top-level object may not retrigger effects that only read the object reference).\n- Conditional reads: a value read only inside an `if` is only a dependency when that branch executed.\n- Use `$effect.pre` when you must measure DOM before updates.\n- `$effect.root` requires manual cleanup (not auto-cleaned).\n\nTesting & best-practices\n- Include `data-testid` in examples for tests.\n- Prefer `$derived` for computed values; `$effect` only for side effects.\n\nOne-line summary: `$effect` = built-in Svelte 5 side-effect rune; no imports; auto-deps; return teardown for cleanup; use `$derived` for pure derived state.\n\n# Svelte 5 $inspect Rune - Dense Reference\n\n**Dev-only reactive debugger. Re-runs on reactive state changes. Template literals MUST use backticks (`)**\n\n## Core Implementation\n```svelte\n<svelte:options runes={true} />\n<script>\n\tlet text = $state(\"Hello world\");\n\t$inspect(text); // Basic usage\n\t$inspect(text).with((type, value) => { // Custom logging\n\t\tif (type === \"update\") console.log(`Text updated to: \"${value}\"`);\n\t});\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // MUST be first statement\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\t});\n</script>\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n</div>\n```\n\n## Basic Usage\n\nThe simplest form of `$inspect` logs values to the console whenever they change:\n\n```svelte\n<script>\n\tlet count = $state(0);\n\tlet message = $state('hello');\n\n\t$inspect(count, message); // will console.log when `count` or `message` change\n</script>\n\n<button onclick={() => count++}>Increment</button>\n<input bind:value={message} />\n```\n\n## Text Input Example with Quotes\n\nWhen working with text inputs, you often want to display the value with quotes to show empty strings clearly:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// Basic $inspect usage\n\t$inspect(text);\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n\t<p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>\n```\n\nNote: Always wrap text values in quotes when displaying them in UI to make empty strings visible.\n\n## $inspect(...).with\n\n`$inspect` returns a property `with`, which you can invoke with a callback, which will then be invoked instead of `console.log`. The first argument to the callback is either `\"init\"` or `\"update\"`; subsequent arguments are the values passed to `$inspect`.\n\n### Custom Console Logging\n\n**MANDATORY SYNTAX**: Template literals MUST use backticks (`), not quotes:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\n\t// Custom callback for tracking text changes\n\t$inspect(text).with((type, value) => {\n\t\tif (type === \"update\") {\n\t\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t\t}\n\t});\n</script>\n\n<input bind:value={text} />\n```\n\n**CRITICAL**: Always use backticks (`) for template literals:\n- ‚úÖ `console.log(\\`Text updated to: \"${value}\"\\`);`\n- ‚ùå `console.log(Text updated to: \"${value}\");` ‚Üê Missing backticks causes syntax error\n\nThe callback receives:\n- `type`: Either `\"init\"` (first call) or `\"update\"` (subsequent changes)  \n- `value`: The current value being inspected\n\n### Debugging Example\n\n```svelte\n<script>\n\tlet count = $state(0);\n\n\t$inspect(count).with((type, count) => {\n\t\tif (type === 'update') {\n\t\t\tdebugger; // or `console.trace`, or whatever you want\n\t\t}\n\t});\n</script>\n\n<button onclick={() => count++}>Increment</button>\n```\n\nA convenient way to find the origin of some change is to pass `console.trace` to `with`:\n\n```js\n$inspect(stuff).with(console.trace);\n```\n\n## $inspect.trace(...)\n\nThis rune, added in 5.14, causes the surrounding function to be _traced_ in development. Any time the function re-runs as part of an effect or a derived, information will be printed to the console about which pieces of reactive state caused the effect to fire.\n\n**üö® CRITICAL PLACEMENT WARNING**: `$inspect.trace` MUST be the first statement of a function body. Placing it anywhere else will cause a compile error.\n\n### ‚ùå WRONG - $inspect.trace not in first position\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t$effect(() => {\n\t\tconsole.log('[$effect] Input text changed to:', text); // ‚ùå Statement before $inspect.trace\n\t\t$inspect.trace(); // ‚ùå WRONG POSITION - will cause compile error\n\t});\n</script>\n```\n\n**Error**: `$inspect.trace(...)` must be the first statement of a function body\n\n### ‚úÖ CORRECT - $inspect.trace as first statement\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // ‚úÖ CORRECT - First statement\n\t\tconsole.log(`[$effect] Input text changed to: \"${text}\"`);\n\t});\n</script>\n```\n\n### Basic Usage in Effects\n\n**MANDATORY**: Always place `$inspect.trace` as the very first line inside function bodies:\n\n```svelte\n<script>\n\timport { doSomeWork } from './elsewhere';\n\n\t$effect(() => {\n\t\t$inspect.trace(); // ‚úÖ Must be first statement\n\t\tdoSomeWork();\n\t});\n</script>\n```\n\n### Text Input Tracking with Effects\n\nFor text input tracking, combine `$inspect.trace` with effects to monitor changes:\n\n```svelte\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// ‚úÖ CORRECT - $inspect.trace as first statement\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // ‚úÖ Optional label, MUST be first\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\t});\n</script>\n\n<input bind:value={text} />\n```\n\n**CRITICAL SYNTAX RULES:**\n1. ‚úÖ `$inspect.trace()` MUST be the very first statement inside `$effect(() => {`  \n2. ‚ùå NEVER put any other code before `$inspect.trace()`\n3. ‚úÖ Use template literals with backticks: `` console.log(`text: \"${text}\"`) ``\n4. ‚ùå NEVER omit backticks: `console.log(text: \"${text}\")` ‚Üê SYNTAX ERROR\n\n`$inspect.trace` takes an optional first argument which will be used as the label.\n\n## Complete Working Example\n\nHere's a complete example that demonstrates all `$inspect` features with proper formatting:\n\n```svelte\n<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t// 1. Basic $inspect usage\n\t$inspect(text);\n\t\n\t// 2. Using $inspect(...).with for custom logging\n\t$inspect(text).with((type, value) => {\n\t\tif (type === \"update\") {\n\t\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t\t}\n\t});\n\t\n\t// 3. MANDATORY: $effect with $inspect.trace AND console.log\n\t$effect(() => {\n\t\t$inspect.trace(\"text-changes\"); // MUST be first\n\t\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`); // REQUIRED\n\t});\n</script>\n\n<div>\n\t<label for=\"text-input\">Edit text:</label>\n\t<input \n\t\tdata-testid=\"text-input\" \n\t\tid=\"text-input\" \n\t\ttype=\"text\" \n\t\tbind:value={text} \n\t/>\n\t<p data-testid=\"text-value\">Current text: \"{text}\"</p>\n\t<p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>\n```\n\n## MANDATORY Patterns for Tests\n\n**$effect with $inspect MUST include console.log:**\n```js\n$effect(() => {\n\t$inspect.trace(\"text-changes\"); // Always first statement\n\tconsole.log(`The text is now: \"${text}\" (${text.length} characters)`); // REQUIRED format\n});\n```\n\n**$inspect.with MUST check update type:**\n```js\n$inspect(text).with((type, value) => {\n\tif (type === \"update\") { // REQUIRED check\n\t\tconsole.log(`Text updated to: \"${value}\"`);\n\t}\n});\n```\n\n## Key Points for Testing\n\n- Always wrap displayed text values in quotes to show empty strings clearly\n- Use specific console.log message formats for predictable testing\n- Include proper `data-testid` attributes for test targeting\n- The `$inspect(...).with` callback should check for `type === \"update\"` to avoid init logs\n- Console messages should include the exact format: `Text updated to: \"${value}\"`\n- Effect logging should follow the pattern: `The text is now: \"${text}\" (${text.length} characters)`\n\n### Critical Syntax Reminders\n\n**Template Literals**: Always use backticks (`) for template literals, not regular quotes:\n```javascript\n// ‚úÖ CORRECT\nconsole.log(`Text updated to: \"${value}\"`);\nconsole.log(`The text is now: \"${text}\" (${text.length} characters)`);\n\n// ‚ùå WRONG - missing backticks\nconsole.log(Text updated to: \"${value}\");\nconsole.log(The text is now: \"${text}\" (${text.length} characters));\n```\n\n**Input Element**: Always include all required attributes:\n```html\n<!-- ‚úÖ CORRECT -->\n<input \n    data-testid=\"text-input\" \n    id=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n/>\n\n<!-- ‚ùå WRONG - incomplete -->\n<input \n```\n\n# Svelte 5 Props Reference\n\n## Basic Props\n```svelte\n<!-- Parent -->\n<MyComponent adjective=\"cool\" />\n\n<!-- Child -->\n<script>\n  let { adjective } = $props(); // destructured (recommended)\n  let props = $props(); // or access via props.adjective\n</script>\n```\n\n## Fallbacks & Renaming\n```js\nlet { adjective = 'happy' } = $props(); // fallback value\nlet { super: trouper = 'default' } = $props(); // rename invalid identifier\nlet { a, b, ...others } = $props(); // rest props\n```\n\nCall $props() exactly once ‚Äî destructure all props in a single call or use a single props object to avoid the `props_duplicate` compile error.\n\nMinimal correct pattern:\n```svelte\n// correct ‚Äî single $props() call\nlet props = $props(); let { name = \"World\", count = 0, showDetails = false } = props;\n```\n\n## Prop Mutation Rules - CRITICAL\n\n**Props are READ-ONLY. Never assign to props directly:**\n\n‚ùå **FORBIDDEN - Will cause compilation errors:**\n```js\nlet { text } = $props();\ntext = \"new value\"; // ‚ùå COMPILE ERROR - props are read-only\n```\n\n‚úÖ **CORRECT - Use local state for modifications:**\n```js\nlet { text } = $props();\nlet localText = $state(text); // Copy to local state\n// Now modify localText: localText = \"new value\"; ‚úÖ\n```\n\n**Rules:**\n- ‚ùå Direct assignment: `prop = value` causes compilation errors\n- ‚ùå Direct mutation: `prop.property = value` (unless `$bindable`) \n- ‚úÖ Local state: `let local = $state(prop)` then modify `local`\n- ‚úÖ Temporary reassignment: only for local scope override\n- Regular objects: mutations have no effect\n- Reactive proxies: mutations work but trigger warnings\n- Fallback values: not reactive, mutations ignored\n\n## Type Safety\n```svelte\n<script lang=\"ts\">\n  interface Props { adjective: string; }\n  let { adjective }: Props = $props();\n  \n  // Or inline\n  let { adjective }: { adjective: string } = $props();\n  \n  // JSDoc\n  /** @type {{ adjective: string }} */\n  let { adjective } = $props();\n</script>\n```\n\n## Unique IDs\n```svelte\n<script>\n  const uid = $props.id(); // unique per component instance\n</script>\n<label for=\"{uid}-input\">Label</label>\n<input id=\"{uid}-input\" />\n```\n\n## Key Points\n- Props update reactively when parent changes\n- Use callbacks or `$bindable` for child-to-parent communication\n- Fallback values aren't reactive proxies\n- Type annotations recommended for discoverability\n- DOM element interfaces in `svelte/elements`\n\n# Svelte 5 Snippets\n```svelte\n<svelte:options runes={true} />\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n<style></style>\n```\n\n## CRITICAL SYNTAX RULES\n- ‚ùå NEVER use `return` keyword or JSX syntax `<span>`\n- ‚úÖ ALWAYS use pure Svelte template syntax: `{#snippet name(params)}...{/snippet}`\n- ‚ùå NOT: `const title = snippet((param) => { return <span>{param}</span>; })`\n- ‚úÖ CORRECT: `{#snippet title(param)}<span>{param}</span>{/snippet}`\n\n## Basic Syntax\n```svelte\n{#snippet name()}...{/snippet}\n{#snippet name(param1, param2)}...{/snippet}\n{@render name(args)}\n```\n\n## Working Example\n```svelte\n<svelte:options runes={true} />\n<script>\n\tconst items = [\"item1\", \"item2\"];\n</script>\n{#snippet title(text)}\n\t<span data-testid=\"title\">{text}</span>\n{/snippet}\n<ul>\n\t{#each items as item}\n\t\t<li>{@render title(item)}</li>\n\t{/each}\n</ul>\n```\n\n## Scope & Parameters\n- Snippets access lexical scope variables\n- Support default values & destructuring: `{#snippet name(param = default)}`\n- Can reference themselves (recursion) and siblings\n- No rest parameters support\n\n## Component Props\n**Explicit:** `<Table {header} {row} />`\n**Implicit:** Content inside component becomes props automatically\n**Children:** Non-snippet content becomes `children` snippet\n\n```svelte\n<!-- Implicit children -->\n<Button>click me</Button>\n\n<!-- Button.svelte -->\n<script>let { children } = $props();</script>\n<button>{@render children()}</button>\n\n<!-- Optional snippets -->\n{@render children?.()}\n{#if children}{@render children()}{:else}fallback{/if}\n```\n\n## TypeScript\n```svelte\n<script lang=\"ts\">\n\timport type { Snippet } from 'svelte';\n\tinterface Props {\n\t\tchildren: Snippet;\n\t\trow: Snippet<[DataType]>;\n\t}\n\tlet { children, row }: Props = $props();\n</script>\n```\n\n## Export (Svelte 5.5.0+)\n```svelte\n<script module>export { add };</script>\n{#snippet add(a, b)}{a} + {b} = {a + b}{/snippet}\n```\n\n## Key Facts\n- Replace Svelte 4 slots with more power/flexibility\n- Template constructs, not JS functions\n- Avoid props named `children` with implicit children\n- Use `createRawSnippet` API for advanced cases"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n<script>\n\tconst books = [\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"];\n</script>\n\n{#snippet title(text)}\n\t<span data-testid=\"book-title\">{text}</span>\n{/snippet}\n\n<ul>\n\t{#each books as book}\n\t\t<li data-testid=\"book-item\">{@render title(book)}</li>\n\t{/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0
      }
    ]
  }
]